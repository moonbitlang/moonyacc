// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/yacc/lib/elab"

import {
  "moonbitlang/core/immut/array",
  "moonbitlang/core/set",
  "moonbitlang/yacc/lib/ast",
  "moonbitlang/yacc/lib/util/array_multimap",
  "moonbitlang/yacc/lib/util/stamp",
}

// Values
pub fn elaborate(@ast.ParserSpec, String, String, json_cst~ : JsonCst, stdlib_rules? : Map[String, Rule], token_payload_rewrite~ : TokenPayloadRewrite, force_int_position~ : Bool) -> ParserSpec raise ElabError

pub fn elaborate_with_stdlib_rules(@ast.ParserSpec, String, String, json_cst~ : JsonCst, no_std~ : Bool, token_payload_rewrite~ : TokenPayloadRewrite, force_int_position~ : Bool) -> ParserSpec raise ElabError

// Errors
pub suberror ElabError {
  UnresolvedSymbol(String, loc~ : (Int, Int))
  FailedToParseTypeExpr(String)
  OutOfBoundsAccess(Int, loc~ : (Int, Int))
}

// Types and methods
pub(all) struct Action {
  stamp : @stamp.Stamp
  arity : Int
  type_ : TypeExpr
  sub_actions : Array[SubAction]
  bindings : Array[(BindingSubject, String)]
  body : Array[(String, (Int, Int)?)]
  original_clause_info : OriginalClauseInfo
}

pub(all) enum Associativity {
  LeftAssoc
  RightAssoc
  NonAssoc
}

pub(all) enum BindingSubject {
  Data(Int, type_~ : TypeExpr)
  StartPosOf(Int)
  EndPosOf(Int)
  StartPos
  EndPos
  SymbolStartPos
  SubAction(index~ : Int, type_~ : TypeExpr)
}

pub(all) struct Clause {
  items : Array[Item]
  prec : Int?
  action : Action
}

pub(all) struct Item {
  binder : String?
  term : Term
}
pub fn Item::type_(Self) -> TypeExpr

pub(all) enum JsonCst {
  No
  Yes
}

pub(all) struct OriginalClauseInfo {
  file : String
  line : Int
  column : Int
  code : String
}

pub(all) struct ParserSpec {
  header : @array.T[(String, (Int, Int)?)]
  trailer : @array.T[(String, (Int, Int)?)]
  tokens : Array[Token]
  rules : Map[String, Rule]
  start_rules : Array[String]
  position_type : TypeExpr
  derive_map : @array_multimap.T[String, String]
}

pub(all) struct Rule {
  name : String
  inline : Bool
  generic_params : @set.Set[String]
  params : Array[(String, TypeExpr)]
  mut type_ : TypeExpr
  clauses : Array[Clause]
}

pub(all) struct SubAction {
  start : Int
  end : Int
  action : Action
}

pub(all) enum Term {
  Token(Token)
  Param(String, TypeExpr)
  RuleCall(String, Array[Term], TypeExpr)
}

pub(all) struct Token {
  name : String
  mut prec : (Int, Associativity)?
  mut type_ : TypeExpr
  mut image : String?
}

pub(all) enum TokenPayloadRewrite {
  NoPayload
  JsonPayload
  NoRewrite
}

pub(all) enum TypeExpr {
  Constr(pkg~ : String?, String, Array[TypeExpr])
  Param(String)
  Option(TypeExpr)
  Tuple(Array[TypeExpr])
  Arrow(Array[TypeExpr], TypeExpr)
}
pub impl Compare for TypeExpr
pub impl Eq for TypeExpr
pub impl Show for TypeExpr

// Type aliases
pub type Code = String

pub type CodeChunk = (String, (Int, Int)?)

pub type Symbol = String

// Traits

