// Generated by `moon tool embed --text`, do not edit.

///|
let parser_spec_src : String =
  #|%position<Int>
  #|%derive<Show> Token
  #|%start spec
  #|
  #|%token EOF
  #|%token<String> IDENT
  #|%token<String> STRING
  #|%token<String> LANGLE_CODE_RANGLE
  #|%token<(String, Int, Array[@ast.SubstItem])> LBRACE_CODE_RBRACE
  #|%token<(String, Int, Int)> PERCENT_LBRACE_CODE_PERCENT_RBRACE
  #|%token<(String, Int, Int)> PERCENT_PERCENT_CODE_EOF
  #|%token<(String, String)> PKG_AND_IDENT
  #|%token PERCENT_PERCENT "%%"
  #|%token PERCENT_START "%start"
  #|%token PERCENT_TOKEN "%token"
  #|%token PERCENT_TYPE "%type"
  #|%token PERCENT_POSITION "%position"
  #|%token PERCENT_LEFT "%left"
  #|%token PERCENT_RIGHT "%right"
  #|%token PERCENT_NONASSOC "%nonassoc"
  #|%token PERCENT_PREC "%prec"
  #|%token PERCENT_DERIVE "%derive"
  #|%token PERCENT_INLINE "%inline"
  #|%token LBRACKET "["
  #|%token RBRACKET "]"
  #|%token LPAREN "("
  #|%token RPAREN ")"
  #|%token COMMA ","
  #|%token ARROW "->"
  #|%token QUESTION "?"
  #|%token COLON ":"
  #|%token BAR "|"
  #|%token EQ "="
  #|%token SEMI ";"
  #|
  #|%%
  #|
  #|spec -> @ast.ParserSpec
  #|  : decl_list=decl_list "%%" rule_list=rule_list trailer=trailer EOF {
  #|    let decls = decl_list.to_array()
  #|    match trailer {
  #|      Some((code, utf8_pos, subst)) => {
  #|        decls.push(Trailer(code, utf8_pos, subst))
  #|      }
  #|      None => ()
  #|    }
  #|    { decls, rules: rule_list.to_array() }
  #|  }
  #|  ;
  #|
  #|decl_list -> @list.T[@ast.Declaration]
  #|  : decl=decl decl_list=decl_list { @list.construct(decl, decl_list) }
  #|  | { @list.empty() }
  #|  ;
  #|
  #|decl -> @ast.Declaration
  #|  : PERCENT_LBRACE_CODE_PERCENT_RBRACE { Header($1.0, $1.1, $1.2) }
  #|  | "%start" symbol_list=nonempty_symbol_with_loc_list { Start(symbol_list.to_array(), type_=None) }
  #|  | "%start" type_=LANGLE_CODE_RANGLE symbol_list=nonempty_symbol_with_loc_list { Start(symbol_list.to_array(), type_=Some(type_)) }
  #|  | "%token" symbol_list=nonempty_symbol_with_loc_list { Token(symbol_list.to_array(), type_=None) }
  #|  | "%token" type_=LANGLE_CODE_RANGLE symbol_list=nonempty_symbol_with_loc_list { Token(symbol_list.to_array(), type_=Some(type_)) }
  #|  | "%token" symbol=symbol_with_loc image=STRING { Token1(symbol, type_=None, image=image) }
  #|  | "%token" type_=LANGLE_CODE_RANGLE symbol=symbol_with_loc image=STRING { Token1(symbol, type_=Some(type_), image=image) }
  #|  | "%type" type_=LANGLE_CODE_RANGLE symbol_list=nonempty_symbol_with_loc_list { Type(symbol_list.to_array(), type_=type_) }
  #|  | "%position" type_=LANGLE_CODE_RANGLE { Position(type_=type_) }
  #|  | "%left" symbol_list=nonempty_prec_symbol_list { Left(symbol_list.to_array()) }
  #|  | "%right" symbol_list=nonempty_prec_symbol_list { Right(symbol_list.to_array()) }
  #|  | "%nonassoc" symbol_list=nonempty_prec_symbol_list { Nonassoc(symbol_list.to_array()) }
  #|  | "%derive" traits=LANGLE_CODE_RANGLE type_=IDENT { Derive(traits=traits, type_=type_) }
  #|  ;
  #|
  #|rule_list -> @list.T[@ast.Rule]
  #|  : rule=rule { @list.construct(rule, @list.empty()) }
  #|  | rule=rule rule_list=rule_list { @list.construct(rule, rule_list) }
  #|  ;
  #|
  #|trailer -> (@ast.Code, Int, Int)?
  #|  : code=PERCENT_LBRACE_CODE_PERCENT_RBRACE { Some(code) }
  #|  | code=PERCENT_PERCENT_CODE_EOF { Some(code) }
  #|  | { None }
  #|  ;
  #|
  #|rule -> @ast.Rule
  #|  : rule_no_modifiers { $1 }
  #|  | "%inline" rule_no_modifiers { { ..$2, inline: true } }
  #|  ;
  #|
  #|rule_no_modifiers -> @ast.Rule
  #|  : nonterminal=symbol type_=opt_rule_return_type ":" clause_list=clause_list option(";") {
  #|    { inline: false, nonterminal, generic_params: [], params: [], type_, clauses: clause_list.to_array() }
  #|  }
  #|  | nonterminal=symbol generic_params=opt_rule_generic_params "(" param_list=nonempty_rule_param_list ")" type_=opt_rule_return_type ":" clause_list=clause_list option(";") {
  #|    { inline: false, nonterminal, generic_params, params: param_list.to_array(),  type_, clauses: clause_list.to_array() }
  #|  }
  #|  ;
  #|
  #|opt_rule_return_type -> @ast.TypeExpr?
  #|  : "->" type_=type_expr { Some(type_) }
  #|  | { None }
  #|  ;
  #|
  #|nonempty_rule_param_list -> @list.T[(String, @ast.TypeExpr?)]
  #|  : IDENT { @list.construct(($1, None), @list.empty()) }
  #|  | IDENT ":" type_expr { @list.construct(($1, Some($3)), @list.empty()) }
  #|  | IDENT "," nonempty_rule_param_list { @list.construct(($1, None), $3) }
  #|  | IDENT ":" type_expr "," nonempty_rule_param_list { @list.construct(($1, Some($3)), $5) }
  #|  ;
  #|
  #|opt_rule_generic_params -> Array[String]
  #|  : { [] }
  #|  | "[" nonempty_comma_ident_list "]" { $2.to_array() }
  #|  ;
  #|
  #|nonempty_comma_ident_list -> @list.T[String]
  #|  : IDENT { @list.construct($1, @list.empty()) }
  #|  | IDENT "," nonempty_comma_ident_list { @list.construct($1, $3) }
  #|  ;
  #|
  #|type_expr -> @ast.TypeExpr
  #|  : postfix_type_expr { $1 }
  #|  | "(" ")" "->" type_expr { Arrow([], $4) }
  #|  | "(" type_expr ")" "->" type_expr { Arrow([$2], $5) }
  #|  | "(" type_expr "," ")" "->" type_expr { Arrow([$2], $6) }
  #|  | "(" type_expr "," nonempty_type_expr_list ")" "->" type_expr { Arrow(@list.construct($2, $4).to_array(), $7) }
  #|  ;
  #|
  #|postfix_type_expr -> @ast.TypeExpr
  #|  : basic_type_expr { $1 }
  #|  | postfix_type_expr "?" { Option($1) }
  #|  ;
  #|
  #|basic_type_expr -> @ast.TypeExpr
  #|  : IDENT { Constr(pkg=None, $1, []) }
  #|  | PKG_AND_IDENT { Constr(pkg=Some($1.0), $1.1, []) }
  #|  | IDENT "[" nonempty_type_expr_list "]" { Constr(pkg=None, $1, $3.to_array()) }
  #|  | PKG_AND_IDENT "[" nonempty_type_expr_list "]" { Constr(pkg=Some($1.0), $1.1, $3.to_array()) }
  #|  | "(" type_expr "," nonempty_type_expr_list ")" { Tuple(@list.construct($2, $4).to_array()) }
  #|  | "(" type_expr ")" { $2 }
  #|  ;
  #|
  #|nonempty_type_expr_list -> @list.T[@ast.TypeExpr]
  #|  : type_expr=type_expr { @list.construct(type_expr, @list.empty()) }
  #|  | type_expr=type_expr "," type_expr_list=nonempty_type_expr_list { @list.construct(type_expr, type_expr_list) }
  #|  ;
  #|
  #|clause_list -> @list.T[(@list.T[@ast.ClauseWithoutAction], @ast.ClauseAction)]
  #|  : "|" nonempty_clause_list { $2 }
  #|  | nonempty_clause_list { $1 }
  #|  ;
  #|
  #|nonempty_clause_list -> @list.T[(@list.T[@ast.ClauseWithoutAction], @ast.ClauseAction)]
  #|  : clause_woa=clause_without_action action=clause_action { @list.construct((@list.construct(clause_woa, @list.empty()), action), @list.empty()) }
  #|  | clause_woa=clause_without_action action=clause_action "|" clause_list=nonempty_clause_list { @list.construct((@list.construct(clause_woa, @list.empty()), action), clause_list) }
  #|  | clause_woa=nonempty_clause_without_action "|" clause_list=nonempty_clause_list {
  #|    guard clause_list is More((clause_woa_list, action), tail=tail_clause_list)
  #|    @list.construct((@list.construct(clause_woa, clause_woa_list), action), tail_clause_list)
  #|  }
  #|  ;
  #|
  #|%inline clause_without_action -> @ast.ClauseWithoutAction
  #|  : empty_clause_without_action { $1 }
  #|  | nonempty_clause_without_action { $1 }
  #|  ;
  #|
  #|empty_clause_without_action -> @ast.ClauseWithoutAction
  #|  : prec=rule_prec { { items: [], prec, loc: ($startpos, $endpos - $startpos) } }
  #|  ;
  #|
  #|nonempty_clause_without_action -> @ast.ClauseWithoutAction
  #|  : item_list=nonempty_item_list prec=rule_prec { { items: item_list.to_array(), prec, loc: ($startpos, $endpos - $startpos) } }
  #|  ;
  #|
  #|clause_action -> @ast.ClauseAction
  #|  : code=LBRACE_CODE_RBRACE {
  #|      let (code, utf8_pos, subst) = code
  #|      { code: Some({ code, utf8_pos, subst }), loc: ($startpos, $endpos - $startpos) }
  #|  }
  #|  ;
  #|
  #|rule_prec -> @ast.PrecSymbol?
  #|  : "%prec" symbol=prec_symbol { Some(symbol) }
  #|  | { None }
  #|  ;
  #|
  #|nonempty_item_list -> @list.T[@ast.ClauseItem]
  #|  : item=item { @list.construct(item, @list.empty()) }
  #|  | item=item item_list=nonempty_item_list { @list.construct(item, item_list) }
  #|  ;
  #|
  #|item -> @ast.ClauseItem
  #|  : term=term { { binder: None, term: term } }
  #|  | binder=IDENT "=" term=term { { binder: Some(binder), term: term } }
  #|  ;
  #|
  #|term -> @ast.Term
  #|  : symbol=symbol { Symbol(symbol, loc=($startpos, $endpos)) }
  #|  | symbol=symbol "(" nonempty_comma_term_list ")" { RuleCall(symbol, symbol_loc=($startpos(symbol), $endpos(symbol)), $3.to_array()) }
  #|  | image=STRING { Image(image, loc=($startpos, $endpos)) }
  #|  ;
  #|
  #|nonempty_comma_term_list -> @list.T[@ast.Term]
  #|  : term=term { @list.construct(term, @list.empty()) }
  #|  | term=term "," term_list=nonempty_comma_term_list { @list.construct(term, term_list) }
  #|  ;
  #|
  #|nonempty_symbol_with_loc_list -> @list.T[@ast.SymbolWithLoc]
  #|  : symbol=symbol_with_loc { @list.construct(symbol, @list.empty()) }
  #|  | symbol=symbol_with_loc symbol_list=nonempty_symbol_with_loc_list { @list.construct(symbol, symbol_list) }
  #|  ;
  #|
  #|nonempty_prec_symbol_list -> @list.T[@ast.PrecSymbol]
  #|  : symbol=prec_symbol { @list.construct(symbol, @list.empty()) }
  #|  | symbol=prec_symbol symbol_list=nonempty_prec_symbol_list { @list.construct(symbol, symbol_list) }
  #|  ;
  #|
  #|prec_symbol -> @ast.PrecSymbol
  #|  : symbol=symbol { Symbol(symbol) }
  #|  | image=STRING { Image(image) }
  #|  ;
  #|
  #|symbol_with_loc -> @ast.SymbolWithLoc
  #|  : symbol=symbol { { symbol, loc: ($startpos, $endpos) } }
  #|  ;
  #|
  #|symbol -> @ast.Symbol
  #|  : ident=IDENT { ident }
  #|  ;
  #|
