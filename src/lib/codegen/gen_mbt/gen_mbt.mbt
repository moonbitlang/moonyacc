// Copyright (C) 2025 International Digital Economy Academy
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; version 2.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <https://www.gnu.org/licenses/>.

///|
enum CodegenSymbol {
  T(Int, String)
  NT(Int, String)
  EOI
} derive(Eq, Compare)

///|
fn to_string(self : CodegenSymbol) -> String {
  match self {
    T(_, name) => "T_\{name}"
    NT(_, name) => "NT_\{name}"
    EOI => "EOI"
  }
}

///|
enum CodegenDecision {
  Accept
  Shift(Int)
  Reduce(Int, String, Int)
  ReduceNoLookahead(Int, String, Int)
} derive(Eq, Compare)

///|
fn CodegenDecision::to_string(self : CodegenDecision) -> String {
  match self {
    Accept => "Accept"
    Shift(state_num) => "Shift(yy_state_\{state_num})"
    Reduce(num_symbols, nonterm, prod_num) =>
      "Reduce(\{num_symbols}, NT_\{nonterm}, yy_action_\{prod_num})"
    ReduceNoLookahead(num_symbols, nonterm, prod_num) =>
      "ReduceNoLookahead(\{num_symbols}, NT_\{nonterm}, yy_action_\{prod_num})"
  }
}

///|
fn esc(code : String) -> String {
  code
  .replace_all(old="@", new="_")
  .replace_all(old="/", new="_")
  .replace_all(old=".", new="_")
  .replace_all(old="[", new="_")
  .replace_all(old="]", new="_")
  .replace_all(old="(", new="_")
  .replace_all(old=")", new="_")
  .replace_all(old=",", new="_")
  .replace_all(old=" ", new="_")
  .replace_all(old="?", new="_")
}

///|
pub fn codegen_tokens(
  terminals : Array[@grm.Terminal],
  terminal_meta : (String) -> @codegen.TerminalMeta,
  output : &Logger,
  no_comments~ : Bool = false,
  derive_map~ : @immut/hashmap.T[@codegen.PubType, String] = @immut/hashmap.new()
) -> Unit {
  ignore(no_comments)
  fn inject_derive(type_ : @codegen.PubType) -> @codegen.CodeFragment {
    match derive_map[type_] {
      None => ""
      Some(traits) => " derive(\{traits})"
    }
  }

  output.write_string(
    $|pub(all) enum Token {
    $|
    ,
  )
  for term in terminals {
    match terminal_meta(term.name).data_type {
      Some(data_type) =>
        output.write_string(
          $|  \{term.name}(\{data_type})
          $|
          ,
        )
      None =>
        output.write_string(
          $|  \{term.name}
          $|
          ,
        )
    }
  }
  output.write_string(
    $|}\{inject_derive(Token)}
    $|
    $|pub fn Token::kind(self : Token) -> TokenKind {
    $|  match self {
    $|
    ,
  )
  for term in terminals {
    match terminal_meta(term.name).data_type {
      Some(_) =>
        output.write_string(
          $|    \{term.name}(_) => TK_\{term.name}
          $|
          ,
        )
      None =>
        output.write_string(
          $|    \{term.name} => TK_\{term.name}
          $|
          ,
        )
    }
  }
  output.write_string(
    $|  }
    $|}
    $|
    $|
    ,
  )

  // TokenKind
  output.write_string(
    $|pub(all) enum TokenKind {
    $|
    ,
  )
  for term in terminals {
    output.write_string(
      $|  TK_\{term.name}
      $|
      ,
    )
  }
  output.write_string(
    $|}\{inject_derive(TokenKind)}
    $|
    $|
    ,
  )

  // TokenKind::to_string
  output.write_string(
    $|pub impl Show for TokenKind with output(self, logger) {
    $|  logger.write_string(
    $|    match self {
    $|
    ,
  )
  for term in terminals {
    let name = match terminal_meta(term.name).image {
      Some(image) => image
      None => term.name
    }
    output.write_string(
      $|      TK_\{term.name} => \{name.escape()}
      $|
      ,
    )
  }
  output.write_string(
    $|    }
    $|  )
    $|}
    $|
    $|
    ,
  )
}

///|
pub fn codegen(
  grammar : @grm.Grammar,
  automaton : @lr1.Automaton,
  meta : @codegen.MetaProvider,
  output : &Logger,
  external_tokens~ : Bool = false,
  no_comments~ : Bool = false,
  mode~ : @codegen.Mode = Default
) -> Unit {
  let used_runtime_funcs = @sorted_set.new()
  let { terminal_meta, nonterminal_meta, production_meta, .. } = meta
  fn inject_derive(type_ : @codegen.PubType) -> @codegen.CodeFragment {
    match meta.derive_map[type_] {
      None => ""
      Some(traits) => " derive(\{traits})"
    }
  }

  // Header
  output.write_string(meta.header)

  // Position
  output.write_string(
    $|pub(all) typealias Position = \{meta.position_data_type}
    $|
    $|
    ,
  )

  // Token, TokenKind
  if external_tokens {
    ()
  } else {
    codegen_tokens(
      grammar.terminals,
      terminal_meta,
      output,
      no_comments~,
      derive_map=meta.derive_map,
    )
  }

  // ParseError
  output.write_string(
    $|pub(all) type! ParseError {
    $|  UnexpectedToken(Token, (Position, Position), Array[TokenKind])
    $|}\{inject_derive(ParseError)}
    $|
    $|
    ,
  )

  // YYObj_xxx
  output.write_string(
    $|typealias YYObj = Error
    $|
    $|
    ,
  )
  match mode {
    Default => {
      let data_types = @sorted_set.new()
      for term in grammar.terminals {
        let meta = terminal_meta(term.name)
        match meta.data_type {
          Some(data_type) => data_types.add(data_type)
          None => ()
        }
      }
      for nonterm in grammar.nonterminals {
        guard not(grammar.starts.iter().map(fn(p) { p.lhs }).contains(nonterm)) else {
          continue
        }
        let meta = nonterminal_meta(nonterm.name)
        data_types.add(meta.data_type)
      }
      output.write_string(
        $|type! YYObj_Void
        $|
        $|
        ,
      )
      for data_type in data_types {
        output.write_string(
          $|type! YYObj_\{esc(data_type)} \{data_type}
          $|
          $|
          ,
        )
      }
    }
    JsonCst(_) =>
      output.write_string(
        $|type! YYObj_Json Json
        $|
        $|
        ,
      )
  }

  // YYState, YYAction, YYDecision
  output.write_string(
    $|typealias YYState = (YYSymbol) -> YYDecision
    $|
    $|typealias YYAction = (Position, ArrayView[(YYObj, Position, Position)]) -> YYObj
    $|
    $|enum YYDecision {
    $|  Accept
    $|  Shift(YYState)
    $|  Reduce(Int, YYSymbol, YYAction)
    $|  ReduceNoLookahead(Int, YYSymbol, YYAction)
    $|  Error
    $|}
    $|
    $|
    ,
  )

  // YYSymbol
  output.write_string(
    $|enum YYSymbol {
    $|
    ,
  )
  for term in grammar.terminals {
    output.write_string(
      $|  T_\{term.name}
      $|
      ,
    )
  }
  for nonterm in grammar.nonterminals {
    guard not(grammar.starts.iter().map(fn(p) { p.lhs }).contains(nonterm)) else {
      continue
    }
    output.write_string(
      $|  NT_\{nonterm.name}
      $|
      ,
    )
  }
  output.write_string(
    $|  EOI
    $|}
    $|
    $|// Workaround for EOI unused warning
    $|fn init {
    $|  match EOI {
    $|    EOI => ()
    $|    _ => ()
    $|  }
    $|}
    $|
    $|
    ,
  )

  // yy_action_xxx
  for production in grammar.productions {
    guard not(grammar.starts.contains(production)) else { continue }
    let meta = production_meta(production.num)
    output.write_string(
      $|fn yy_action_\{production.num}(_last_pos : Position, _args : ArrayView[(YYObj, Position, Position)]) -> YYObj {
      $|
      ,
    )
    for binding in meta.bindings {
      match binding.0 {
        Data(index) => {
          let symbol = production.rhs[index]
          let data_type = match symbol {
            T(term) => terminal_meta(term.name).data_type.or("Unit")
            NT(nonterm) => nonterminal_meta(nonterm.name).data_type
          }
          output.write_string(
            $|  guard let YYObj_\{esc(data_type)}(\{binding.1}) = _args[\{index}].0
            $|
            ,
          )
        }
        LastPos =>
          output.write_string(
            $|  let \{binding.1} = _last_pos
            $|
            ,
          )
        StartPos(index) | EndPos(index) =>
          if production.rhs.length() == 0 {
            output.write_string(
              $|  let \{binding.1} = _last_pos
              $|
              ,
            )
          } else {
            let field = match binding.0 {
              StartPos(_) => 1
              EndPos(_) => 2
              _ => panic()
            }
            output.write_string(
              $|  let \{binding.1} = _args[\{index}].\{field}
              $|
              ,
            )
          }
        SymbolStartPos => {
          used_runtime_funcs.add("_get_symbol_start_pos")
          output.write_string(
            $|  let \{binding.1} = _get_symbol_start_pos(_args, _last_pos)
            $|
            ,
          )
        }
      }
    }
    output.write_string(
      $|  YYObj_\{esc(nonterminal_meta(production.lhs.name).data_type)}({(); \{meta.body}})
      $|}
      $|
      $|
      ,
    )
  }

  // yy_input
  output.write_string(
    $|fn yy_input(token : Token, _start_pos : Position, _end_pos : Position) -> (YYSymbol, YYObj) {
    $|  match token {
    $|
    ,
  )
  for term in grammar.terminals {
    let meta = terminal_meta(term.name)
    match mode {
      Default =>
        match meta.data_type {
          Some(data_type) =>
            output.write_string(
              $|    \{term.name}(data) => (T_\{term.name}, YYObj_\{esc(data_type)}(data))
              $|
              ,
            )
          None =>
            output.write_string(
              $|    \{term.name} => (T_\{term.name}, YYObj_Void)
              $|
              ,
            )
        }
      JsonCst(_) => {
        let payload_code = match meta.data_type {
          Some(_) => "(data)"
          None => ""
        }
        let data_code = match meta.data_type {
          Some(_) => "data.to_json()"
          None => "Null"
        }
        output.write_string(
          $|    \{term.name}\{payload_code} => (T_\{term.name}, YYObj_Json({
          $|      "type": "TERMINAL",
          $|      "name": "\{term.name}",
          $|      "data": \{data_code},
          $|      "start": _start_pos.to_json(),
          $|      "end": _end_pos.to_json()
          $|    }))
          $|
          ,
        )
      }
    }
  }
  output.write_string(
    $|  }
    $|}
    $|
    $|
    ,
  )

  // yy_state_xxx
  fn emit_state(state : @lr1.LR1State) {
    if not(no_comments) {
      for item in state.iter_item_groups() {
        output.write_string(
          $|// \{item}
          $|
          ,
        )
      }
    }
    output.write_string(
      $|fn yy_state_\{state.num}(_lookahead : YYSymbol) -> YYDecision {
      $|
      ,
    )

    // `sum` is used to detect if it is exhaustive match
    let mut sum = 0
    let decision_groups : @sorted_map.T[
      CodegenDecision,
      @immut/sorted_set.T[CodegenSymbol],
    ] = @sorted_map.new()
    fn add_symbol_decision(symbol, decision) {
      decision_groups[decision] = decision_groups[decision]
        .or(@immut/sorted_set.new())
        .add(symbol)
      match symbol {
        T(num, _) => sum += num
        NT(num, _) => sum += grammar.terminals.length() + num
        EOI => sum += grammar.terminals.length() + grammar.nonterminals.length()
      }
    }

    for input, decision in state.action {
      add_symbol_decision(
        match input {
          Input(term) => T(term.num, term.name)
          EndOfInput => EOI
        },
        match decision {
          Accept => Accept
          Shift(next_state) => Shift(next_state.num)
          Reduce(production) =>
            Reduce(production.rhs.length(), production.lhs.name, production.num)
          Conflict(_) => panic()
        },
      )
    }
    for symbol, state in state.goto {
      match symbol {
        NT(nonterm) =>
          add_symbol_decision(NT(nonterm.num, nonterm.name), Shift(state.num))
        _ => ()
      }
    }
    fn no_lookahead_needed() -> Bool {
      match decision_groups.keys()[0] {
        Reduce(_) | Accept => true
        _ => false
      }
    }

    let mut total = 0
    for term in grammar.terminals {
      total += term.num
    }
    for nonterm in grammar.nonterminals {
      total += grammar.terminals.length() + nonterm.num
    }
    total += grammar.terminals.length() + grammar.nonterminals.length()

    //
    if decision_groups.size() == 1 && no_lookahead_needed() {
      let decision = decision_groups.keys()[0]
      let decision = match decision {
        Reduce(num_symbols, nonterm, prod_num) =>
          ReduceNoLookahead(num_symbols, nonterm, prod_num)
        key => key
      }
      output.write_string(
        $|  \{decision}
        $|
        ,
      )
    } else {
      output.write_string(
        $|  match _lookahead {
        $|
        ,
      )
      for decision, symbols in decision_groups {
        let pattern = String::concat(
          symbols.iter().map(CodegenSymbol::to_string).to_array(),
          separator=" | ",
        )
        output.write_string(
          $|    \{pattern} => \{decision}
          $|
          ,
        )
      }
      let exhaustive = sum == total
      if not(exhaustive) {
        output.write_string(
          $|    _ => Error
          $|
          ,
        )
      }
      output.write_string(
        $|  }
        $|
        ,
      )
    }
    output.write_string(
      $|}
      $|
      $|
      ,
    )
  }

  for state in automaton.states {
    emit_state(state)
  }

  // yy_parse
  output.write_string(
    #|fn yy_parse[T](
    #|  read_token : () -> (Token, Position, Position),
    #|  start_pos : Position,
    #|  start : YYState,
    #|  return_ : (YYObj) -> T
    #|) -> T!ParseError {
    #|  let mut state_stack : @immut/list.T[YYState] = Cons(start, Nil)
    #|  let data_stack : Array[(YYObj, Position, Position)] = []
    #|  let mut last_pos = start_pos
    #|  let mut state = start
    #|  let mut lookahead : Option[(YYSymbol, (YYObj, Position, Position), Token)] = None
    #|  let mut last_shifted_state_stack = state_stack
    #|  while true {
    #|    let decision = match state(EOI) {
    #|      ReduceNoLookahead(_) | Accept as t => t
    #|      _ => {
    #|        match lookahead {
    #|          Some(la) => state(la.0)
    #|          None => {
    #|            let (token, start_pos, end_pos) = read_token()
    #|            let (symbol, data) = yy_input(token, start_pos, end_pos)
    #|            lookahead = Some((symbol, (data, start_pos, end_pos), token))
    #|            state(symbol)
    #|          }
    #|        }
    #|      }
    #|    }
    #|    match decision {
    #|      Accept => return return_(data_stack.unsafe_pop().0)
    #|      Shift(next_state) => {
    #|        guard let Some(la) = lookahead
    #|        data_stack.push(la.1)
    #|        state_stack = Cons(next_state, state_stack)
    #|        last_shifted_state_stack = state_stack
    #|        state = next_state
    #|        last_pos = la.1.2
    #|        let (token, start_pos, end_pos) = read_token()
    #|        let (symbol, data) = yy_input(token, start_pos, end_pos)
    #|        lookahead = Some((symbol, (data, start_pos, end_pos), token))
    #|      }
    #|      Reduce(count, symbol, action)
    #|      | ReduceNoLookahead(count, symbol, action) => {
    #|        loop (count, symbol, action) {
    #|          _ => {
    #|            let args = data_stack[data_stack.length() - count:]
    #|            let data = action(last_pos, args)
    #|            let (start_pos, end_pos) = if args.length() == 0 {
    #|              (last_pos, last_pos)
    #|            } else {
    #|              (args[0].1, args[args.length() - 1].2)
    #|            }
    #|            for i in 0..<count {
    #|              ignore(data_stack.unsafe_pop())
    #|              state_stack = state_stack.tail()
    #|            }
    #|            state = state_stack.unsafe_head()
    #|            data_stack.push((data, start_pos, end_pos))
    #|            match state(symbol) {
    #|              Accept => return return_(data_stack.unsafe_pop().0)
    #|              Shift(next_state) => {
    #|                state_stack = Cons(next_state, state_stack)
    #|                state = next_state
    #|              }
    #|              Reduce(count, symbol, action)
    #|              | ReduceNoLookahead(count, symbol, action) => continue (count, symbol, action)
    #|              _ => panic()
    #|            }
    #|          }
    #|        }
    #|      }
    #|      Error => {
    #|        let (_, (_, start_pos, end_pos), token) = lookahead.unwrap()
    #|        error!(last_shifted_state_stack, token, (start_pos, end_pos))
    #|      }
    #|    }
    #|  }
    #|  panic()
    #|}
    #|
    #|
    ,
  )
  output.write_string(
    $|fn error(stack : @immut/list.T[YYState], token : Token, loc : (Position, Position)) -> Unit!ParseError {
    $|  let expected = []
    $|  fn try_add(symbol : YYSymbol, kind : TokenKind) {
    $|    fn go(stack : @immut/list.T[YYState]) {
    $|      match stack {
    $|        Nil => ()
    $|        Cons(state, _) => {
    $|          match state(symbol) {
    $|            Accept | Shift(_) => expected.push(kind)
    $|            Reduce(count, symbol, _) | ReduceNoLookahead(count, symbol, _) => {
    $|              fn inner_go(stack : @immut/list.T[YYState], count, symbol) {
    $|                let stack = stack.drop(count)
    $|                guard let Cons(state, _) = stack
    $|                match state(symbol) {
    $|                  Shift(state) => go(Cons(state, stack))
    $|                  Reduce(count, symbol, _) | ReduceNoLookahead(count, symbol, _) => inner_go(stack, count, symbol)
    $|                  _ => panic()
    $|                }
    $|              }
    $|              inner_go(stack, count, symbol)
    $|            }
    $|            Error => ()
    $|          }
    $|        }
    $|      }
    $|    }
    $|    go(stack)
    $|  }
    $|
    ,
  )
  // Note: this is a workaround since moonc will stack overflow if the code is too long like this
  // ```
  // for term in grammar.terminals {
  //   output.write_string(
  //     $|  try_add(T_\{term.name}, TK_\{term.name})
  //     $|
  //     ,
  //   )
  // }
  // ```
  output.write_string("  for term in [")
  for i, term in grammar.terminals {
    if i > 0 {
      output.write_string(", ")
    }
    output.write_string("(T_\{term.name}, TK_\{term.name})")
  }
  output.write_string("] {\n")
  output.write_string(
    $|    try_add(term.0, term.1)
    $|  }
    $|
    ,
  )
  output.write_string(
    $|  raise UnexpectedToken(token, loc, expected)
    $|}
    $|
    $|
    ,
  )
  for start in automaton.starts {
    let (start_production, start_state) = start
    let name = start_production.lhs.name
    let original_name = name.substring(
      start=0,
      end=name.length() - "_prime".length(),
    )
    output.write_string(
      $|pub fn \{original_name}(read_token : () -> (Token, Position, Position), start_pos : Position) -> \{nonterminal_meta(name).data_type}!ParseError {
      $|  yy_parse!(
      $|    read_token,
      $|    start_pos,
      $|    yy_state_\{start_state.num},
      $|    fn {
      $|      YYObj_\{esc(nonterminal_meta(name).data_type)}(result) => result
      $|      _ => panic()
      $|    },
      $|  )
      $|}
      $|
      ,
    )
  }

  // Runtime functions
  for func in used_runtime_funcs {
    match func {
      "_get_symbol_start_pos" =>
        output.write_string(
          $|
          $|fn _get_symbol_start_pos(args : ArrayView[(YYObj, Position, Position)], last_pos : Position) -> Position {
          $|  if args.length() == 0 {
          $|    last_pos
          $|  } else {
          $|    for i = 0; i < args.length(); i = i + 1 {
          $|      let (_, start_pos, end_pos) = args[i]
          $|      if start_pos == end_pos {
          $|        continue
          $|      }
          $|      return start_pos
          $|    }
          $|    args[args.length() - 1].2
          $|  }
          $|}
          $|
          ,
        )
      _ => panic()
    }
  }
  match mode {
    Default => ()
    JsonCst(_) =>
      output.write_string(
        $|
        $|fn args_to_json(args : ArrayView[(YYObj, Position, Position)]) -> Json {
        $|  Array(args.iter().map(fn {
        $|    (YYObj_Json(json), _, _) => json
        $|    _ => panic()
        $|  }).to_array())
        $|}
        $|
        ,
      )
  }

  // Footer
  output.write_string(meta.footer)
}
