class $PanicError extends Error {}
function $panic() {
  throw new $PanicError();
}
function $64$moonbitlang$47$core$47$builtin$46$Json$Number(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$builtin$46$Json$Number.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$Json$String(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$String.prototype.$tag = 4;
function $64$moonbitlang$47$core$47$builtin$46$Json$Array(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$Array.prototype.$tag = 5;
function $64$moonbitlang$47$core$47$builtin$46$Json$Object(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$Object.prototype.$tag = 6;
function $bound_check(arr, index) {
  if (index < 0 || index >= arr.length) throw new Error("Index out of bounds");
}
const moonbitlang$core$builtin$$random_seed = () => {
  if (globalThis.crypto?.getRandomValues) {
    const array = new Uint32Array(1);
    globalThis.crypto.getRandomValues(array);
    return array[0] | 0; // Convert to signed 32
  } else {
    return Math.floor(Math.random() * 0x100000000) | 0; // Fallback to Math.random
  }
};
function Result$Err$0$(param0) {
  this._0 = param0;
}
Result$Err$0$.prototype.$tag = 0;
function Result$Ok$0$(param0) {
  this._0 = param0;
}
Result$Ok$0$.prototype.$tag = 1;
function Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$UnresolvedSymbol(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$UnresolvedSymbol.prototype.$tag = 51;
function Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$FailedToParseTypeExpr(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$FailedToParseTypeExpr.prototype.$tag = 50;
function Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$OutOfBoundsAccess(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$OutOfBoundsAccess.prototype.$tag = 49;
const Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void = { $tag: 48 };
function Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_String$46$YYObj_String(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_String$46$YYObj_String.prototype.$tag = 47;
function Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__list_List__ast_TypeExpr_$46$YYObj__list_List__ast_TypeExpr_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__list_List__ast_TypeExpr_$46$YYObj__list_List__ast_TypeExpr_.prototype.$tag = 46;
function Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__String__String_$46$YYObj__String__String_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__String__String_$46$YYObj__String__String_.prototype.$tag = 45;
function Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr.prototype.$tag = 44;
const Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile = { $tag: 43 };
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$Unrecognized(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$Unrecognized.prototype.$tag = 42;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$ParseError$46$UnexpectedToken(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$ParseError$46$UnexpectedToken.prototype.$tag = 41;
const Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void = { $tag: 40 };
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_PrecSymbol_$46$YYObj__list_List__ast_PrecSymbol_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_PrecSymbol_$46$YYObj__list_List__ast_PrecSymbol_.prototype.$tag = 39;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_SymbolWithLoc$46$YYObj__ast_SymbolWithLoc(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_SymbolWithLoc$46$YYObj__ast_SymbolWithLoc.prototype.$tag = 38;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_SymbolWithLoc_$46$YYObj__list_List__ast_SymbolWithLoc_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_SymbolWithLoc_$46$YYObj__list_List__ast_SymbolWithLoc_.prototype.$tag = 37;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration.prototype.$tag = 36;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List_String_$46$YYObj__list_List_String_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List_String_$46$YYObj__list_List_String_.prototype.$tag = 35;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_TypeExpr_$46$YYObj__list_List__ast_TypeExpr_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_TypeExpr_$46$YYObj__list_List__ast_TypeExpr_.prototype.$tag = 34;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__String_$46$YYObj__String__String_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__String_$46$YYObj__String__String_.prototype.$tag = 33;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr.prototype.$tag = 32;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Term_$46$YYObj__list_List__ast_Term_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Term_$46$YYObj__list_List__ast_Term_.prototype.$tag = 31;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String.prototype.$tag = 30;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Term$46$YYObj__ast_Term(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Term$46$YYObj__ast_Term.prototype.$tag = 29;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseItem$46$YYObj__ast_ClauseItem(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseItem$46$YYObj__ast_ClauseItem.prototype.$tag = 28;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_PrecSymbol$46$YYObj__ast_PrecSymbol(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_PrecSymbol$46$YYObj__ast_PrecSymbol.prototype.$tag = 27;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_ClauseItem_$46$YYObj__list_List__ast_ClauseItem_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_ClauseItem_$46$YYObj__list_List__ast_ClauseItem_.prototype.$tag = 26;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_PrecSymbol_$46$YYObj__ast_PrecSymbol_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_PrecSymbol_$46$YYObj__ast_PrecSymbol_.prototype.$tag = 25;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Array__ast_SubstItem__$46$YYObj__String__Int__Array__ast_SubstItem__(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Array__ast_SubstItem__$46$YYObj__String__Int__Array__ast_SubstItem__.prototype.$tag = 24;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseAction$46$YYObj__ast_ClauseAction(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseAction$46$YYObj__ast_ClauseAction.prototype.$tag = 23;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseWithoutAction$46$YYObj__ast_ClauseWithoutAction(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseWithoutAction$46$YYObj__ast_ClauseWithoutAction.prototype.$tag = 22;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Option_Unit_$46$YYObj_Option_Unit_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Option_Unit_$46$YYObj_Option_Unit_.prototype.$tag = 21;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__String___ast_TypeExpr___$46$YYObj__list_List__String___ast_TypeExpr___(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__String___ast_TypeExpr___$46$YYObj__list_List__String___ast_TypeExpr___.prototype.$tag = 20;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Array_String_$46$YYObj_Array_String_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Array_String_$46$YYObj_Array_String_.prototype.$tag = 19;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__.prototype.$tag = 18;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr_$46$YYObj__ast_TypeExpr_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr_$46$YYObj__ast_TypeExpr_.prototype.$tag = 17;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Symbol$46$YYObj__ast_Symbol(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Symbol$46$YYObj__ast_Symbol.prototype.$tag = 16;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Rule$46$YYObj__ast_Rule(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Rule$46$YYObj__ast_Rule.prototype.$tag = 15;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Int_$46$YYObj__String__Int__Int_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Int_$46$YYObj__String__Int__Int_.prototype.$tag = 14;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ParserSpec$46$YYObj__ast_ParserSpec(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ParserSpec$46$YYObj__ast_ParserSpec.prototype.$tag = 13;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj___ast_Code__Int__Int__$46$YYObj___ast_Code__Int__Int__(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj___ast_Code__Int__Int__$46$YYObj___ast_Code__Int__Int__.prototype.$tag = 12;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Rule_$46$YYObj__list_List__ast_Rule_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Rule_$46$YYObj__list_List__ast_Rule_.prototype.$tag = 11;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Declaration_$46$YYObj__list_List__ast_Declaration_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Declaration_$46$YYObj__list_List__ast_Declaration_.prototype.$tag = 10;
function Error$Yoorkin$47$ArgParser$46$ErrorMsg$46$ErrorMsg(param0) {
  this._0 = param0;
}
Error$Yoorkin$47$ArgParser$46$ErrorMsg$46$ErrorMsg.prototype.$tag = 9;
function Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseOrLexError$46$ParseError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseOrLexError$46$ParseError.prototype.$tag = 8;
function Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseOrLexError$46$LexError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseOrLexError$46$LexError.prototype.$tag = 7;
function Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError.prototype.$tag = 6;
function Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError.prototype.$tag = 5;
const Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$IndexOutOfBounds = { $tag: 4 };
const Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$InvalidIndex = { $tag: 3 };
function Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$LexError$46$Unrecognized(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$LexError$46$Unrecognized.prototype.$tag = 2;
function Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseError$46$UnexpectedToken(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseError$46$UnexpectedToken.prototype.$tag = 1;
function Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseError$46$UnexpectedEndOfInput(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseError$46$UnexpectedEndOfInput.prototype.$tag = 0;
const moonbitlang$core$builtin$$int_to_string_js = (x, radix) => {
  return x.toString(radix);
};
function $makebytes(a, b) {
  const arr = new Uint8Array(a);
  if (b !== 0) {
    arr.fill(b);
  }
  return arr;
}
function $unsafe_make_string(a, b) {
  return String.fromCodePoint(b).repeat(a);
}
function $make_array_len_and_init(a, b) {
  const arr = new Array(a);
  arr.fill(b);
  return arr;
}
const moonbitlang$core$builtin$$JSArray$push = (arr, val) => { arr.push(val); };
const Option$None$1$ = { $tag: 0 };
function Option$Some$1$(param0) {
  this._0 = param0;
}
Option$Some$1$.prototype.$tag = 1;
function $compare_int(a, b) {
  return (a >= b) - (a <= b);
}
const moonbitlang$core$builtin$$try_init_wasm_helper = function() {
  try {
    return new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch (e) {
    return undefined;
  }
};
const moonbitlang$core$builtin$$MyInt64$div_bigint = (a, b) => {
  const aVal = (BigInt(a.hi) << 32n) | BigInt(a.lo >>> 0);
  const bVal = (BigInt(b.hi) << 32n) | BigInt(b.lo >>> 0);
  const result = aVal / bVal;
  const lo = Number(result & 0xFFFFFFFFn);
  const hi = Number((result >> 32n) & 0xFFFFFFFFn);
  return { hi: hi | 0, lo: lo | 0 };
};
const moonbitlang$core$builtin$$MyInt64$compare = (a, b) => {
  const ahi = a.hi;
  const bhi = b.hi;
  if (ahi < bhi) {
    return -1;
  }
  if (ahi > bhi) {
    return 1;
  }
  const alo = a.lo >>> 0;
  const blo = b.lo >>> 0;
  if (alo < blo) {
    return -1;
  }
  if (alo > blo) {
    return 1;
  }
  return 0;
};
const moonbitlang$core$builtin$$JSArray$copy = (arr) => arr.slice(0);
const $bytes_literal$0 = new Uint8Array();
const moonbitlang$core$builtin$$JSArray$pop = (arr) => arr.pop();
const moonbitlang$core$builtin$$JSArray$splice = (arr, idx, cnt) => arr.splice(idx, cnt);
const moonbitlang$core$double$internal$ryu$$ryu_to_string = (number) => number.toString();
function Result$Err$2$(param0) {
  this._0 = param0;
}
Result$Err$2$.prototype.$tag = 0;
function Result$Ok$2$(param0) {
  this._0 = param0;
}
Result$Ok$2$.prototype.$tag = 1;
function Result$Err$3$(param0) {
  this._0 = param0;
}
Result$Err$3$.prototype.$tag = 0;
function Result$Ok$3$(param0) {
  this._0 = param0;
}
Result$Ok$3$.prototype.$tag = 1;
function Result$Err$4$(param0) {
  this._0 = param0;
}
Result$Err$4$.prototype.$tag = 0;
function Result$Ok$4$(param0) {
  this._0 = param0;
}
Result$Ok$4$.prototype.$tag = 1;
function Result$Err$5$(param0) {
  this._0 = param0;
}
Result$Err$5$.prototype.$tag = 0;
function Result$Ok$5$(param0) {
  this._0 = param0;
}
Result$Ok$5$.prototype.$tag = 1;
const $9223372036854775807L = { hi: 2147483647, lo: -1 };
const $10L = { hi: 0, lo: 10 };
const $1L = { hi: 0, lo: 1 };
const $16L = { hi: 0, lo: 16 };
const $_9223372036854775808L = { hi: -2147483648, lo: 0 };
const $0L = { hi: 0, lo: 0 };
function $64$moonbitlang$47$core$47$json$46$WriteFrame$Array(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$json$46$WriteFrame$Array.prototype.$tag = 0;
function $64$moonbitlang$47$core$47$json$46$WriteFrame$Object(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$json$46$WriteFrame$Object.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$6$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$6$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$6$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$6$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$6$.prototype.$tag = 2;
const $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$7$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$7$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$7$.prototype.$tag = 2;
const $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$8$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$8$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$8$.prototype.$tag = 2;
const $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$9$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$9$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$9$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$9$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$9$.prototype.$tag = 2;
const $64$moonbitlang$47$core$47$list$46$List$Empty$10$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$10$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$10$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$11$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$11$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$11$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$12$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$12$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$12$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$13$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$13$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$13$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$14$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$14$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$14$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$15$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$15$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$15$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$16$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$16$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$16$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$17$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$17$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$17$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$18$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$18$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$18$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$19$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$19$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$19$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$20$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$20$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$20$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$21$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$21$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$21$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$22$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$22$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$22$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$23$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$23$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$23$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$list$46$List$Empty$24$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$list$46$List$More$24$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$list$46$List$More$24$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$25$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Tree$25$(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Tree$25$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$26$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Tree$26$(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Tree$26$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Empty$27$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Node$27$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Node$27$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Empty$28$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Node$28$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Node$28$.prototype.$tag = 1;
const Option$None$29$ = { $tag: 0 };
function Option$Some$29$(param0) {
  this._0 = param0;
}
Option$Some$29$.prototype.$tag = 1;
const Option$None$30$ = { $tag: 0 };
function Option$Some$30$(param0) {
  this._0 = param0;
}
Option$Some$30$.prototype.$tag = 1;
const Option$None$31$ = { $tag: 0 };
function Option$Some$31$(param0) {
  this._0 = param0;
}
Option$Some$31$.prototype.$tag = 1;
const Option$None$32$ = { $tag: 0 };
function Option$Some$32$(param0) {
  this._0 = param0;
}
Option$Some$32$.prototype.$tag = 1;
function Result$Err$33$(param0) {
  this._0 = param0;
}
Result$Err$33$.prototype.$tag = 0;
function Result$Ok$33$(param0) {
  this._0 = param0;
}
Result$Ok$33$.prototype.$tag = 1;
function Result$Err$34$(param0) {
  this._0 = param0;
}
Result$Err$34$.prototype.$tag = 0;
function Result$Ok$34$(param0) {
  this._0 = param0;
}
Result$Ok$34$.prototype.$tag = 1;
function $64$Yoorkin$47$ArgParser$46$Spec$Unit(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Unit.prototype.$tag = 0;
function $64$Yoorkin$47$ArgParser$46$Spec$String(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$String.prototype.$tag = 1;
function $64$Yoorkin$47$ArgParser$46$Spec$Set_string(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Set_string.prototype.$tag = 2;
function $64$Yoorkin$47$ArgParser$46$Spec$Set(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Set.prototype.$tag = 3;
function $64$Yoorkin$47$ArgParser$46$Spec$Clear(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Clear.prototype.$tag = 4;
const moonbitlang$x$fs$$read_file_ffi = function(path) {
   var fs = require('fs');
   try {
     const content = fs.readFileSync(path);
     globalThis.fileContent = content;
     return 0;
   } catch (error) {
     globalThis.errorMessage = error.message;
     return -1;
   }
 };
const moonbitlang$x$fs$$write_file_ffi = function(path, content) {
   var fs = require('fs');
   try {
     fs.writeFileSync(path, Buffer.from(content));
     return 0;
   } catch (error) {
     globalThis.errorMessage = error.message;
     return -1;
   }
 };
const moonbitlang$x$fs$$get_file_content_ffi = function() {
   return globalThis.fileContent;
 };
const moonbitlang$x$fs$$get_error_message_ffi = function() {
   return globalThis.errorMessage || '';
 };
function Result$Err$35$(param0) {
  this._0 = param0;
}
Result$Err$35$.prototype.$tag = 0;
function Result$Ok$35$(param0) {
  this._0 = param0;
}
Result$Ok$35$.prototype.$tag = 1;
function Result$Err$36$(param0) {
  this._0 = param0;
}
Result$Err$36$.prototype.$tag = 0;
function Result$Ok$36$(param0) {
  this._0 = param0;
}
Result$Ok$36$.prototype.$tag = 1;
function Result$Err$37$(param0) {
  this._0 = param0;
}
Result$Err$37$.prototype.$tag = 0;
function Result$Ok$37$(param0) {
  this._0 = param0;
}
Result$Ok$37$.prototype.$tag = 1;
const moonbitlang$x$sys$internal$ffi$$get_cli_args_internal = function() {
  return process.argv.slice(1);
 };
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Header(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Header.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Trailer(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Trailer.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Start(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Start.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Token(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Token.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Token1(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Token1.prototype.$tag = 4;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Type(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Type.prototype.$tag = 5;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Derive(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Derive.prototype.$tag = 6;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Position(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Position.prototype.$tag = 7;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Left(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Left.prototype.$tag = 8;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Right(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Right.prototype.$tag = 9;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Nonassoc(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Nonassoc.prototype.$tag = 10;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Term$Symbol(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Term$Symbol.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Term$Image(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Term$Image.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$Term$RuleCall(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$Term$RuleCall.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Option(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Option.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Tuple(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Tuple.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$PrecSymbol$Symbol(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$PrecSymbol$Symbol.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$PrecSymbol$Image(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$PrecSymbol$Image.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Accept = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead.prototype.$tag = 3;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error = { $tag: 4 };
function Result$Err$38$(param0) {
  this._0 = param0;
}
Result$Err$38$.prototype.$tag = 0;
function Result$Ok$38$(param0) {
  this._0 = param0;
}
Result$Ok$38$.prototype.$tag = 1;
function Result$Err$39$(param0) {
  this._0 = param0;
}
Result$Err$39$.prototype.$tag = 0;
function Result$Ok$39$(param0) {
  this._0 = param0;
}
Result$Ok$39$.prototype.$tag = 1;
function Result$Err$40$(param0) {
  this._0 = param0;
}
Result$Err$40$.prototype.$tag = 0;
function Result$Ok$40$(param0) {
  this._0 = param0;
}
Result$Ok$40$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$Dollar(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$Dollar.prototype.$tag = 0;
const $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$StartPos = { $tag: 1 };
const $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$EndPos = { $tag: 2 };
const $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$Loc = { $tag: 3 };
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$StartPosOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$StartPosOf.prototype.$tag = 4;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$EndPosOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$EndPosOf.prototype.$tag = 5;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$LocOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$LocOf.prototype.$tag = 6;
const $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$SymbolStartPos = { $tag: 7 };
const $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$Sloc = { $tag: 8 };
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$ClauseItemIdent$Dollar(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$ClauseItemIdent$Dollar.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$ast$46$ClauseItemIdent$Name(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$ast$46$ClauseItemIdent$Name.prototype.$tag = 1;
function Result$Err$41$(param0) {
  this._0 = param0;
}
Result$Err$41$.prototype.$tag = 0;
function Result$Ok$41$(param0) {
  this._0 = param0;
}
Result$Ok$41$.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$EOF = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$IDENT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$IDENT.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$STRING(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$STRING.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LANGLE_CODE_RANGLE(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LANGLE_CODE_RANGLE.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LBRACE_CODE_RBRACE(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LBRACE_CODE_RBRACE.prototype.$tag = 4;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LBRACE_CODE_PERCENT_RBRACE(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LBRACE_CODE_PERCENT_RBRACE.prototype.$tag = 5;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT_CODE_EOF(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT_CODE_EOF.prototype.$tag = 6;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PKG_AND_IDENT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PKG_AND_IDENT.prototype.$tag = 7;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT = { $tag: 8 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_START = { $tag: 9 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_TOKEN = { $tag: 10 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_TYPE = { $tag: 11 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_POSITION = { $tag: 12 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LEFT = { $tag: 13 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_RIGHT = { $tag: 14 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_NONASSOC = { $tag: 15 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PREC = { $tag: 16 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_DERIVE = { $tag: 17 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_INLINE = { $tag: 18 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LBRACKET = { $tag: 19 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$RBRACKET = { $tag: 20 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LPAREN = { $tag: 21 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$RPAREN = { $tag: 22 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$COMMA = { $tag: 23 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$ARROW = { $tag: 24 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$QUESTION = { $tag: 25 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$COLON = { $tag: 26 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$BAR = { $tag: 27 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$EQ = { $tag: 28 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$SEMI = { $tag: 29 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Accept = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Reduce(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Reduce.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead.prototype.$tag = 3;
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error = { $tag: 4 };
function Result$Err$42$(param0) {
  this._0 = param0;
}
Result$Err$42$.prototype.$tag = 0;
function Result$Ok$42$(param0) {
  this._0 = param0;
}
Result$Ok$42$.prototype.$tag = 1;
function Result$Err$43$(param0) {
  this._0 = param0;
}
Result$Err$43$.prototype.$tag = 0;
function Result$Ok$43$(param0) {
  this._0 = param0;
}
Result$Ok$43$.prototype.$tag = 1;
function Result$Err$44$(param0) {
  this._0 = param0;
}
Result$Err$44$.prototype.$tag = 0;
function Result$Ok$44$(param0) {
  this._0 = param0;
}
Result$Ok$44$.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$EOF = { $tag: 0 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$LPAREN = { $tag: 1 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$RPAREN = { $tag: 2 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$LBRACKET = { $tag: 3 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$RBRACKET = { $tag: 4 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$COMMA = { $tag: 5 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$ARROW = { $tag: 6 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$QUESTION = { $tag: 7 };
function $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$IDENT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$IDENT.prototype.$tag = 8;
function $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$PKG_AND_IDENT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$PKG_AND_IDENT.prototype.$tag = 9;
function Result$Err$45$(param0) {
  this._0 = param0;
}
Result$Err$45$.prototype.$tag = 0;
function Result$Ok$45$(param0) {
  this._0 = param0;
}
Result$Ok$45$.prototype.$tag = 1;
const Option$None$46$ = { $tag: 0 };
function Option$Some$46$(param0) {
  this._0 = param0;
}
Option$Some$46$.prototype.$tag = 1;
function Result$Err$47$(param0) {
  this._0 = param0;
}
Result$Err$47$.prototype.$tag = 0;
function Result$Ok$47$(param0) {
  this._0 = param0;
}
Result$Ok$47$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$Data(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$Data.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$StartPosOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$StartPosOf.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$EndPosOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$EndPosOf.prototype.$tag = 2;
const $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$StartPos = { $tag: 3 };
const $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$EndPos = { $tag: 4 };
const $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$SymbolStartPos = { $tag: 5 };
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$SubAction(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$SubAction.prototype.$tag = 6;
function Result$Err$48$(param0) {
  this._0 = param0;
}
Result$Err$48$.prototype.$tag = 0;
function Result$Ok$48$(param0) {
  this._0 = param0;
}
Result$Ok$48$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Param(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Param.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Option(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Option.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Tuple(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Tuple.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Arrow(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Arrow.prototype.$tag = 4;
function Result$Err$49$(param0) {
  this._0 = param0;
}
Result$Err$49$.prototype.$tag = 0;
function Result$Ok$49$(param0) {
  this._0 = param0;
}
Result$Ok$49$.prototype.$tag = 1;
function Result$Err$50$(param0) {
  this._0 = param0;
}
Result$Err$50$.prototype.$tag = 0;
function Result$Ok$50$(param0) {
  this._0 = param0;
}
Result$Ok$50$.prototype.$tag = 1;
function Result$Err$51$(param0) {
  this._0 = param0;
}
Result$Err$51$.prototype.$tag = 0;
function Result$Ok$51$(param0) {
  this._0 = param0;
}
Result$Ok$51$.prototype.$tag = 1;
function Result$Err$52$(param0) {
  this._0 = param0;
}
Result$Err$52$.prototype.$tag = 0;
function Result$Ok$52$(param0) {
  this._0 = param0;
}
Result$Ok$52$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$Token(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$Token.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$Param(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$Param.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$RuleCall(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$RuleCall.prototype.$tag = 2;
function Result$Err$53$(param0) {
  this._0 = param0;
}
Result$Err$53$.prototype.$tag = 0;
function Result$Ok$53$(param0) {
  this._0 = param0;
}
Result$Ok$53$.prototype.$tag = 1;
function Result$Err$54$(param0) {
  this._0 = param0;
}
Result$Err$54$.prototype.$tag = 0;
function Result$Ok$54$(param0) {
  this._0 = param0;
}
Result$Ok$54$.prototype.$tag = 1;
function $i32_ctz(a) {
  a >>>= 0;
  if (a === 0) return 32;
  a &= -a;
  return 31 - Math.clz32(a);
}
function $i32_popcnt(a) {
  a = a - ((a >>> 1) & 0x55555555);
  a = (a & 0x33333333) + ((a >>> 2) & 0x33333333);
  a = (a + (a >>> 4)) & 0x0f0f0f0f;
  a = a + (a >>> 8);
  a = a + (a >>> 16);
  return a & 0x3f;
}
function Result$Err$55$(param0) {
  this._0 = param0;
}
Result$Err$55$.prototype.$tag = 0;
function Result$Ok$55$(param0) {
  this._0 = param0;
}
Result$Ok$55$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Accept = { $tag: 2 };
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Conflict(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Conflict.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Reduce_conflict_resolved_by_presentation_order(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Reduce_conflict_resolved_by_presentation_order.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_resolved_without_precedence(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_resolved_without_precedence.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_not_resolved_because_of_non_assoc(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_not_resolved_because_of_non_assoc.prototype.$tag = 2;
const $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input.prototype.$tag = 1;
const Option$None$56$ = { $tag: 0 };
function Option$Some$56$(param0) {
  this._0 = param0;
}
Option$Some$56$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$T(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$T.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$NT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$NT.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$T(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$T.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$NT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$NT.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$EOI = { $tag: 2 };
const $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Accept = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Shift(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Shift.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Reduce(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Reduce.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$ReduceNoLookahead(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$ReduceNoLookahead.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$T(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$T.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$NT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$NT.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$EOI = { $tag: 2 };
const $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Error = { $tag: 0 };
const $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Accept = { $tag: 1 };
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Shift(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Shift.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Reduce(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Reduce.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$ReduceNoLookahead(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$ReduceNoLookahead.prototype.$tag = 4;
const moonbitlang$yacc$lib$driver$util$$ffi_exit = (code) => { process.exit(code); };
const moonbitlang$yacc$lib$driver$util$$println_to_stderr = (msg) => { console.error("%s", msg); };
function Option$Some$57$(param0) {
  this._0 = param0;
}
Option$Some$57$.prototype.$tag = 1;
const $$$64$moonbitlang$47$yacc$47$lib$47$codegen$46$SourceMap$36$as$36$64$moonbitlang$47$yacc$47$lib$47$codegen$46$SourceMapBuilder = { method_0: moonbitlang$yacc$lib$codegen$$SourceMapBuilder$add_mapping$0$ };
const $$$64$moonbitlang$47$core$47$builtin$46$Logger$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger = { method_0: (_x, _x$2) => {
  _x.method_table.method_0(_x.self, _x$2);
}, method_1: (_x, _x$2, _x$3, _x$4) => {
  _x.method_table.method_1(_x.self, _x$2, _x$3, _x$4);
}, method_2: (_x, _x$2) => {
  _x.method_table.method_2(_x.self, _x$2);
}, method_3: (_x, _x$2) => {
  _x.method_table.method_3(_x.self, _x$2);
} };
const $$$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodeGenerator$36$as$36$64$moonbitlang$47$yacc$47$lib$47$codegen$46$CodeGenerator = { method_0: moonbitlang$yacc$lib$codegen$$CodeGenerator$void_type$1$, method_1: moonbitlang$yacc$lib$codegen$$CodeGenerator$void_action_code$1$, method_2: moonbitlang$yacc$lib$codegen$$CodeGenerator$codegen_tokens$1$, method_3: moonbitlang$yacc$lib$codegen$$CodeGenerator$codegen$1$ };
const $$$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodeGenerator$36$as$36$64$moonbitlang$47$yacc$47$lib$47$codegen$46$CodeGenerator = { method_0: moonbitlang$yacc$lib$codegen$$CodeGenerator$void_type$2$, method_1: moonbitlang$yacc$lib$codegen$$CodeGenerator$void_action_code$2$, method_2: moonbitlang$yacc$lib$codegen$$CodeGenerator$codegen_tokens$2$, method_3: moonbitlang$yacc$lib$codegen$$CodeGenerator$codegen$2$ };
const $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger = { method_0: moonbitlang$core$builtin$$Logger$write_string$3$, method_1: moonbitlang$core$builtin$$Logger$write_substring$4$, method_2: moonbitlang$core$builtin$$Logger$write_view$3$, method_3: moonbitlang$core$builtin$$Logger$write_char$3$ };
const $$$64$moonbitlang$47$yacc$47$lib$47$util$47$logger_with_cursor$46$LoggerWithCursor$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger = { method_0: moonbitlang$core$builtin$$Logger$write_string$5$, method_1: moonbitlang$core$builtin$$Logger$write_substring$6$, method_2: moonbitlang$core$builtin$$Logger$write_view$5$, method_3: moonbitlang$core$builtin$$Logger$write_char$5$ };
function Error$$to_string(_e) {
  switch (_e.$tag) {
    case 31: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List__ast_Term_.YYObj__list_List__ast_Term_";
    }
    case 30: {
      return "moonbitlang/yacc/lib/parser.YYObj_String.YYObj_String";
    }
    case 29: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_Term.YYObj__ast_Term";
    }
    case 3: {
      return moonbitlang$core$builtin$$Show$to_string$7$(_e);
    }
    case 28: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_ClauseItem.YYObj__ast_ClauseItem";
    }
    case 13: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_ParserSpec.YYObj__ast_ParserSpec";
    }
    case 36: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_Declaration.YYObj__ast_Declaration";
    }
    case 27: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_PrecSymbol.YYObj__ast_PrecSymbol";
    }
    case 44: {
      return "moonbitlang/yacc/lib/parser/type_expr_parser.YYObj__ast_TypeExpr.YYObj__ast_TypeExpr";
    }
    case 4: {
      return moonbitlang$core$builtin$$Show$to_string$7$(_e);
    }
    case 17: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_TypeExpr_.YYObj__ast_TypeExpr_";
    }
    case 1: {
      return moonbitlang$core$builtin$$Show$to_string$8$(_e);
    }
    case 46: {
      return "moonbitlang/yacc/lib/parser/type_expr_parser.YYObj__list_List__ast_TypeExpr_.YYObj__list_List__ast_TypeExpr_";
    }
    case 14: {
      return "moonbitlang/yacc/lib/parser.YYObj__String__Int__Int_.YYObj__String__Int__Int_";
    }
    case 41: {
      return "moonbitlang/yacc/lib/parser.ParseError.UnexpectedToken";
    }
    case 43: {
      return "moonbitlang/yacc/lib/parser.LexError.UnexpectedEndOfFile";
    }
    case 24: {
      return "moonbitlang/yacc/lib/parser.YYObj__String__Int__Array__ast_SubstItem__.YYObj__String__Int__Array__ast_SubstItem__";
    }
    case 8: {
      return moonbitlang$core$builtin$$Show$to_string$9$(_e);
    }
    case 7: {
      return moonbitlang$core$builtin$$Show$to_string$9$(_e);
    }
    case 5: {
      return moonbitlang$core$builtin$$Show$to_string$10$(_e);
    }
    case 33: {
      return "moonbitlang/yacc/lib/parser.YYObj__String__String_.YYObj__String__String_";
    }
    case 15: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_Rule.YYObj__ast_Rule";
    }
    case 26: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List__ast_ClauseItem_.YYObj__list_List__ast_ClauseItem_";
    }
    case 23: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_ClauseAction.YYObj__ast_ClauseAction";
    }
    case 50: {
      return "moonbitlang/yacc/lib/elab.ElabError.FailedToParseTypeExpr";
    }
    case 2: {
      return moonbitlang$core$builtin$$Show$to_string$11$(_e);
    }
    case 45: {
      return "moonbitlang/yacc/lib/parser/type_expr_parser.YYObj__String__String_.YYObj__String__String_";
    }
    case 40: {
      return "moonbitlang/yacc/lib/parser.YYObj_Void.YYObj_Void";
    }
    case 9: {
      return "Yoorkin/ArgParser.ErrorMsg.ErrorMsg";
    }
    case 39: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List__ast_PrecSymbol_.YYObj__list_List__ast_PrecSymbol_";
    }
    case 22: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_ClauseWithoutAction.YYObj__ast_ClauseWithoutAction";
    }
    case 20: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List__String___ast_TypeExpr___.YYObj__list_List__String___ast_TypeExpr___";
    }
    case 11: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List__ast_Rule_.YYObj__list_List__ast_Rule_";
    }
    case 49: {
      return "moonbitlang/yacc/lib/elab.ElabError.OutOfBoundsAccess";
    }
    case 32: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_TypeExpr.YYObj__ast_TypeExpr";
    }
    case 18: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__.YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__";
    }
    case 51: {
      return "moonbitlang/yacc/lib/elab.ElabError.UnresolvedSymbol";
    }
    case 48: {
      return "moonbitlang/yacc/lib/parser/type_expr_parser.YYObj_Void.YYObj_Void";
    }
    case 47: {
      return "moonbitlang/yacc/lib/parser/type_expr_parser.YYObj_String.YYObj_String";
    }
    case 0: {
      return moonbitlang$core$builtin$$Show$to_string$8$(_e);
    }
    case 38: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_SymbolWithLoc.YYObj__ast_SymbolWithLoc";
    }
    case 6: {
      return moonbitlang$core$builtin$$Show$to_string$12$(_e);
    }
    case 37: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List__ast_SymbolWithLoc_.YYObj__list_List__ast_SymbolWithLoc_";
    }
    case 25: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_PrecSymbol_.YYObj__ast_PrecSymbol_";
    }
    case 34: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List__ast_TypeExpr_.YYObj__list_List__ast_TypeExpr_";
    }
    case 42: {
      return "moonbitlang/yacc/lib/parser.LexError.Unrecognized";
    }
    case 19: {
      return "moonbitlang/yacc/lib/parser.YYObj_Array_String_.YYObj_Array_String_";
    }
    case 12: {
      return "moonbitlang/yacc/lib/parser.YYObj___ast_Code__Int__Int__.YYObj___ast_Code__Int__Int__";
    }
    case 10: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List__ast_Declaration_.YYObj__list_List__ast_Declaration_";
    }
    case 35: {
      return "moonbitlang/yacc/lib/parser.YYObj__list_List_String_.YYObj__list_List_String_";
    }
    case 21: {
      return "moonbitlang/yacc/lib/parser.YYObj_Option_Unit_.YYObj_Option_Unit_";
    }
    default: {
      return "moonbitlang/yacc/lib/parser.YYObj__ast_Symbol.YYObj__ast_Symbol";
    }
  }
}
const moonbitlang$core$builtin$$wasm_helper_cache = { tried: false, exports: undefined };
const moonbitlang$core$builtin$$boyer_moore_horspool_find$46$constr$47$745 = 0;
const moonbitlang$core$builtin$$brute_force_find$46$constr$47$759 = 0;
const moonbitlang$core$strconv$$base_err_str = "invalid base";
const moonbitlang$core$strconv$$range_err_str = "value out of range";
const moonbitlang$core$strconv$$syntax_err_str = "invalid syntax";
const moonbitlang$core$strconv$$parse_int64$46$inner$46$42$bind$124$600 = "";
const moonbitlang$core$int$$max_value = 2147483647;
const moonbitlang$yacc$lib$parser$$code_rbrace$46$42$bind$124$2449 = "$";
(() => {
})();
const moonbitlang$yacc$lib$parser$$yy_action_14$46$constr$47$6057 = 1;
const moonbitlang$yacc$lib$parser$$yy_action_16$46$constr$47$6069 = 1;
const moonbitlang$yacc$lib$parser$$yy_action_17$46$constr$47$6083 = 1;
const moonbitlang$yacc$lib$parser$$yy_action_19$46$constr$47$6095 = 1;
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6695 = { _0: 0, _1: 0 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6696 = { _0: 1, _1: 1 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6697 = { _0: 2, _1: 2 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6698 = { _0: 3, _1: 3 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6699 = { _0: 4, _1: 4 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6700 = { _0: 5, _1: 5 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6701 = { _0: 6, _1: 6 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6702 = { _0: 7, _1: 7 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6703 = { _0: 8, _1: 8 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6704 = { _0: 9, _1: 9 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6705 = { _0: 10, _1: 10 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6706 = { _0: 11, _1: 11 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6707 = { _0: 12, _1: 12 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6708 = { _0: 13, _1: 13 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6709 = { _0: 14, _1: 14 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6710 = { _0: 15, _1: 15 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6711 = { _0: 16, _1: 16 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6712 = { _0: 17, _1: 17 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6713 = { _0: 18, _1: 18 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6714 = { _0: 19, _1: 19 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6715 = { _0: 20, _1: 20 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6716 = { _0: 21, _1: 21 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6717 = { _0: 22, _1: 22 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6718 = { _0: 23, _1: 23 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6719 = { _0: 24, _1: 24 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6720 = { _0: 25, _1: 25 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6721 = { _0: 26, _1: 26 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6722 = { _0: 27, _1: 27 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6723 = { _0: 28, _1: 28 };
const moonbitlang$yacc$lib$parser$$error$46$tuple$47$6724 = { _0: 29, _1: 29 };
(() => {
})();
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7287 = { _0: 0, _1: 0 };
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7288 = { _0: 1, _1: 1 };
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7289 = { _0: 2, _1: 2 };
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7290 = { _0: 3, _1: 3 };
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7291 = { _0: 4, _1: 4 };
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7292 = { _0: 5, _1: 5 };
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7293 = { _0: 6, _1: 6 };
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7294 = { _0: 7, _1: 7 };
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7295 = { _0: 8, _1: 8 };
const moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7296 = { _0: 9, _1: 9 };
const moonbitlang$yacc$lib$util$stamp$$next_stamp = { val: 0 };
const moonbitlang$yacc$lib$elab$$stdlib_src = "%%\n\noption[T](X : T) -> Option[T]\n  : { None }\n  | X { Some($1) }\n  ;\n\n%inline ioption[T](X : T) -> Option[T]\n  : { None }\n  | X { Some($1) }\n  ;\n\nloption[T](X : @list.List[T]) -> @list.List[T]\n  : { @list.empty() }\n  | X { $1 }\n  ;\n\nboption[T](X : T) -> Bool\n  : { false }\n  | X { true }\n  ;\n\n%inline pair[X, Y](X : X, Y : Y) -> (X, Y)\n  : X Y { ($1, $2) }\n  ;\n\n%inline separated_pair[X, Y](X : X, SEP, Y : Y) -> (X, Y)\n  : X SEP Y { ($1, $3) }\n  ;\n\n%inline preceded[T](L, X : T) -> T\n  : L X { $2 }\n  ;\n\n%inline terminated[T](X : T, R) -> T\n  : X R { $1 }\n  ;\n\n%inline delimited[T](L, X : T, R) -> T\n  : L X R { $2 }\n  ;\n\nlist[T](X : T) -> @list.List[T]\n  : { @list.empty() }\n  | X list(X) { $2.add($1) }\n  ;\n\nnonempty_list[T](X : T) -> @list.List[T]\n  : X { @list.singleton($1) }\n  | X nonempty_list(X) { $2.add($1) }\n  ;\n\nseparated_list[T](SEP, X : T) -> @list.List[T]\n  : { @list.empty() }\n  | separated_nonempty_list(SEP, X) { $1 }\n  ;\n\nseparated_nonempty_list[T](SEP, X : T) -> @list.List[T]\n  : X { @list.singleton($1) }\n  | X SEP separated_nonempty_list(SEP, X) { $3.add($1) }\n  ;\n";
const moonbitlang$yacc$lib$elab$$elaborate$46$42$bind$124$791 = ",";
const moonbitlang$yacc$lib$elab$$elaborate$46$42$bind$124$792 = " ";
const moonbitlang$yacc$lib$elab$$elaborate_action$46$tuple$47$7967 = { _0: 0, _1: 0 };
const moonbitlang$yacc$lib$elab$$elaborate_action$46$tuple$47$7968 = { _0: 0, _1: 0 };
const moonbitlang$yacc$lib$util$small_int_set$$_empty = [0];
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$478 = " ";
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$479 = "_";
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$480 = "(";
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$481 = "_";
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$482 = ")";
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$483 = "_";
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$484 = ",";
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$485 = "_";
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident$46$42$bind$124$493 = "/";
const moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident$46$42$bind$124$494 = "_";
const moonbitlang$yacc$lib$codegen$gen_mbt$$fix_result_type$46$42$bind$124$562 = "->";
const moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$type_$124$36 = "ParseError";
const moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$42$bind$124$749 = "\n";
const moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$42$bind$124$863 = " | ";
const moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident$46$42$bind$124$441 = "/";
const moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident$46$42$bind$124$442 = "_";
const moonbitlang$yacc$lib$codegen$gen_mbt_table$$fix_result_type$46$42$bind$124$510 = "->";
const moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$type_$124$37 = "ParseError";
const moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$42$bind$124$694 = "\n";
const moonbitlang$yacc$lib$codegen$gen_mbt_table$$compress_generator$46$record$47$9506 = { compress: true };
const moonbitlang$yacc$lib$codegen$gen_mbt_table$$generator$46$record$47$9507 = { compress: false };
const moonbitlang$yacc$lib$codegen$gen_mbt_table$$generator = { self: moonbitlang$yacc$lib$codegen$gen_mbt_table$$generator$46$record$47$9507, method_table: $$$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodeGenerator$36$as$36$64$moonbitlang$47$yacc$47$lib$47$codegen$46$CodeGenerator };
const moonbitlang$yacc$lib$driver$util$$path_basename$46$42$bind$124$17 = "/";
const moonbitlang$yacc$lib$driver$util$$path_basename$46$42$bind$124$11 = "\\";
const moonbitlang$yacc$lib$driver$$array_to_or_list$46$42$bind$124$150 = ", ";
const moonbitlang$yacc$main$$_init$42$46$usage$124$1 = "Usage: moonyacc [options] <input-file>";
const moonbitlang$core$builtin$$seed = moonbitlang$core$builtin$$random_seed();
const moonbitlang$yacc$lib$codegen$gen_mbt$$generator = { self: undefined, method_table: $$$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodeGenerator$36$as$36$64$moonbitlang$47$yacc$47$lib$47$codegen$46$CodeGenerator };
const moonbitlang$yacc$lib$util$stamp$$initial_stamp = moonbitlang$yacc$lib$util$stamp$$new();
const moonbitlang$yacc$lib$lr1$$_empty = { concrete_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$empty(), vars: moonbitlang$yacc$lib$util$small_int_set$$_empty };
const moonbitlang$yacc$lib$codegen$gen_mbt_table$$compress_generator = { self: moonbitlang$yacc$lib$codegen$gen_mbt_table$$compress_generator$46$record$47$9506, method_table: $$$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodeGenerator$36$as$36$64$moonbitlang$47$yacc$47$lib$47$codegen$46$CodeGenerator };
function moonbitlang$core$abort$$abort$13$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$14$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$15$(msg) {
  $panic();
}
function moonbitlang$core$abort$$abort$16$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$17$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$18$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$19$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$20$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$21$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$22$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$23$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$24$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$25$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$26$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$27$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$28$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$29$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$30$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$31$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$32$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$33$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$34$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$35$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$36$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$37$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$38$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$39$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$40$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$41$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$42$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$43$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$44$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$45$(msg) {
  return $panic();
}
function moonbitlang$core$abort$$abort$46$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$Logger$write_object$13$(self, obj) {
  moonbitlang$core$builtin$$Show$output$13$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$47$(self, obj) {
  moonbitlang$core$builtin$$Show$output$48$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$49$(self, obj) {
  moonbitlang$core$builtin$$Show$output$50$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$51$(self, obj) {
  moonbitlang$core$builtin$$Show$output$51$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$17$(self, obj) {
  moonbitlang$core$builtin$$Show$output$17$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$52$(self, obj) {
  moonbitlang$core$builtin$$Show$output$52$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$53$(self, obj) {
  self.method_table.method_0(self.self, obj.name);
}
function moonbitlang$core$builtin$$Logger$write_object$54$(self, obj) {
  moonbitlang$core$builtin$$Show$output$54$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$55$(self, obj) {
  self.method_table.method_0(self.self, obj.name);
}
function moonbitlang$core$builtin$$Logger$write_object$56$(self, obj) {
  moonbitlang$core$builtin$$Show$output$56$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$57$(self, obj) {
  moonbitlang$core$builtin$$Show$output$58$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$59$(self, obj) {
  moonbitlang$core$builtin$$Show$output$59$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$60$(self, obj) {
  moonbitlang$core$builtin$$Show$output$60$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$61$(self, obj) {
  moonbitlang$core$builtin$$Show$output$61$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$62$(self, obj) {
  moonbitlang$core$builtin$$Show$output$62$(obj, self);
}
function moonbitlang$core$builtin$$Show$output$63$(_x_5001, _x_5002) {
  if (_x_5001.$tag === 4) {
    _x_5002.method_table.method_0(_x_5002.self, "IndexOutOfBounds");
    return;
  } else {
    _x_5002.method_table.method_0(_x_5002.self, "InvalidIndex");
    return;
  }
}
function moonbitlang$core$builtin$$Hasher$consume4(self, input) {
  const _p = (self.acc >>> 0) + ((Math.imul(input, -1028477379) | 0) >>> 0) | 0;
  const _p$2 = 17;
  self.acc = Math.imul(_p << _p$2 | (_p >>> (32 - _p$2 | 0) | 0), 668265263) | 0;
}
function moonbitlang$core$builtin$$Hasher$combine_uint(self, value) {
  self.acc = (self.acc >>> 0) + (4 >>> 0) | 0;
  moonbitlang$core$builtin$$Hasher$consume4(self, value);
}
function moonbitlang$core$builtin$$abort$13$(string, loc) {
  return moonbitlang$core$abort$$abort$13$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$14$(string, loc) {
  return moonbitlang$core$abort$$abort$14$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$15$(string, loc) {
  moonbitlang$core$abort$$abort$15$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$16$(string, loc) {
  return moonbitlang$core$abort$$abort$16$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$17$(string, loc) {
  return moonbitlang$core$abort$$abort$17$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$18$(string, loc) {
  return moonbitlang$core$abort$$abort$18$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$19$(string, loc) {
  return moonbitlang$core$abort$$abort$19$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$20$(string, loc) {
  return moonbitlang$core$abort$$abort$20$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$21$(string, loc) {
  return moonbitlang$core$abort$$abort$21$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$22$(string, loc) {
  return moonbitlang$core$abort$$abort$22$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$23$(string, loc) {
  return moonbitlang$core$abort$$abort$23$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$24$(string, loc) {
  return moonbitlang$core$abort$$abort$24$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$25$(string, loc) {
  return moonbitlang$core$abort$$abort$25$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$26$(string, loc) {
  return moonbitlang$core$abort$$abort$26$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$27$(string, loc) {
  return moonbitlang$core$abort$$abort$27$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$28$(string, loc) {
  return moonbitlang$core$abort$$abort$28$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$29$(string, loc) {
  return moonbitlang$core$abort$$abort$29$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$30$(string, loc) {
  return moonbitlang$core$abort$$abort$30$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$31$(string, loc) {
  return moonbitlang$core$abort$$abort$31$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$32$(string, loc) {
  return moonbitlang$core$abort$$abort$32$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$33$(string, loc) {
  return moonbitlang$core$abort$$abort$33$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$34$(string, loc) {
  return moonbitlang$core$abort$$abort$34$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$35$(string, loc) {
  return moonbitlang$core$abort$$abort$35$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$36$(string, loc) {
  return moonbitlang$core$abort$$abort$36$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$37$(string, loc) {
  return moonbitlang$core$abort$$abort$37$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$38$(string, loc) {
  return moonbitlang$core$abort$$abort$38$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$39$(string, loc) {
  return moonbitlang$core$abort$$abort$39$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$40$(string, loc) {
  return moonbitlang$core$abort$$abort$40$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$41$(string, loc) {
  return moonbitlang$core$abort$$abort$41$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$42$(string, loc) {
  return moonbitlang$core$abort$$abort$42$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$43$(string, loc) {
  return moonbitlang$core$abort$$abort$43$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$44$(string, loc) {
  return moonbitlang$core$abort$$abort$44$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$45$(string, loc) {
  return moonbitlang$core$abort$$abort$45$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$builtin$$abort$46$(string, loc) {
  return moonbitlang$core$abort$$abort$46$(`${string}\n  at ${moonbitlang$core$builtin$$Show$to_string$64$(loc)}\n`);
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$65$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$17$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$26$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$32$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$31$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$28$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$33$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        const _tmp$2 = dst_offset + i | 0;
        const _tmp$3 = src_offset + i | 0;
        $bound_check(src, _tmp$3);
        $bound_check(dst, _tmp$2);
        dst[_tmp$2] = src[_tmp$3];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$builtin$$StringBuilder$new$46$inner(size_hint) {
  return { val: "" };
}
function moonbitlang$core$builtin$$Logger$write_char$3$(self, ch) {
  const _bind = self;
  _bind.val = `${_bind.val}${String.fromCodePoint(ch)}`;
}
function moonbitlang$core$builtin$$code_point_of_surrogate_pair(leading, trailing) {
  return (((Math.imul(leading - 55296 | 0, 1024) | 0) + trailing | 0) - 56320 | 0) + 65536 | 0;
}
function moonbitlang$core$string$$String$unsafe_char_at(self, index) {
  const c1 = self.charCodeAt(index);
  if (55296 <= c1 && c1 <= 56319) {
    const _tmp = index + 1 | 0;
    const c2 = self.charCodeAt(_tmp);
    return moonbitlang$core$builtin$$code_point_of_surrogate_pair(c1, c2);
  } else {
    return c1;
  }
}
function moonbitlang$core$string$$String$escape(self) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$13$(self, { self: buf, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return buf.val;
}
function moonbitlang$core$array$$Array$at$66$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$32$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$67$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$68$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$69$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$34$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$70$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$71$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$72$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$55$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$73$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$17$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$74$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$75$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$76$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$array$$Array$at$77$(self, index) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    return self[index];
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$SourceLocRepr$parse(repr) {
  const _bind = { str: repr, start: 0, end: repr.length };
  const _data = _bind.str;
  const _start = _bind.start;
  const _end = _start + (_bind.end - _bind.start | 0) | 0;
  let _cursor = _start;
  let accept_state = -1;
  let match_end = -1;
  let match_tag_saver_0 = -1;
  let match_tag_saver_1 = -1;
  let match_tag_saver_2 = -1;
  let match_tag_saver_3 = -1;
  let match_tag_saver_4 = -1;
  let tag_0 = -1;
  let tag_1 = -1;
  let tag_1_1 = -1;
  let tag_1_2 = -1;
  let tag_3 = -1;
  let tag_2 = -1;
  let tag_2_1 = -1;
  let tag_4 = -1;
  _L: {
    let join_dispatch_19;
    _L$2: {
      if (_cursor < _end) {
        const _p = _cursor;
        const next_char = _data.charCodeAt(_p);
        _cursor = _cursor + 1 | 0;
        if (next_char < 65) {
          if (next_char < 64) {
            break _L;
          } else {
            while (true) {
              tag_0 = _cursor;
              if (_cursor < _end) {
                _L$3: {
                  const _p$2 = _cursor;
                  const next_char$2 = _data.charCodeAt(_p$2);
                  _cursor = _cursor + 1 | 0;
                  if (next_char$2 < 55296) {
                    if (next_char$2 < 58) {
                      break _L$3;
                    } else {
                      if (next_char$2 > 58) {
                        break _L$3;
                      } else {
                        if (_cursor < _end) {
                          _L$4: {
                            const _p$3 = _cursor;
                            const next_char$3 = _data.charCodeAt(_p$3);
                            _cursor = _cursor + 1 | 0;
                            if (next_char$3 < 56319) {
                              if (next_char$3 < 55296) {
                                break _L$4;
                              } else {
                                join_dispatch_19 = 7;
                                break _L$2;
                              }
                            } else {
                              if (next_char$3 > 56319) {
                                if (next_char$3 < 65536) {
                                  break _L$4;
                                } else {
                                  break _L;
                                }
                              } else {
                                join_dispatch_19 = 8;
                                break _L$2;
                              }
                            }
                          }
                          join_dispatch_19 = 0;
                          break _L$2;
                        } else {
                          break _L;
                        }
                      }
                    }
                  } else {
                    if (next_char$2 > 56318) {
                      if (next_char$2 < 57344) {
                        if (_cursor < _end) {
                          const _p$3 = _cursor;
                          const next_char$3 = _data.charCodeAt(_p$3);
                          _cursor = _cursor + 1 | 0;
                          if (next_char$3 < 56320) {
                            break _L;
                          } else {
                            if (next_char$3 > 57343) {
                              break _L;
                            } else {
                              continue;
                            }
                          }
                        } else {
                          break _L;
                        }
                      } else {
                        if (next_char$2 > 65535) {
                          break _L;
                        } else {
                          break _L$3;
                        }
                      }
                    } else {
                      if (_cursor < _end) {
                        const _p$3 = _cursor;
                        const next_char$3 = _data.charCodeAt(_p$3);
                        _cursor = _cursor + 1 | 0;
                        if (next_char$3 < 56320) {
                          break _L;
                        } else {
                          if (next_char$3 > 65535) {
                            break _L;
                          } else {
                            continue;
                          }
                        }
                      } else {
                        break _L;
                      }
                    }
                  }
                }
                continue;
              } else {
                break _L;
              }
            }
          }
        } else {
          break _L;
        }
      } else {
        break _L;
      }
    }
    let _tmp = join_dispatch_19;
    _L$3: while (true) {
      const dispatch_19 = _tmp;
      _L$4: {
        _L$5: {
          switch (dispatch_19) {
            case 3: {
              tag_1_2 = tag_1_1;
              tag_1_1 = tag_1;
              tag_1 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p = _cursor;
                  const next_char = _data.charCodeAt(_p);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        tag_1 = _cursor;
                        tag_2_1 = tag_2;
                        tag_2 = _cursor;
                        tag_3 = _cursor;
                        if (_cursor < _end) {
                          _L$7: {
                            const _p$2 = _cursor;
                            const next_char$2 = _data.charCodeAt(_p$2);
                            _cursor = _cursor + 1 | 0;
                            if (next_char$2 < 59) {
                              if (next_char$2 < 46) {
                                if (next_char$2 < 45) {
                                  break _L$7;
                                } else {
                                  break _L$4;
                                }
                              } else {
                                if (next_char$2 > 47) {
                                  if (next_char$2 < 58) {
                                    _tmp = 6;
                                    continue _L$3;
                                  } else {
                                    _tmp = 3;
                                    continue _L$3;
                                  }
                                } else {
                                  break _L$7;
                                }
                              }
                            } else {
                              if (next_char$2 > 55295) {
                                if (next_char$2 < 57344) {
                                  if (next_char$2 < 56319) {
                                    _tmp = 7;
                                    continue _L$3;
                                  } else {
                                    _tmp = 8;
                                    continue _L$3;
                                  }
                                } else {
                                  if (next_char$2 > 65535) {
                                    break _L;
                                  } else {
                                    break _L$7;
                                  }
                                }
                              } else {
                                break _L$7;
                              }
                            }
                          }
                          _tmp = 0;
                          continue _L$3;
                        } else {
                          break _L;
                        }
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp = 1;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 2: {
              tag_1 = _cursor;
              tag_2 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p = _cursor;
                  const next_char = _data.charCodeAt(_p);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        _tmp = 2;
                        continue _L$3;
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp = 3;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 0: {
              tag_1 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p = _cursor;
                  const next_char = _data.charCodeAt(_p);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      break _L$6;
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp = 1;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 8: {
              if (_cursor < _end) {
                const _p = _cursor;
                const next_char = _data.charCodeAt(_p);
                _cursor = _cursor + 1 | 0;
                if (next_char < 56320) {
                  break _L;
                } else {
                  if (next_char > 57343) {
                    break _L;
                  } else {
                    _tmp = 0;
                    continue _L$3;
                  }
                }
              } else {
                break _L;
              }
            }
            case 4: {
              tag_1 = _cursor;
              tag_4 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p = _cursor;
                  const next_char = _data.charCodeAt(_p);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        _tmp = 4;
                        continue _L$3;
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        tag_1_2 = tag_1_1;
                        tag_1_1 = tag_1;
                        tag_1 = _cursor;
                        if (_cursor < _end) {
                          _L$7: {
                            const _p$2 = _cursor;
                            const next_char$2 = _data.charCodeAt(_p$2);
                            _cursor = _cursor + 1 | 0;
                            if (next_char$2 < 55296) {
                              if (next_char$2 < 58) {
                                if (next_char$2 < 48) {
                                  break _L$7;
                                } else {
                                  tag_1 = _cursor;
                                  tag_2_1 = tag_2;
                                  tag_2 = _cursor;
                                  if (_cursor < _end) {
                                    _L$8: {
                                      const _p$3 = _cursor;
                                      const next_char$3 = _data.charCodeAt(_p$3);
                                      _cursor = _cursor + 1 | 0;
                                      if (next_char$3 < 55296) {
                                        if (next_char$3 < 58) {
                                          if (next_char$3 < 48) {
                                            break _L$8;
                                          } else {
                                            _tmp = 5;
                                            continue _L$3;
                                          }
                                        } else {
                                          if (next_char$3 > 58) {
                                            break _L$8;
                                          } else {
                                            _tmp = 3;
                                            continue _L$3;
                                          }
                                        }
                                      } else {
                                        if (next_char$3 > 56318) {
                                          if (next_char$3 < 57344) {
                                            _tmp = 8;
                                            continue _L$3;
                                          } else {
                                            if (next_char$3 > 65535) {
                                              break _L;
                                            } else {
                                              break _L$8;
                                            }
                                          }
                                        } else {
                                          _tmp = 7;
                                          continue _L$3;
                                        }
                                      }
                                    }
                                    _tmp = 0;
                                    continue _L$3;
                                  } else {
                                    break _L$5;
                                  }
                                }
                              } else {
                                if (next_char$2 > 58) {
                                  break _L$7;
                                } else {
                                  _tmp = 1;
                                  continue _L$3;
                                }
                              }
                            } else {
                              if (next_char$2 > 56318) {
                                if (next_char$2 < 57344) {
                                  _tmp = 8;
                                  continue _L$3;
                                } else {
                                  if (next_char$2 > 65535) {
                                    break _L;
                                  } else {
                                    break _L$7;
                                  }
                                }
                              } else {
                                _tmp = 7;
                                continue _L$3;
                              }
                            }
                          }
                          _tmp = 0;
                          continue _L$3;
                        } else {
                          break _L;
                        }
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 5: {
              tag_1 = _cursor;
              tag_2 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p = _cursor;
                  const next_char = _data.charCodeAt(_p);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        _tmp = 5;
                        continue _L$3;
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp = 3;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp = 0;
                continue _L$3;
              } else {
                break _L$5;
              }
            }
            case 6: {
              tag_1 = _cursor;
              tag_2 = _cursor;
              tag_3 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p = _cursor;
                  const next_char = _data.charCodeAt(_p);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 59) {
                    if (next_char < 46) {
                      if (next_char < 45) {
                        break _L$6;
                      } else {
                        break _L$4;
                      }
                    } else {
                      if (next_char > 47) {
                        if (next_char < 58) {
                          _tmp = 6;
                          continue _L$3;
                        } else {
                          _tmp = 3;
                          continue _L$3;
                        }
                      } else {
                        break _L$6;
                      }
                    }
                  } else {
                    if (next_char > 55295) {
                      if (next_char < 57344) {
                        if (next_char < 56319) {
                          _tmp = 7;
                          continue _L$3;
                        } else {
                          _tmp = 8;
                          continue _L$3;
                        }
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      break _L$6;
                    }
                  }
                }
                _tmp = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            case 7: {
              if (_cursor < _end) {
                const _p = _cursor;
                const next_char = _data.charCodeAt(_p);
                _cursor = _cursor + 1 | 0;
                if (next_char < 56320) {
                  break _L;
                } else {
                  if (next_char > 65535) {
                    break _L;
                  } else {
                    _tmp = 0;
                    continue _L$3;
                  }
                }
              } else {
                break _L;
              }
            }
            case 1: {
              tag_1_1 = tag_1;
              tag_1 = _cursor;
              if (_cursor < _end) {
                _L$6: {
                  const _p = _cursor;
                  const next_char = _data.charCodeAt(_p);
                  _cursor = _cursor + 1 | 0;
                  if (next_char < 55296) {
                    if (next_char < 58) {
                      if (next_char < 48) {
                        break _L$6;
                      } else {
                        _tmp = 2;
                        continue _L$3;
                      }
                    } else {
                      if (next_char > 58) {
                        break _L$6;
                      } else {
                        _tmp = 1;
                        continue _L$3;
                      }
                    }
                  } else {
                    if (next_char > 56318) {
                      if (next_char < 57344) {
                        _tmp = 8;
                        continue _L$3;
                      } else {
                        if (next_char > 65535) {
                          break _L;
                        } else {
                          break _L$6;
                        }
                      }
                    } else {
                      _tmp = 7;
                      continue _L$3;
                    }
                  }
                }
                _tmp = 0;
                continue _L$3;
              } else {
                break _L;
              }
            }
            default: {
              break _L;
            }
          }
        }
        tag_1 = tag_1_2;
        tag_2 = tag_2_1;
        match_tag_saver_0 = tag_0;
        match_tag_saver_1 = tag_1;
        match_tag_saver_2 = tag_2;
        match_tag_saver_3 = tag_3;
        match_tag_saver_4 = tag_4;
        accept_state = 0;
        match_end = _cursor;
        break _L;
      }
      tag_1_1 = tag_1_2;
      tag_1 = _cursor;
      tag_2 = tag_2_1;
      if (_cursor < _end) {
        _L$5: {
          const _p = _cursor;
          const next_char = _data.charCodeAt(_p);
          _cursor = _cursor + 1 | 0;
          if (next_char < 55296) {
            if (next_char < 58) {
              if (next_char < 48) {
                break _L$5;
              } else {
                _tmp = 4;
                continue;
              }
            } else {
              if (next_char > 58) {
                break _L$5;
              } else {
                _tmp = 1;
                continue;
              }
            }
          } else {
            if (next_char > 56318) {
              if (next_char < 57344) {
                _tmp = 8;
                continue;
              } else {
                if (next_char > 65535) {
                  break _L;
                } else {
                  break _L$5;
                }
              }
            } else {
              _tmp = 7;
              continue;
            }
          }
        }
        _tmp = 0;
        continue;
      } else {
        break _L;
      }
    }
  }
  if (accept_state === 0) {
    let start_line;
    let _try_err;
    _L$2: {
      _L$3: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_1 + 1 | 0, match_tag_saver_2);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          start_line = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp = _err._0;
          _try_err = _tmp;
          break _L$3;
        }
        break _L$2;
      }
      start_line = $panic();
    }
    let start_column;
    let _try_err$2;
    _L$3: {
      _L$4: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_2 + 1 | 0, match_tag_saver_3);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          start_column = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp = _err._0;
          _try_err$2 = _tmp;
          break _L$4;
        }
        break _L$3;
      }
      start_column = $panic();
    }
    let pkg;
    let _try_err$3;
    _L$4: {
      _L$5: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, _start + 1 | 0, match_tag_saver_0);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          pkg = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp = _err._0;
          _try_err$3 = _tmp;
          break _L$5;
        }
        break _L$4;
      }
      pkg = $panic();
    }
    let filename;
    let _try_err$4;
    _L$5: {
      _L$6: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_0 + 1 | 0, match_tag_saver_1);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          filename = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp = _err._0;
          _try_err$4 = _tmp;
          break _L$6;
        }
        break _L$5;
      }
      filename = $panic();
    }
    let end_line;
    let _try_err$5;
    _L$6: {
      _L$7: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_3 + 1 | 0, match_tag_saver_4);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          end_line = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp = _err._0;
          _try_err$5 = _tmp;
          break _L$7;
        }
        break _L$6;
      }
      end_line = $panic();
    }
    let end_column;
    let _try_err$6;
    _L$7: {
      _L$8: {
        const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_4 + 1 | 0, match_end);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          end_column = _ok._0;
        } else {
          const _err = _bind$2;
          const _tmp = _err._0;
          _try_err$6 = _tmp;
          break _L$8;
        }
        break _L$7;
      }
      end_column = $panic();
    }
    return { pkg: pkg, filename: filename, start_line: start_line, start_column: start_column, end_line: end_line, end_column: end_column };
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$StringBuilder$write_object$78$(self, obj) {
  moonbitlang$core$builtin$$Show$output$78$(obj, { self: self, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
}
function moonbitlang$core$builtin$$Logger$write_string$3$(self, str) {
  const _bind = self;
  _bind.val = `${_bind.val}${str}`;
}
function moonbitlang$core$builtin$$Hasher$combine_int(self, value) {
  moonbitlang$core$builtin$$Hasher$combine_uint(self, value);
}
function moonbitlang$core$builtin$$MyInt64$from_int(value) {
  return { hi: value >> 31 & -1, lo: value | 0 };
}
function moonbitlang$core$int$$Int$to_int64(self) {
  return moonbitlang$core$builtin$$MyInt64$from_int(self);
}
function moonbitlang$core$builtin$$Hasher$combine$13$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$13$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$17$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$17$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$79$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$79$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$54$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$54$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$80$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$80$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$81$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$81$(value, self);
}
function moonbitlang$core$builtin$$Eq$not_equal$82$(x, y) {
  return !(x === y);
}
function moonbitlang$core$builtin$$Eq$not_equal$83$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$84$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$85$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$86$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$87$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$88$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$89$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$90$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$91$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$92$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$93$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$94$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$95$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$96$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$97$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$98$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$99$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$100$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$101$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$14$(x, y);
}
function moonbitlang$core$builtin$$Eq$not_equal$102$(x, y) {
  return !moonbitlang$core$builtin$$Eq$equal$103$(x, y);
}
function moonbitlang$core$builtin$$Compare$op_lt$104$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$54$(x, y) < 0;
}
function moonbitlang$core$builtin$$Compare$op_lt$105$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$52$(x, y) < 0;
}
function moonbitlang$core$builtin$$Compare$op_lt$106$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$107$(x, y) < 0;
}
function moonbitlang$core$builtin$$Compare$op_lt$108$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$13$(x, y) < 0;
}
function moonbitlang$core$builtin$$Compare$op_lt$109$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$73$(x, y) < 0;
}
function moonbitlang$core$builtin$$Compare$op_lt$110$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$74$(x, y) < 0;
}
function moonbitlang$core$builtin$$Compare$op_gt$106$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$107$(x, y) > 0;
}
function moonbitlang$core$builtin$$Compare$op_le$106$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$107$(x, y) <= 0;
}
function moonbitlang$core$builtin$$Compare$op_ge$106$(x, y) {
  return moonbitlang$core$builtin$$Compare$compare$107$(x, y) >= 0;
}
function moonbitlang$core$builtin$$Hasher$avalanche(self) {
  let acc = self.acc;
  acc = acc ^ (acc >>> 15 | 0);
  acc = Math.imul(acc, -2048144777) | 0;
  acc = acc ^ (acc >>> 13 | 0);
  acc = Math.imul(acc, -1028477379) | 0;
  acc = acc ^ (acc >>> 16 | 0);
  return acc;
}
function moonbitlang$core$builtin$$Hasher$finalize(self) {
  return moonbitlang$core$builtin$$Hasher$avalanche(self);
}
function moonbitlang$core$builtin$$Hasher$new$46$inner(seed) {
  return { acc: (seed >>> 0) + (374761393 >>> 0) | 0 };
}
function moonbitlang$core$builtin$$Hasher$new(seed$46$opt) {
  let seed;
  if (seed$46$opt === undefined) {
    seed = moonbitlang$core$builtin$$seed;
  } else {
    const _Some = seed$46$opt;
    seed = _Some;
  }
  return moonbitlang$core$builtin$$Hasher$new$46$inner(seed);
}
function moonbitlang$core$builtin$$Hash$hash$108$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(undefined);
  moonbitlang$core$builtin$$Hasher$combine$13$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$builtin$$Hash$hash$111$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(undefined);
  moonbitlang$core$builtin$$Hasher$combine$17$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$builtin$$Hash$hash$112$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(undefined);
  moonbitlang$core$builtin$$Hasher$combine$79$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$builtin$$Hash$hash$104$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(undefined);
  moonbitlang$core$builtin$$Hasher$combine$54$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$builtin$$Hash$hash$113$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(undefined);
  moonbitlang$core$builtin$$Hasher$combine$80$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$builtin$$Hash$hash$82$(self) {
  const _self = moonbitlang$core$builtin$$Hasher$new(undefined);
  moonbitlang$core$builtin$$Hasher$combine$81$(_self, self);
  return moonbitlang$core$builtin$$Hasher$finalize(_self);
}
function moonbitlang$core$string$$String$sub$46$inner(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  if (start$2 >= 0 && (start$2 <= end$2 && end$2 <= len)) {
    let _tmp;
    if (start$2 < len) {
      const _p = self.charCodeAt(start$2);
      _tmp = 56320 <= _p && _p <= 57343;
    } else {
      _tmp = false;
    }
    if (_tmp) {
      return new Result$Err$0$(Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$InvalidIndex);
    }
    let _tmp$2;
    if (end$2 < len) {
      const _p = self.charCodeAt(end$2);
      _tmp$2 = 56320 <= _p && _p <= 57343;
    } else {
      _tmp$2 = false;
    }
    if (_tmp$2) {
      return new Result$Err$0$(Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$InvalidIndex);
    }
    return new Result$Ok$0$({ str: self, start: start$2, end: end$2 });
  } else {
    return new Result$Err$0$(Error$moonbitlang$47$core$47$builtin$46$CreatingViewError$46$IndexOutOfBounds);
  }
}
function moonbitlang$core$string$$String$sub(self, start$46$opt, end) {
  let start;
  if (start$46$opt === undefined) {
    start = 0;
  } else {
    const _Some = start$46$opt;
    start = _Some;
  }
  return moonbitlang$core$string$$String$sub$46$inner(self, start, end);
}
function moonbitlang$core$builtin$$Logger$write_substring$4$(self, value, start, len) {
  let _tmp;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$core$string$$String$sub$46$inner(value, start, start + len | 0);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$2 = _err._0;
        _try_err = _tmp$2;
        break _L$2;
      }
      break _L;
    }
    _tmp = $panic();
  }
  moonbitlang$core$builtin$$Logger$write_view$3$(self, _tmp);
}
function moonbitlang$core$builtin$$Logger$write_substring$6$(self, value, start, len) {
  let _tmp;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$core$string$$String$sub$46$inner(value, start, start + len | 0);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$2 = _err._0;
        _try_err = _tmp$2;
        break _L$2;
      }
      break _L;
    }
    _tmp = $panic();
  }
  moonbitlang$core$builtin$$Logger$write_view$5$(self, _tmp);
}
function moonbitlang$core$builtin$$Show$to_string$114$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$115$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$10$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$116$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$64$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$117$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$118$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$119$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$111$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$17$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$120$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$48$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$121$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$51$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$122$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$75$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$123$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$124$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$12$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$125$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$7$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$63$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$8$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$60$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$11$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$61$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Show$to_string$9$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  moonbitlang$core$builtin$$Show$output$126$(self, { self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger });
  return logger.val;
}
function moonbitlang$core$builtin$$Logger$write_iter$46$inner$51$(self, iter, prefix, suffix, sep, trailing) {
  self.method_table.method_0(self.self, prefix);
  if (trailing) {
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$51$(iter);
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        const _x = _Some;
        moonbitlang$core$builtin$$Logger$write_object$51$(self, _x);
        self.method_table.method_0(self.self, sep);
        continue;
      }
    }
  } else {
    let first = true;
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$51$(iter);
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        const _x = _Some;
        if (first) {
          first = false;
        } else {
          self.method_table.method_0(self.self, sep);
        }
        moonbitlang$core$builtin$$Logger$write_object$51$(self, _x);
        continue;
      }
    }
  }
  self.method_table.method_0(self.self, suffix);
}
function moonbitlang$core$builtin$$Logger$write_iter$46$inner$62$(self, iter, prefix, suffix, sep, trailing) {
  self.method_table.method_0(self.self, prefix);
  if (trailing) {
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$62$(iter);
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        const _x = _Some;
        moonbitlang$core$builtin$$Logger$write_object$62$(self, _x);
        self.method_table.method_0(self.self, sep);
        continue;
      }
    }
  } else {
    let first = true;
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$62$(iter);
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        const _x = _Some;
        if (first) {
          first = false;
        } else {
          self.method_table.method_0(self.self, sep);
        }
        moonbitlang$core$builtin$$Logger$write_object$62$(self, _x);
        continue;
      }
    }
  }
  self.method_table.method_0(self.self, suffix);
}
function moonbitlang$core$int$$Int$to_string$46$inner(self, radix) {
  return moonbitlang$core$builtin$$int_to_string_js(self, radix);
}
function moonbitlang$core$string$$StringView$view$46$inner(self, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.end - self.start | 0;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  return start_offset >= 0 && (start_offset <= end_offset$2 && end_offset$2 <= (self.end - self.start | 0)) ? { str: self.str, start: self.start + start_offset | 0, end: self.start + end_offset$2 | 0 } : moonbitlang$core$builtin$$abort$14$("Invalid index for View", "@moonbitlang/core/builtin:stringview.mbt:111:5-111:36");
}
function moonbitlang$core$builtin$$to_hex$46$to_hex_digit$124$3717(i) {
  if (i < 10) {
    const _p = 48;
    const _p$2 = (i + _p | 0) & 255;
    return _p$2;
  } else {
    const _p = 97;
    const _p$2 = (i + _p | 0) & 255;
    const _p$3 = 10;
    const _p$4 = (_p$2 - _p$3 | 0) & 255;
    return _p$4;
  }
}
function moonbitlang$core$byte$$Byte$to_hex(b) {
  const _self = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  const _p = 16;
  moonbitlang$core$builtin$$Logger$write_char$3$(_self, moonbitlang$core$builtin$$to_hex$46$to_hex_digit$124$3717((b / _p | 0) & 255));
  const _p$2 = 16;
  moonbitlang$core$builtin$$Logger$write_char$3$(_self, moonbitlang$core$builtin$$to_hex$46$to_hex_digit$124$3717((b % _p$2 | 0) & 255));
  const _p$3 = _self;
  return _p$3.val;
}
function moonbitlang$core$builtin$$output$46$flush_segment$124$3707(_env, seg, i) {
  const self = _env._1;
  const logger = _env._0;
  if (i > seg) {
    logger.method_table.method_1(logger.self, self, seg, i - seg | 0);
    return;
  } else {
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$13$(self, logger) {
  logger.method_table.method_3(logger.self, 34);
  const _env = { _0: logger, _1: self };
  const len = self.length;
  let _tmp = 0;
  let _tmp$2 = 0;
  _L: while (true) {
    const i = _tmp;
    const seg = _tmp$2;
    if (i >= len) {
      moonbitlang$core$builtin$$output$46$flush_segment$124$3707(_env, seg, i);
      break;
    }
    const code = self.charCodeAt(i);
    let c;
    _L$2: {
      switch (code) {
        case 34: {
          c = code;
          break _L$2;
        }
        case 92: {
          c = code;
          break _L$2;
        }
        case 10: {
          moonbitlang$core$builtin$$output$46$flush_segment$124$3707(_env, seg, i);
          logger.method_table.method_0(logger.self, "\\n");
          _tmp = i + 1 | 0;
          _tmp$2 = i + 1 | 0;
          continue _L;
        }
        case 13: {
          moonbitlang$core$builtin$$output$46$flush_segment$124$3707(_env, seg, i);
          logger.method_table.method_0(logger.self, "\\r");
          _tmp = i + 1 | 0;
          _tmp$2 = i + 1 | 0;
          continue _L;
        }
        case 8: {
          moonbitlang$core$builtin$$output$46$flush_segment$124$3707(_env, seg, i);
          logger.method_table.method_0(logger.self, "\\b");
          _tmp = i + 1 | 0;
          _tmp$2 = i + 1 | 0;
          continue _L;
        }
        case 9: {
          moonbitlang$core$builtin$$output$46$flush_segment$124$3707(_env, seg, i);
          logger.method_table.method_0(logger.self, "\\t");
          _tmp = i + 1 | 0;
          _tmp$2 = i + 1 | 0;
          continue _L;
        }
        default: {
          if (code < 32) {
            moonbitlang$core$builtin$$output$46$flush_segment$124$3707(_env, seg, i);
            logger.method_table.method_0(logger.self, "\\u{");
            logger.method_table.method_0(logger.self, moonbitlang$core$byte$$Byte$to_hex(code & 255));
            logger.method_table.method_3(logger.self, 125);
            _tmp = i + 1 | 0;
            _tmp$2 = i + 1 | 0;
            continue _L;
          } else {
            _tmp = i + 1 | 0;
            continue _L;
          }
        }
      }
    }
    moonbitlang$core$builtin$$output$46$flush_segment$124$3707(_env, seg, i);
    logger.method_table.method_3(logger.self, 92);
    logger.method_table.method_3(logger.self, c);
    _tmp = i + 1 | 0;
    _tmp$2 = i + 1 | 0;
    continue;
  }
  logger.method_table.method_3(logger.self, 34);
}
function moonbitlang$core$builtin$$Show$to_string$14$(self) {
  return self.str.substring(self.start, self.end);
}
function moonbitlang$core$string$$StringView$iter(self) {
  const start = self.start;
  const end = self.end;
  const index = { val: start };
  const _p = () => {
    if (index.val < end) {
      const _tmp = self.str;
      const _tmp$2 = index.val;
      const c1 = _tmp.charCodeAt(_tmp$2);
      if (55296 <= c1 && c1 <= 56319 && (index.val + 1 | 0) < self.end) {
        const _tmp$3 = self.str;
        const _tmp$4 = index.val + 1 | 0;
        const c2 = _tmp$3.charCodeAt(_tmp$4);
        if (56320 <= c2 && c2 <= 57343) {
          index.val = index.val + 2 | 0;
          return moonbitlang$core$builtin$$code_point_of_surrogate_pair(c1, c2);
        }
      }
      index.val = index.val + 1 | 0;
      return c1;
    } else {
      return -1;
    }
  };
  return _p;
}
function moonbitlang$core$builtin$$Iter2$new$127$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$128$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$129$(f) {
  return f;
}
function moonbitlang$core$builtin$$Eq$equal$14$(self, other) {
  const len = self.end - self.start | 0;
  if (len === (other.end - other.start | 0)) {
    if (self.str === other.str && self.start === other.start) {
      return true;
    }
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const _tmp$2 = self.str;
        const _tmp$3 = self.start + i | 0;
        const _tmp$4 = _tmp$2.charCodeAt(_tmp$3);
        const _tmp$5 = other.str;
        const _tmp$6 = other.start + i | 0;
        if (_tmp$4 === _tmp$5.charCodeAt(_tmp$6)) {
        } else {
          return false;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return true;
  } else {
    return false;
  }
}
function moonbitlang$core$string$$String$view$46$inner(self, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.length;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  return start_offset >= 0 && (start_offset <= end_offset$2 && end_offset$2 <= self.length) ? { str: self, start: start_offset, end: end_offset$2 } : moonbitlang$core$builtin$$abort$14$("Invalid index for View", "@moonbitlang/core/builtin:stringview.mbt:382:5-382:36");
}
function moonbitlang$core$string$$String$from_array(chars) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(Math.imul(chars.end - chars.start | 0, 4) | 0);
  const _len = chars.end - chars.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const c = chars.buf[chars.start + _i | 0];
      moonbitlang$core$builtin$$Logger$write_char$3$(buf, c);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return buf.val;
}
function moonbitlang$core$string$$String$char_length_eq$46$inner(self, len, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.length;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  let _tmp = start_offset;
  let _tmp$2 = 0;
  while (true) {
    const index = _tmp;
    const count = _tmp$2;
    if (index < end_offset$2 && count < len) {
      const c1 = self.charCodeAt(index);
      if (55296 <= c1 && c1 <= 56319 && (index + 1 | 0) < end_offset$2) {
        const _tmp$3 = index + 1 | 0;
        const c2 = self.charCodeAt(_tmp$3);
        if (56320 <= c2 && c2 <= 57343) {
          _tmp = index + 2 | 0;
          _tmp$2 = count + 1 | 0;
          continue;
        } else {
          moonbitlang$core$builtin$$abort$15$("invalid surrogate pair", "@moonbitlang/core/builtin:string.mbt:426:9-426:40");
        }
      }
      _tmp = index + 1 | 0;
      _tmp$2 = count + 1 | 0;
      continue;
    } else {
      return count === len && index === end_offset$2;
    }
  }
}
function moonbitlang$core$string$$String$char_length_ge$46$inner(self, len, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.length;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  let _tmp = start_offset;
  let _tmp$2 = 0;
  while (true) {
    const index = _tmp;
    const count = _tmp$2;
    if (index < end_offset$2 && count < len) {
      const c1 = self.charCodeAt(index);
      if (55296 <= c1 && c1 <= 56319 && (index + 1 | 0) < end_offset$2) {
        const _tmp$3 = index + 1 | 0;
        const c2 = self.charCodeAt(_tmp$3);
        if (56320 <= c2 && c2 <= 57343) {
          _tmp = index + 2 | 0;
          _tmp$2 = count + 1 | 0;
          continue;
        } else {
          moonbitlang$core$builtin$$abort$15$("invalid surrogate pair", "@moonbitlang/core/builtin:string.mbt:454:9-454:40");
        }
      }
      _tmp = index + 1 | 0;
      _tmp$2 = count + 1 | 0;
      continue;
    } else {
      return count >= len;
    }
  }
}
function moonbitlang$core$string$$String$offset_of_nth_char_backward(self, n, start_offset, end_offset) {
  let char_count = 0;
  let utf16_offset = end_offset;
  while (true) {
    if ((utf16_offset - 1 | 0) >= start_offset && char_count < n) {
      const _tmp = utf16_offset - 1 | 0;
      const c = self.charCodeAt(_tmp);
      if (56320 <= c && c <= 57343) {
        utf16_offset = utf16_offset - 2 | 0;
      } else {
        utf16_offset = utf16_offset - 1 | 0;
      }
      char_count = char_count + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return char_count < n || utf16_offset < start_offset ? undefined : utf16_offset;
}
function moonbitlang$core$string$$String$offset_of_nth_char_forward(self, n, start_offset, end_offset) {
  if (start_offset >= 0 && start_offset <= end_offset) {
    let utf16_offset = start_offset;
    let char_count = 0;
    while (true) {
      if (utf16_offset < end_offset && char_count < n) {
        const _tmp = utf16_offset;
        const c = self.charCodeAt(_tmp);
        if (55296 <= c && c <= 56319) {
          utf16_offset = utf16_offset + 2 | 0;
        } else {
          utf16_offset = utf16_offset + 1 | 0;
        }
        char_count = char_count + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return char_count < n || utf16_offset >= end_offset ? undefined : utf16_offset;
  } else {
    return moonbitlang$core$builtin$$abort$16$("Invalid start index", "@moonbitlang/core/builtin:string.mbt:329:5-329:33");
  }
}
function moonbitlang$core$string$$String$offset_of_nth_char$46$inner(self, i, start_offset, end_offset) {
  let end_offset$2;
  if (end_offset === undefined) {
    end_offset$2 = self.length;
  } else {
    const _Some = end_offset;
    end_offset$2 = _Some;
  }
  return i >= 0 ? moonbitlang$core$string$$String$offset_of_nth_char_forward(self, i, start_offset, end_offset$2) : moonbitlang$core$string$$String$offset_of_nth_char_backward(self, -i | 0, start_offset, end_offset$2);
}
function moonbitlang$core$builtin$$unsafe_make_string(_tmp, _tmp$2) {
  return $unsafe_make_string(_tmp, _tmp$2);
}
function moonbitlang$core$string$$String$make(length, value) {
  if (length >= 0) {
    if (value <= 65535) {
      return moonbitlang$core$builtin$$unsafe_make_string(length, value);
    } else {
      const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(Math.imul(2, length) | 0);
      let _tmp = 0;
      while (true) {
        const _ = _tmp;
        if (_ < length) {
          moonbitlang$core$builtin$$Logger$write_char$3$(buf, value);
          _tmp = _ + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return buf.val;
    }
  } else {
    return moonbitlang$core$builtin$$abort$13$("invalid length", "@moonbitlang/core/builtin:string.mbt:27:28-27:51");
  }
}
function moonbitlang$core$builtin$$StringBuilder$write_iter(self, iter) {
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$59$(iter);
    if (_bind === -1) {
      return;
    } else {
      const _Some = _bind;
      const _ch = _Some;
      moonbitlang$core$builtin$$Logger$write_char$3$(self, _ch);
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Logger$write_view$3$(self, str) {
  const _bind = self;
  _bind.val = `${_bind.val}${moonbitlang$core$builtin$$Show$to_string$14$(str)}`;
}
function moonbitlang$core$builtin$$boyer_moore_horspool_find(haystack, needle) {
  const haystack_len = haystack.end - haystack.start | 0;
  const needle_len = needle.end - needle.start | 0;
  if (needle_len > 0) {
    if (haystack_len >= needle_len) {
      const skip_table = $make_array_len_and_init(256, needle_len);
      const _end4174 = needle_len - 1 | 0;
      let _tmp = 0;
      while (true) {
        const i = _tmp;
        if (i < _end4174) {
          const _tmp$2 = needle.str;
          const _tmp$3 = needle.start + i | 0;
          const _tmp$4 = _tmp$2.charCodeAt(_tmp$3) & 255;
          $bound_check(skip_table, _tmp$4);
          skip_table[_tmp$4] = (needle_len - 1 | 0) - i | 0;
          _tmp = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      let _tmp$2 = 0;
      while (true) {
        const i = _tmp$2;
        if (i <= (haystack_len - needle_len | 0)) {
          const _end4180 = needle_len - 1 | 0;
          let _tmp$3 = 0;
          while (true) {
            const j = _tmp$3;
            if (j <= _end4180) {
              const _p = i + j | 0;
              const _tmp$4 = haystack.str;
              const _tmp$5 = haystack.start + _p | 0;
              const _tmp$6 = _tmp$4.charCodeAt(_tmp$5);
              const _tmp$7 = needle.str;
              const _tmp$8 = needle.start + j | 0;
              if (_tmp$6 !== _tmp$7.charCodeAt(_tmp$8)) {
                break;
              }
              _tmp$3 = j + 1 | 0;
              continue;
            } else {
              return i;
            }
          }
          const _p = (i + needle_len | 0) - 1 | 0;
          const _tmp$4 = haystack.str;
          const _tmp$5 = haystack.start + _p | 0;
          const _tmp$6 = _tmp$4.charCodeAt(_tmp$5) & 255;
          $bound_check(skip_table, _tmp$6);
          _tmp$2 = i + skip_table[_tmp$6] | 0;
          continue;
        } else {
          break;
        }
      }
      return undefined;
    } else {
      return undefined;
    }
  } else {
    return moonbitlang$core$builtin$$boyer_moore_horspool_find$46$constr$47$745;
  }
}
function moonbitlang$core$builtin$$brute_force_find(haystack, needle) {
  const haystack_len = haystack.end - haystack.start | 0;
  const needle_len = needle.end - needle.start | 0;
  if (needle_len > 0) {
    if (haystack_len >= needle_len) {
      const _p = 0;
      const _tmp = needle.str;
      const _tmp$2 = needle.start + _p | 0;
      const needle_first = _tmp.charCodeAt(_tmp$2);
      const forward_len = haystack_len - needle_len | 0;
      let i = 0;
      while (true) {
        if (i <= forward_len) {
          while (true) {
            let _tmp$3;
            if (i <= forward_len) {
              const _p$2 = i;
              const _tmp$4 = haystack.str;
              const _tmp$5 = haystack.start + _p$2 | 0;
              _tmp$3 = _tmp$4.charCodeAt(_tmp$5) !== needle_first;
            } else {
              _tmp$3 = false;
            }
            if (_tmp$3) {
              i = i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          if (i <= forward_len) {
            let _tmp$3 = 1;
            while (true) {
              const j = _tmp$3;
              if (j < needle_len) {
                const _p$2 = i + j | 0;
                const _tmp$4 = haystack.str;
                const _tmp$5 = haystack.start + _p$2 | 0;
                const _tmp$6 = _tmp$4.charCodeAt(_tmp$5);
                const _tmp$7 = needle.str;
                const _tmp$8 = needle.start + j | 0;
                if (_tmp$6 !== _tmp$7.charCodeAt(_tmp$8)) {
                  break;
                }
                _tmp$3 = j + 1 | 0;
                continue;
              } else {
                return i;
              }
            }
            i = i + 1 | 0;
          }
          continue;
        } else {
          break;
        }
      }
      return undefined;
    } else {
      return undefined;
    }
  } else {
    return moonbitlang$core$builtin$$brute_force_find$46$constr$47$759;
  }
}
function moonbitlang$core$string$$StringView$find(self, str) {
  return (str.end - str.start | 0) <= 4 ? moonbitlang$core$builtin$$brute_force_find(self, str) : moonbitlang$core$builtin$$boyer_moore_horspool_find(self, str);
}
function moonbitlang$core$builtin$$boyer_moore_horspool_rev_find(haystack, needle) {
  const haystack_len = haystack.end - haystack.start | 0;
  const needle_len = needle.end - needle.start | 0;
  if (needle_len > 0) {
    if (haystack_len >= needle_len) {
      const skip_table = $make_array_len_and_init(256, needle_len);
      let _tmp = needle_len - 1 | 0;
      while (true) {
        const i = _tmp;
        if (i > 0) {
          const _tmp$2 = needle.str;
          const _tmp$3 = needle.start + i | 0;
          const _tmp$4 = _tmp$2.charCodeAt(_tmp$3) & 255;
          $bound_check(skip_table, _tmp$4);
          skip_table[_tmp$4] = i;
          _tmp = i - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      let _tmp$2 = haystack_len - needle_len | 0;
      while (true) {
        const i = _tmp$2;
        if (i >= 0) {
          let _tmp$3 = 0;
          while (true) {
            const j = _tmp$3;
            if (j < needle_len) {
              const _p = i + j | 0;
              const _tmp$4 = haystack.str;
              const _tmp$5 = haystack.start + _p | 0;
              const _tmp$6 = _tmp$4.charCodeAt(_tmp$5);
              const _tmp$7 = needle.str;
              const _tmp$8 = needle.start + j | 0;
              if (_tmp$6 !== _tmp$7.charCodeAt(_tmp$8)) {
                break;
              }
              _tmp$3 = j + 1 | 0;
              continue;
            } else {
              return i;
            }
          }
          const _tmp$4 = haystack.str;
          const _tmp$5 = haystack.start + i | 0;
          const _tmp$6 = _tmp$4.charCodeAt(_tmp$5) & 255;
          $bound_check(skip_table, _tmp$6);
          _tmp$2 = i - skip_table[_tmp$6] | 0;
          continue;
        } else {
          break;
        }
      }
      return undefined;
    } else {
      return undefined;
    }
  } else {
    return haystack_len;
  }
}
function moonbitlang$core$string$$String$find(self, str) {
  return moonbitlang$core$string$$StringView$find({ str: self, start: 0, end: self.length }, str);
}
function moonbitlang$core$string$$String$repeat(self, n) {
  if (n <= 0) {
    return "";
  } else {
    if (n === 1) {
      return self;
    } else {
      const len = self.length;
      const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(Math.imul(len, n) | 0);
      const str = self;
      let _tmp = 0;
      while (true) {
        const _ = _tmp;
        if (_ < n) {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, str);
          _tmp = _ + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return buf.val;
    }
  }
}
function moonbitlang$core$builtin$$brute_force_rev_find(haystack, needle) {
  const haystack_len = haystack.end - haystack.start | 0;
  const needle_len = needle.end - needle.start | 0;
  if (needle_len > 0) {
    if (haystack_len >= needle_len) {
      const _p = 0;
      const _tmp = needle.str;
      const _tmp$2 = needle.start + _p | 0;
      const needle_first = _tmp.charCodeAt(_tmp$2);
      let i = haystack_len - needle_len | 0;
      while (true) {
        if (i >= 0) {
          while (true) {
            let _tmp$3;
            if (i >= 0) {
              const _p$2 = i;
              const _tmp$4 = haystack.str;
              const _tmp$5 = haystack.start + _p$2 | 0;
              _tmp$3 = _tmp$4.charCodeAt(_tmp$5) !== needle_first;
            } else {
              _tmp$3 = false;
            }
            if (_tmp$3) {
              i = i - 1 | 0;
              continue;
            } else {
              break;
            }
          }
          if (i >= 0) {
            let _tmp$3 = 1;
            while (true) {
              const j = _tmp$3;
              if (j < needle_len) {
                const _p$2 = i + j | 0;
                const _tmp$4 = haystack.str;
                const _tmp$5 = haystack.start + _p$2 | 0;
                const _tmp$6 = _tmp$4.charCodeAt(_tmp$5);
                const _tmp$7 = needle.str;
                const _tmp$8 = needle.start + j | 0;
                if (_tmp$6 !== _tmp$7.charCodeAt(_tmp$8)) {
                  break;
                }
                _tmp$3 = j + 1 | 0;
                continue;
              } else {
                return i;
              }
            }
            i = i - 1 | 0;
          }
          continue;
        } else {
          break;
        }
      }
      return undefined;
    } else {
      return undefined;
    }
  } else {
    return haystack_len;
  }
}
function moonbitlang$core$string$$StringView$rev_find(self, str) {
  return (str.end - str.start | 0) <= 4 ? moonbitlang$core$builtin$$brute_force_rev_find(self, str) : moonbitlang$core$builtin$$boyer_moore_horspool_rev_find(self, str);
}
function moonbitlang$core$string$$String$rev_find(self, str) {
  return moonbitlang$core$string$$StringView$rev_find({ str: self, start: 0, end: self.length }, str);
}
function moonbitlang$core$string$$StringView$has_prefix(self, str) {
  const _bind = moonbitlang$core$string$$StringView$find(self, str);
  if (_bind === undefined) {
    return false;
  } else {
    const _Some = _bind;
    const _i = _Some;
    return _i === 0;
  }
}
function moonbitlang$core$string$$String$has_prefix(self, str) {
  return moonbitlang$core$string$$StringView$has_prefix({ str: self, start: 0, end: self.length }, str);
}
function moonbitlang$core$array$$Array$push$55$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$53$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$34$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$130$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$131$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$132$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$23$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$133$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$134$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$135$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$136$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$137$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$59$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$13$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$21$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$138$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$139$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$140$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$69$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$141$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$68$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$79$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$142$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$17$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$30$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$143$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$119$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$144$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$32$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$27$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$65$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$145$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$14$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$73$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$146$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$147$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$74$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$148$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$149$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$77$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$67$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$150$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$151$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$152$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$153$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$154$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$155$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$62$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$156$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$157$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$158$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$51$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$159$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$160$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$builtin$$Iter$next$161$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$54$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$162$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$163$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$52$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$86$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$164$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$13$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$165$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$166$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$139$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$167$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$41$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$140$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$168$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$23$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$169$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$65$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$75$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$170$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$124$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$59$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$159$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$158$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$171$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$14$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$138$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$32$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$72$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$17$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$79$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$172$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$173$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$174$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$73$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$55$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$53$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$34$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$74$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$175$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$176$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$67$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$51$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$builtin$$Iter$next$62$(self) {
  const _func = self;
  return _func();
}
function moonbitlang$core$string$$StringView$contains(self, str) {
  const _bind = moonbitlang$core$string$$StringView$find(self, str);
  return !(_bind === undefined);
}
function moonbitlang$core$string$$String$contains(self, str) {
  return moonbitlang$core$string$$StringView$contains({ str: self, start: 0, end: self.length }, str);
}
function moonbitlang$core$string$$StringView$contains_char(self, c) {
  const len = self.end - self.start | 0;
  if (len > 0) {
    const c$2 = c;
    if (c$2 <= 65535) {
      let _tmp = 0;
      while (true) {
        const i = _tmp;
        if (i < len) {
          const _tmp$2 = self.str;
          const _tmp$3 = self.start + i | 0;
          if (_tmp$2.charCodeAt(_tmp$3) === c$2) {
            return true;
          }
          _tmp = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    } else {
      if (len >= 2) {
        const adj = c$2 - 65536 | 0;
        const high = 55296 + (adj >> 10) | 0;
        const low = 56320 + (adj & 1023) | 0;
        let i = 0;
        while (true) {
          if (i < (len - 1 | 0)) {
            const _p = i;
            const _tmp = self.str;
            const _tmp$2 = self.start + _p | 0;
            if (_tmp.charCodeAt(_tmp$2) === high) {
              i = i + 1 | 0;
              const _p$2 = i;
              const _tmp$3 = self.str;
              const _tmp$4 = self.start + _p$2 | 0;
              if (_tmp$3.charCodeAt(_tmp$4) === low) {
                return true;
              }
            }
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      } else {
        return false;
      }
    }
    return false;
  } else {
    return false;
  }
}
function moonbitlang$core$string$$StringView$trim_start$46$inner(self, chars) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (moonbitlang$core$string$$String$char_length_eq$46$inner(_param.str, 0, _param.start, _param.end)) {
      return _param;
    } else {
      const _c = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 0, _param.start, _param.end));
      const _tmp$2 = _param.str;
      const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, 1, _param.start, _param.end);
      let _tmp$3;
      if (_bind === undefined) {
        _tmp$3 = _param.end;
      } else {
        const _Some = _bind;
        _tmp$3 = _Some;
      }
      const _tmp$4 = _tmp$3;
      const _x = { str: _tmp$2, start: _tmp$4, end: _param.end };
      if (moonbitlang$core$string$$StringView$contains_char(chars, _c)) {
        _tmp = _x;
        continue;
      } else {
        return _param;
      }
    }
  }
}
function moonbitlang$core$string$$StringView$trim_end$46$inner(self, chars) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (moonbitlang$core$string$$String$char_length_eq$46$inner(_param.str, 0, _param.start, _param.end)) {
      return _param;
    } else {
      const _c = moonbitlang$core$string$$String$unsafe_char_at(_param.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, -1, _param.start, _param.end));
      const _x = { str: _param.str, start: _param.start, end: moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param.str, -1, _param.start, _param.end) };
      if (moonbitlang$core$string$$StringView$contains_char(chars, _c)) {
        _tmp = _x;
        continue;
      } else {
        return _param;
      }
    }
  }
}
function moonbitlang$core$string$$StringView$trim$46$inner(self, chars) {
  return moonbitlang$core$string$$StringView$trim_end$46$inner(moonbitlang$core$string$$StringView$trim_start$46$inner(self, chars), chars);
}
function moonbitlang$core$string$$String$iter(self) {
  const len = self.length;
  const index = { val: 0 };
  const _p = () => {
    if (index.val < len) {
      const _tmp = index.val;
      const c1 = self.charCodeAt(_tmp);
      if (55296 <= c1 && c1 <= 56319 && (index.val + 1 | 0) < len) {
        const _tmp$2 = index.val + 1 | 0;
        const c2 = self.charCodeAt(_tmp$2);
        if (56320 <= c2 && c2 <= 57343) {
          const c = moonbitlang$core$builtin$$code_point_of_surrogate_pair(c1, c2);
          index.val = index.val + 2 | 0;
          return c;
        }
      }
      index.val = index.val + 1 | 0;
      return c1;
    } else {
      return -1;
    }
  };
  return _p;
}
function moonbitlang$core$string$$String$pad_start(self, total_width, padding_char) {
  const len = self.length;
  if (len < total_width) {
    const padding = moonbitlang$core$string$$String$make(total_width - len | 0, padding_char);
    const _self = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
    moonbitlang$core$builtin$$StringBuilder$write_iter(_self, moonbitlang$core$string$$String$iter(padding));
    moonbitlang$core$builtin$$StringBuilder$write_iter(_self, moonbitlang$core$string$$String$iter(self));
    const _p = _self;
    return _p.val;
  } else {
    return self;
  }
}
function moonbitlang$core$builtin$$Iter$map$177$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$159$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$178$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$171$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$179$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$14$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$180$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$161$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$181$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$17$(self);
    if (_bind === undefined) {
      return Option$None$1$;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return new Option$Some$1$(f(_x));
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$182$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$17$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$183$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$55$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$184$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$53$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$185$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$34$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$186$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$176$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$187$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$67$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$188$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$75$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$189$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$59$(self);
    if (_bind === -1) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Iter$map$190$(self, f) {
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$163$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return f(_x);
    }
  };
}
function moonbitlang$core$builtin$$Show$to_string$59$(self) {
  return String.fromCodePoint(self);
}
function moonbitlang$core$string$$StringView$split(self, sep) {
  const sep_len = sep.end - sep.start | 0;
  if (sep_len === 0) {
    return moonbitlang$core$builtin$$Iter$map$189$(moonbitlang$core$string$$StringView$iter(self), (c) => moonbitlang$core$string$$String$view$46$inner(moonbitlang$core$builtin$$Show$to_string$59$(c), 0, undefined));
  }
  const remaining = { val: self };
  const _p = () => {
    const _bind = remaining.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _view = _Some;
      const _bind$2 = moonbitlang$core$string$$StringView$find(_view, sep);
      if (_bind$2 === undefined) {
        remaining.val = undefined;
        return _view;
      } else {
        const _Some$2 = _bind$2;
        const _end = _Some$2;
        remaining.val = moonbitlang$core$string$$StringView$view$46$inner(_view, _end + sep_len | 0, undefined);
        return moonbitlang$core$string$$StringView$view$46$inner(_view, 0, _end);
      }
    }
  };
  return _p;
}
function moonbitlang$core$string$$String$split(self, sep) {
  return moonbitlang$core$string$$StringView$split({ str: self, start: 0, end: self.length }, sep);
}
function moonbitlang$core$builtin$$Iter$to_array$139$(self) {
  const result = [];
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$139$(self);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      moonbitlang$core$array$$Array$push$139$(result, _x);
      continue;
    }
  }
  return result;
}
function moonbitlang$core$builtin$$Iter$to_array$14$(self) {
  const result = [];
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$14$(self);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      moonbitlang$core$array$$Array$push$14$(result, _x);
      continue;
    }
  }
  return result;
}
function moonbitlang$core$builtin$$Iter$to_array$13$(self) {
  const result = [];
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$13$(self);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      moonbitlang$core$array$$Array$push$13$(result, _x);
      continue;
    }
  }
  return result;
}
function moonbitlang$core$string$$String$replace_all(self, old, new_) {
  const len = self.length;
  const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(len);
  const old_len = old.end - old.start | 0;
  const new$2 = moonbitlang$core$builtin$$Show$to_string$14$(new_);
  if (old_len === 0) {
    moonbitlang$core$builtin$$Logger$write_string$3$(buf, new$2);
    const _it = moonbitlang$core$string$$String$iter(self);
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$59$(_it);
      if (_bind === -1) {
        break;
      } else {
        const _Some = _bind;
        const _c = _Some;
        moonbitlang$core$builtin$$Logger$write_char$3$(buf, _c);
        moonbitlang$core$builtin$$Logger$write_string$3$(buf, new$2);
        continue;
      }
    }
    return buf.val;
  } else {
    const first_end = moonbitlang$core$string$$String$find(self, old);
    if (first_end === undefined) {
      return self;
    } else {
      const _Some = first_end;
      const _end = _Some;
      let _tmp = { str: self, start: 0, end: self.length };
      let _tmp$2 = _end;
      while (true) {
        const view = _tmp;
        const end = _tmp$2;
        const seg = moonbitlang$core$string$$StringView$view$46$inner(view, 0, end);
        moonbitlang$core$builtin$$Logger$write_substring$4$(buf, seg.str, seg.start, seg.end - seg.start | 0);
        moonbitlang$core$builtin$$Logger$write_string$3$(buf, new$2);
        if ((end + old_len | 0) <= len) {
          const next_view = moonbitlang$core$string$$StringView$view$46$inner(view, end + old_len | 0, undefined);
          const _bind = moonbitlang$core$string$$StringView$find(next_view, old);
          if (_bind === undefined) {
            moonbitlang$core$builtin$$Logger$write_substring$4$(buf, next_view.str, next_view.start, next_view.end - next_view.start | 0);
            break;
          } else {
            const _Some$2 = _bind;
            const _next_end = _Some$2;
            _tmp = next_view;
            _tmp$2 = _next_end;
            continue;
          }
        } else {
          break;
        }
      }
      return buf.val;
    }
  }
}
function moonbitlang$core$builtin$$ToStringView$to_string_view$13$(self) {
  return { str: self, start: 0, end: self.length };
}
function moonbitlang$core$string$$String$substring$46$inner(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    end$2 = _Some;
  }
  return start >= 0 && (start <= end$2 && end$2 <= len) ? self.substring(start, end$2) : $panic();
}
function moonbitlang$core$builtin$$Compare$compare$13$(self, other) {
  const len = self.length;
  const _bind = $compare_int(len, other.length);
  if (_bind === 0) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const order = $compare_int(self.charCodeAt(i), other.charCodeAt(i));
        if (order !== 0) {
          return order;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return 0;
  } else {
    return _bind;
  }
}
function moonbitlang$core$builtin$$Show$output$17$(self, logger) {
  logger.method_table.method_0(logger.self, moonbitlang$core$int$$Int$to_string$46$inner(self, 10));
}
function moonbitlang$core$builtin$$Show$output$48$(self, logger) {
  if (self === undefined) {
    logger.method_table.method_0(logger.self, "None");
    return;
  } else {
    const _Some = self;
    const _arg = _Some;
    logger.method_table.method_0(logger.self, "Some(");
    moonbitlang$core$builtin$$Logger$write_object$13$(logger, _arg);
    logger.method_table.method_0(logger.self, ")");
    return;
  }
}
function moonbitlang$core$array$$ArrayView$iter$13$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$23$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$159$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$158$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$138$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$32$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$41$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$79$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$55$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$53$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$34$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$67$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$75$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$51$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$iter$62$(self) {
  const i = { val: 0 };
  const _p = () => {
    if (i.val < (self.end - self.start | 0)) {
      const elem = self.buf[self.start + i.val | 0];
      i.val = i.val + 1 | 0;
      return elem;
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$Array$iter$23$(self) {
  return moonbitlang$core$array$$ArrayView$iter$23$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$159$(self) {
  return moonbitlang$core$array$$ArrayView$iter$159$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$158$(self) {
  return moonbitlang$core$array$$ArrayView$iter$158$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$138$(self) {
  return moonbitlang$core$array$$ArrayView$iter$138$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$32$(self) {
  return moonbitlang$core$array$$ArrayView$iter$32$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$41$(self) {
  return moonbitlang$core$array$$ArrayView$iter$41$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$79$(self) {
  return moonbitlang$core$array$$ArrayView$iter$79$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$13$(self) {
  return moonbitlang$core$array$$ArrayView$iter$13$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$55$(self) {
  return moonbitlang$core$array$$ArrayView$iter$55$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$53$(self) {
  return moonbitlang$core$array$$ArrayView$iter$53$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$34$(self) {
  return moonbitlang$core$array$$ArrayView$iter$34$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$67$(self) {
  return moonbitlang$core$array$$ArrayView$iter$67$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$75$(self) {
  return moonbitlang$core$array$$ArrayView$iter$75$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$51$(self) {
  return moonbitlang$core$array$$ArrayView$iter$51$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$iter$62$(self) {
  return moonbitlang$core$array$$ArrayView$iter$62$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$builtin$$Show$output$50$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$46$inner$51$(logger, moonbitlang$core$array$$Array$iter$51$(self), "[", "]", ", ", false);
}
function moonbitlang$core$builtin$$Show$output$58$(self, logger) {
  moonbitlang$core$builtin$$Logger$write_iter$46$inner$62$(logger, moonbitlang$core$array$$Array$iter$62$(self), "[", "]", ", ", false);
}
function moonbitlang$core$array$$FixedArray$makei$191$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = $make_array_len_and_init(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        $bound_check(array, i);
        array[i] = value(i);
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$FixedArray$makei$192$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = $make_array_len_and_init(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        $bound_check(array, i);
        array[i] = value(i);
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$FixedArray$makei$193$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = $make_array_len_and_init(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        $bound_check(array, i);
        array[i] = value(i);
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$FixedArray$makei$194$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = $make_array_len_and_init(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        $bound_check(array, i);
        array[i] = value(i);
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$FixedArray$makei$195$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = $make_array_len_and_init(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        $bound_check(array, i);
        array[i] = value(i);
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$FixedArray$makei$196$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = $make_array_len_and_init(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        $bound_check(array, i);
        array[i] = value(i);
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$FixedArray$makei$197$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = $make_array_len_and_init(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        $bound_check(array, i);
        array[i] = value(i);
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$FixedArray$from_array$17$(array) {
  const _p = array.end - array.start | 0;
  if (_p <= 0) {
    return [];
  } else {
    const _p$2 = 0;
    const _p$3 = $make_array_len_and_init(_p, array.buf[array.start + _p$2 | 0]);
    let _tmp = 1;
    while (true) {
      const _p$4 = _tmp;
      if (_p$4 < _p) {
        $bound_check(_p$3, _p$4);
        _p$3[_p$4] = array.buf[array.start + _p$4 | 0];
        _tmp = _p$4 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return _p$3;
  }
}
function moonbitlang$core$array$$FixedArray$from_array$31$(array) {
  const _p = array.end - array.start | 0;
  if (_p <= 0) {
    return [];
  } else {
    const _p$2 = 0;
    const _p$3 = $make_array_len_and_init(_p, array.buf[array.start + _p$2 | 0]);
    let _tmp = 1;
    while (true) {
      const _p$4 = _tmp;
      if (_p$4 < _p) {
        $bound_check(_p$3, _p$4);
        _p$3[_p$4] = array.buf[array.start + _p$4 | 0];
        _tmp = _p$4 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return _p$3;
  }
}
function moonbitlang$core$array$$FixedArray$map$198$(self, f) {
  if (self.length === 0) {
    return [];
  }
  const _tmp = self.length;
  $bound_check(self, 0);
  const res = $make_array_len_and_init(_tmp, f(self[0]));
  const _end2230 = self.length;
  let _tmp$2 = 1;
  while (true) {
    const i = _tmp$2;
    if (i < _end2230) {
      $bound_check(self, i);
      $bound_check(res, i);
      res[i] = f(self[i]);
      _tmp$2 = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return res;
}
function moonbitlang$core$array$$FixedArray$fold$199$(self, init, f) {
  let _tmp = 0;
  let _tmp$2 = init;
  while (true) {
    const i = _tmp;
    const acc = _tmp$2;
    if (i < self.length) {
      _tmp = i + 1 | 0;
      $bound_check(self, i);
      _tmp$2 = f(acc, self[i]);
      continue;
    } else {
      return acc;
    }
  }
}
function moonbitlang$core$array$$ArrayView$search$34$(self, value) {
  const _end981 = self.end - self.start | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end981) {
      const _p = self.buf[self.start + i | 0];
      if (_p.num === value.num) {
        return i;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return undefined;
    }
  }
}
function moonbitlang$core$array$$ArrayView$at$21$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$21$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$array$$ArrayView$at$27$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$27$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$array$$ArrayView$at$28$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$28$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$array$$ArrayView$at$30$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$30$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$array$$ArrayView$at$32$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$32$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$array$$ArrayView$at$37$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$37$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$array$$ArrayView$at$39$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$39$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$array$$ArrayView$at$44$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$44$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:arrayview.mbt:124:5-126:6");
  }
}
function moonbitlang$core$builtin$$Default$default$200$() {
  return [];
}
function moonbitlang$core$builtin$$Default$default$201$() {
  return [];
}
function moonbitlang$core$builtin$$Eq$equal$48$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return _x === _y;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$84$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$202$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$88$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$203$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$90$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return _x.key === _y.key;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$92$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$204$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$94$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return _x.value === _y.value;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$96$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$205$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$98$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$206$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$100$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$207$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$103$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Eq$equal$208$(_x, _y);
    }
  }
}
function moonbitlang$core$option$$Option$unwrap_or$209$(self, default_) {
  if (self.$tag === 0) {
    return default_;
  } else {
    const _Some = self;
    return _Some._0;
  }
}
function moonbitlang$core$option$$Option$unwrap_or_else$210$(self, default_) {
  if (self === undefined) {
    return default_();
  } else {
    const _Some = self;
    const _t = _Some;
    return _t;
  }
}
function moonbitlang$core$builtin$$Compare$compare$48$(self, other) {
  if (self === undefined) {
    return other === undefined ? 0 : -1;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return 1;
    } else {
      const _Some$2 = other;
      const _y = _Some$2;
      return moonbitlang$core$builtin$$Compare$compare$13$(_x, _y);
    }
  }
}
function moonbitlang$core$builtin$$Iter$empty$166$() {
  return () => undefined;
}
function moonbitlang$core$builtin$$Iter$empty$17$() {
  return () => undefined;
}
function moonbitlang$core$builtin$$Iter$singleton$170$(elem) {
  const consumed = { val: false };
  return () => {
    if (consumed.val) {
      return undefined;
    } else {
      consumed.val = true;
      return elem;
    }
  };
}
function moonbitlang$core$array$$MutArrayView$at$34$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$34$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:mutarrayview.mbt:97:5-99:6");
  }
}
function moonbitlang$core$array$$MutArrayView$at$41$(self, index) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    return _tmp[_tmp$2];
  } else {
    return moonbitlang$core$builtin$$abort$41$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:mutarrayview.mbt:97:5-99:6");
  }
}
function moonbitlang$core$array$$MutArrayView$set$34$(self, index, value) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    _tmp[_tmp$2] = value;
    return;
  } else {
    moonbitlang$core$builtin$$abort$15$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:mutarrayview.mbt:161:5-163:6");
    return;
  }
}
function moonbitlang$core$array$$MutArrayView$set$41$(self, index, value) {
  if (index >= 0 && index < (self.end - self.start | 0)) {
    const _tmp = self.buf;
    const _tmp$2 = self.start + index | 0;
    $bound_check(_tmp, _tmp$2);
    _tmp[_tmp$2] = value;
    return;
  } else {
    moonbitlang$core$builtin$$abort$15$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.end - self.start | 0)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:mutarrayview.mbt:161:5-163:6");
    return;
  }
}
function moonbitlang$core$array$$Array$mut_view$46$inner$34$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, end: end$2 } : moonbitlang$core$builtin$$abort$24$("View index out of bounds", "@moonbitlang/core/builtin:mutarrayview.mbt:237:5-237:38");
}
function moonbitlang$core$array$$Array$mut_view$46$inner$41$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, end: end$2 } : moonbitlang$core$builtin$$abort$29$("View index out of bounds", "@moonbitlang/core/builtin:mutarrayview.mbt:237:5-237:38");
}
function moonbitlang$core$array$$MutArrayView$mut_view$46$inner$34$(self, start, end) {
  const len = self.end - self.start | 0;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, end: (self.start + start$2 | 0) + (end$2 - start$2 | 0) | 0 } : moonbitlang$core$builtin$$abort$24$("View index out of bounds", "@moonbitlang/core/builtin:mutarrayview.mbt:286:5-286:38");
}
function moonbitlang$core$array$$MutArrayView$mut_view$46$inner$41$(self, start, end) {
  const len = self.end - self.start | 0;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, end: (self.start + start$2 | 0) + (end$2 - start$2 | 0) | 0 } : moonbitlang$core$builtin$$abort$29$("View index out of bounds", "@moonbitlang/core/builtin:mutarrayview.mbt:286:5-286:38");
}
function moonbitlang$core$int$$Int$next_power_of_two(self) {
  if (self >= 0) {
    if (self <= 1) {
      return 1;
    }
    if (self > 1073741824) {
      return 1073741824;
    }
    return (2147483647 >> (Math.clz32(self - 1 | 0) - 1 | 0)) + 1 | 0;
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$Map$new$46$inner$211$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$212$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$213$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$214$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$215$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$216$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$217$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$218$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$219$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$220$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$new$46$inner$221$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$214$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$211$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$212$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$215$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$213$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$216$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$218$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$219$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$217$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$220$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$221$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$builtin$$Map$set_entry$214$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$211$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$212$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$215$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$213$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$216$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$218$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$219$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$217$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$220$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set_entry$221$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$builtin$$Map$push_away$214$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$214$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$214$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$211$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$211$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$211$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$212$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$212$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$212$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$215$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$215$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$215$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$213$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$213$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$213$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$216$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$216$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$216$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$218$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$218$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$218$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$219$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$219$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$219$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$217$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$217$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$217$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$220$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$220$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$220$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$push_away$221$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$builtin$$Map$set_entry$221$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$builtin$$Map$set_entry$221$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set_with_hash$211$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$211$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$211$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$211$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$212$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$212$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$212$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$212$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$214$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$214$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$214$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$214$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$215$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$215$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$215$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$215$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$213$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$213$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$213$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$213$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$216$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$216$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$216$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$216$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$218$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$218$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$218$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$218$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$219$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$219$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$219$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$219$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$217$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$217$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$217$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$217$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$220$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$220$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$220$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$220$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$set_with_hash$221$(self, key, value, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$221$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        _curr_entry.value = value;
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$builtin$$Map$push_away$221$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key, value: value };
  moonbitlang$core$builtin$$Map$add_entry_to_tail$221$(self, _idx, entry);
}
function moonbitlang$core$builtin$$Map$grow$214$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$214$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$211$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$211$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$212$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$212$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$215$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$215$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$213$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$213$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$216$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$216$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$218$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$218$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$219$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$219$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$217$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$217$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$220$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$220$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$221$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _value = _x.value;
      const _hash = _x.hash;
      moonbitlang$core$builtin$$Map$set_with_hash$221$(self, _key, _value, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$set$211$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$211$(self, key, value, moonbitlang$core$builtin$$Hash$hash$108$(key));
}
function moonbitlang$core$builtin$$Map$set$212$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$212$(self, key, value, moonbitlang$core$builtin$$Hash$hash$108$(key));
}
function moonbitlang$core$builtin$$Map$set$214$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$214$(self, key, value, moonbitlang$core$builtin$$Hash$hash$111$(key));
}
function moonbitlang$core$builtin$$Map$set$215$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$215$(self, key, value, moonbitlang$core$builtin$$Hash$hash$111$(key));
}
function moonbitlang$core$builtin$$Map$set$213$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$213$(self, key, value, moonbitlang$core$builtin$$Hash$hash$111$(key));
}
function moonbitlang$core$builtin$$Map$set$216$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$216$(self, key, value, moonbitlang$core$builtin$$Hash$hash$108$(key));
}
function moonbitlang$core$builtin$$Map$set$218$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$218$(self, key, value, moonbitlang$core$builtin$$Hash$hash$108$(key));
}
function moonbitlang$core$builtin$$Map$set$219$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$219$(self, key, value, moonbitlang$core$builtin$$Hash$hash$108$(key));
}
function moonbitlang$core$builtin$$Map$set$217$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$217$(self, key, value, moonbitlang$core$builtin$$Hash$hash$108$(key));
}
function moonbitlang$core$builtin$$Map$set$220$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$220$(self, key, value, moonbitlang$core$builtin$$Hash$hash$108$(key));
}
function moonbitlang$core$builtin$$Map$set$221$(self, key, value) {
  moonbitlang$core$builtin$$Map$set_with_hash$221$(self, key, value, moonbitlang$core$builtin$$Hash$hash$108$(key));
}
function moonbitlang$core$builtin$$Map$from_array$211$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$211$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$211$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$212$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$212$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$212$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$213$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$213$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$213$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$214$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$214$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$214$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$215$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$215$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$215$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$216$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$216$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$216$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$217$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$217$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$217$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$218$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$218$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$218$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$219$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$219$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$219$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$220$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$220$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$220$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$221$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$builtin$$Map$new$46$inner$221$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$builtin$$Map$set$221$(m, e._0, e._1);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$builtin$$Map$get$215$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$111$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$213$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$111$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$216$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$211$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$212$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$219$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$220$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$221$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (i > _entry.psl) {
        return undefined;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get_or_init$214$(self, key, default_) {
  const hash = moonbitlang$core$builtin$$Hash$hash$111$(key);
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      const new_value = default_();
      _bind = { _0: idx, _1: psl, _2: new_value, _3: undefined };
      break;
    } else {
      const _Some = _bind$2;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry.value;
      }
      if (psl > _entry.psl) {
        const new_value = default_();
        _bind = { _0: idx, _1: psl, _2: new_value, _3: _entry };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _new_value = _bind._2;
  const _push_away = _bind._3;
  if (self.size >= self.grow_at) {
    moonbitlang$core$builtin$$Map$grow$214$(self);
    moonbitlang$core$builtin$$Map$set_with_hash$214$(self, key, _new_value, hash);
  } else {
    if (_push_away === undefined) {
    } else {
      const _Some = _push_away;
      const _entry = _Some;
      moonbitlang$core$builtin$$Map$push_away$214$(self, _idx, _entry);
    }
    const entry = { prev: self.tail, next: undefined, psl: _psl, hash: hash, key: key, value: _new_value };
    moonbitlang$core$builtin$$Map$add_entry_to_tail$214$(self, _idx, entry);
  }
  return _new_value;
}
function moonbitlang$core$builtin$$Map$contains$216$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$iter$216$(self) {
  const curr_entry = { val: self.head };
  const _p = () => {
    const _bind = curr_entry.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _key = _x.key;
      const _value = _x.value;
      const _next = _x.next;
      curr_entry.val = _next;
      return { _0: _key, _1: _value };
    }
  };
  return _p;
}
function moonbitlang$core$builtin$$Map$iter$218$(self) {
  const curr_entry = { val: self.head };
  const _p = () => {
    const _bind = curr_entry.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _key = _x.key;
      const _value = _x.value;
      const _next = _x.next;
      curr_entry.val = _next;
      return { _0: _key, _1: _value };
    }
  };
  return _p;
}
function moonbitlang$core$builtin$$Map$iter2$216$(self) {
  return moonbitlang$core$builtin$$Map$iter$216$(self);
}
function moonbitlang$core$builtin$$Map$values$217$(self) {
  const curr_entry = { val: self.head };
  const _p = () => {
    const _bind = curr_entry.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _value = _x.value;
      const _next = _x.next;
      curr_entry.val = _next;
      return _value;
    }
  };
  return _p;
}
function moonbitlang$core$builtin$$ToJson$to_json$17$(self) {
  const _p = self + 0;
  const _p$2 = undefined;
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Number(_p, _p$2);
}
function moonbitlang$core$builtin$$ToJson$to_json$222$(self) {
  const _p = new Array(self.length);
  const _p$2 = self.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = self[_p$3];
      _p[_p$3] = moonbitlang$core$builtin$$ToJson$to_json$130$(_p$4);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Array(_p);
}
function moonbitlang$core$builtin$$Iter$filter$139$(self, f) {
  return () => {
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$139$(self);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _x = _Some;
        if (f(_x)) {
          return _x;
        }
        continue;
      }
    }
  };
}
function moonbitlang$core$builtin$$Iter$filter$161$(self, f) {
  return () => {
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$161$(self);
      if (_bind === undefined) {
        return undefined;
      } else {
        const _Some = _bind;
        const _x = _Some;
        if (f(_x)) {
          return _x;
        }
        continue;
      }
    }
  };
}
function moonbitlang$core$builtin$$Iter$mapi$223$(self, f) {
  const i = { val: 0 };
  return () => {
    const _bind = moonbitlang$core$builtin$$Iter$next$79$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const result = f(i.val, _x);
      i.val = i.val + 1 | 0;
      return result;
    }
  };
}
function moonbitlang$core$builtin$$Iter$flat_map$224$(self, f) {
  const current_iter = { val: moonbitlang$core$builtin$$Iter$empty$166$() };
  return () => {
    const _bind = current_iter.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _iter = _Some;
      let _tmp = moonbitlang$core$builtin$$Iter$next$166$(_iter);
      while (true) {
        const _param = _tmp;
        if (_param === undefined) {
          const _bind$2 = moonbitlang$core$builtin$$Iter$next$158$(self);
          if (_bind$2 === undefined) {
            return undefined;
          } else {
            const _Some$2 = _bind$2;
            const _x = _Some$2;
            const iter = f(_x);
            current_iter.val = iter;
            _tmp = moonbitlang$core$builtin$$Iter$next$166$(iter);
            continue;
          }
        } else {
          const _Some$2 = _param;
          return _Some$2;
        }
      }
    }
  };
}
function moonbitlang$core$builtin$$Iter$join(self, sep) {
  const result = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  const _bind = moonbitlang$core$builtin$$Iter$next$13$(self);
  if (_bind === undefined) {
  } else {
    const _Some = _bind;
    const _x = _Some;
    moonbitlang$core$builtin$$Logger$write_string$3$(result, _x);
    while (true) {
      const _bind$2 = moonbitlang$core$builtin$$Iter$next$13$(self);
      if (_bind$2 === undefined) {
        break;
      } else {
        const _Some$2 = _bind$2;
        const _x$2 = _Some$2;
        moonbitlang$core$builtin$$Logger$write_string$3$(result, sep);
        moonbitlang$core$builtin$$Logger$write_string$3$(result, _x$2);
        continue;
      }
    }
  }
  return result.val;
}
function moonbitlang$core$builtin$$Iter$find_first$54$(self, f) {
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$54$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (f(_x)) {
        return _x;
      }
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Iter$find_first$23$(self, f) {
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$23$(self);
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (f(_x)) {
        return _x;
      }
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Iter$concat$170$(self, other) {
  const in_first = { val: true };
  return () => {
    if (in_first.val) {
      const result = moonbitlang$core$builtin$$Iter$next$170$(self);
      if (result === undefined) {
        in_first.val = false;
        return moonbitlang$core$builtin$$Iter$next$170$(other);
      } else {
        return result;
      }
    } else {
      return moonbitlang$core$builtin$$Iter$next$170$(other);
    }
  };
}
function moonbitlang$core$builtin$$Add$add$225$(self, other) {
  return moonbitlang$core$builtin$$Iter$concat$170$(self, other);
}
function moonbitlang$core$builtin$$Iter$contains$53$(self, value) {
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$53$(self);
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.num === value.num) {
        return true;
      }
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Iter2$next$216$(self) {
  return moonbitlang$core$builtin$$Iter$next$161$(self);
}
function moonbitlang$core$builtin$$Iter2$next$127$(self) {
  return moonbitlang$core$builtin$$Iter$next$165$(self);
}
function moonbitlang$core$builtin$$Iter2$next$128$(self) {
  return moonbitlang$core$builtin$$Iter$next$169$(self);
}
function moonbitlang$core$builtin$$Iter2$next$226$(self) {
  return moonbitlang$core$builtin$$Iter$next$172$(self);
}
function moonbitlang$core$builtin$$Iter2$next$129$(self) {
  return moonbitlang$core$builtin$$Iter$next$173$(self);
}
function moonbitlang$core$builtin$$Iter2$next$227$(self) {
  return moonbitlang$core$builtin$$Iter$next$174$(self);
}
function moonbitlang$core$builtin$$Iter2$next$228$(self) {
  return moonbitlang$core$builtin$$Iter$next$175$(self);
}
function moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, bhi, blo) {
  const _ahi = self.hi;
  const _alo = self.lo;
  const lo = _alo + blo | 0;
  const s = lo >> 31;
  const as_ = _alo >> 31;
  const bs = blo >> 31;
  const c = (as_ & bs | ~s & (as_ ^ bs)) & 1;
  const hi = (_ahi + bhi | 0) + c | 0;
  return { hi: hi, lo: lo };
}
function moonbitlang$core$builtin$$Add$add$229$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, other.hi, other.lo);
}
function moonbitlang$core$builtin$$Sub$sub$229$(self, other) {
  return other.lo === 0 ? { hi: self.hi - other.hi | 0, lo: self.lo } : moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, ~other.hi, ~other.lo + 1 | 0);
}
function moonbitlang$core$builtin$$Mul$mul$229$(self, other) {
  const _ahi = self.hi;
  const _alo = self.lo;
  const _bhi = other.hi;
  const _blo = other.lo;
  const ahi = _ahi;
  const alo = _alo;
  const bhi = _bhi;
  const blo = _blo;
  const a48 = ahi >>> 16 | 0;
  const a32 = ahi & 65535;
  const a16 = alo >>> 16 | 0;
  const a00 = alo & 65535;
  const b48 = bhi >>> 16 | 0;
  const b32 = bhi & 65535;
  const b16 = blo >>> 16 | 0;
  const b00 = blo & 65535;
  const c00 = Math.imul(a00, b00) | 0;
  const c16 = c00 >>> 16 | 0;
  const c00$2 = c00 & 65535;
  const c16$2 = (c16 >>> 0) + ((Math.imul(a16, b00) | 0) >>> 0) | 0;
  const c32 = c16$2 >>> 16 | 0;
  const c16$3 = c16$2 & 65535;
  const c16$4 = (c16$3 >>> 0) + ((Math.imul(a00, b16) | 0) >>> 0) | 0;
  const c32$2 = (c32 >>> 0) + ((c16$4 >>> 16 | 0) >>> 0) | 0;
  const c16$5 = c16$4 & 65535;
  const c32$3 = (c32$2 >>> 0) + ((Math.imul(a32, b00) | 0) >>> 0) | 0;
  const c48 = c32$3 >>> 16 | 0;
  const c32$4 = c32$3 & 65535;
  const c32$5 = (c32$4 >>> 0) + ((Math.imul(a16, b16) | 0) >>> 0) | 0;
  const c48$2 = (c48 >>> 0) + ((c32$5 >>> 16 | 0) >>> 0) | 0;
  const c32$6 = c32$5 & 65535;
  const c32$7 = (c32$6 >>> 0) + ((Math.imul(a00, b32) | 0) >>> 0) | 0;
  const c48$3 = (c48$2 >>> 0) + ((c32$7 >>> 16 | 0) >>> 0) | 0;
  const c32$8 = c32$7 & 65535;
  const c48$4 = (((((((c48$3 >>> 0) + ((Math.imul(a48, b00) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a32, b16) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a16, b32) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a00, b48) | 0) >>> 0) | 0;
  const c48$5 = c48$4 & 65535;
  return { hi: c48$5 << 16 | c32$8, lo: c16$5 << 16 | c00$2 };
}
function moonbitlang$core$builtin$$try_get_int64_wasm_helper() {
  if (moonbitlang$core$builtin$$wasm_helper_cache.tried) {
    const _bind = moonbitlang$core$builtin$$wasm_helper_cache.exports;
    return !(_bind === undefined);
  }
  moonbitlang$core$builtin$$wasm_helper_cache.tried = true;
  moonbitlang$core$builtin$$wasm_helper_cache.exports = moonbitlang$core$builtin$$try_init_wasm_helper();
  const _bind = moonbitlang$core$builtin$$wasm_helper_cache.exports;
  return !(_bind === undefined);
}
function moonbitlang$core$builtin$$Div$div$229$(self, other) {
  if (!(other.hi === 0 && other.lo === 0)) {
    if (!moonbitlang$core$builtin$$try_get_int64_wasm_helper()) {
      return moonbitlang$core$builtin$$MyInt64$div_bigint(self, other);
    }
    const _bind = moonbitlang$core$builtin$$wasm_helper_cache.exports;
    if (_bind === undefined) {
      return $panic();
    } else {
      const _Some = _bind;
      const _exports = _Some;
      const _ahi = self.hi;
      const _alo = self.lo;
      const _bhi = other.hi;
      const _blo = other.lo;
      const _func = _exports.div_s;
      const lo = _func(_alo, _ahi, _blo, _bhi);
      const _func$2 = _exports.get_high;
      const hi = _func$2();
      return { hi: hi, lo: lo };
    }
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$Add$add$107$(self, other) {
  return moonbitlang$core$builtin$$Add$add$229$(self, other);
}
function moonbitlang$core$builtin$$Sub$sub$107$(self, other) {
  return moonbitlang$core$builtin$$Sub$sub$229$(self, other);
}
function moonbitlang$core$builtin$$Mul$mul$107$(self, other) {
  return moonbitlang$core$builtin$$Mul$mul$229$(self, other);
}
function moonbitlang$core$builtin$$Div$div$107$(self, other) {
  return moonbitlang$core$builtin$$Div$div$229$(self, other);
}
function moonbitlang$core$builtin$$Compare$compare$107$(self, other) {
  return moonbitlang$core$builtin$$MyInt64$compare(self, other);
}
function moonbitlang$core$int64$$Int64$to_int(self) {
  const _p = self;
  return _p.lo;
}
function moonbitlang$core$builtin$$Hasher$combine_string(self, value) {
  const _end2373 = value.length;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < _end2373) {
      moonbitlang$core$builtin$$Hasher$combine_uint(self, value.charCodeAt(i));
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$13$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_string(hasher, self);
}
function moonbitlang$core$builtin$$Hash$hash_combine$17$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self);
}
function moonbitlang$core$array$$FixedArray$blit_to$46$inner$65$(self, dst, len, src_offset, dst_offset) {
  if (dst_offset >= 0 && (src_offset >= 0 && ((dst_offset + len | 0) <= dst.length && (src_offset + len | 0) <= self.length))) {
    moonbitlang$core$array$$FixedArray$unsafe_blit$65$(dst, dst_offset, self, src_offset, len);
    return;
  } else {
    moonbitlang$core$builtin$$abort$15$(`bounds check failed: dst_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(dst_offset)}, src_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(src_offset)}, len = ${moonbitlang$core$builtin$$Show$to_string$111$(len)}, dst.length = ${moonbitlang$core$builtin$$Show$to_string$111$(dst.length)}, self.length = ${moonbitlang$core$builtin$$Show$to_string$111$(self.length)}`, "@moonbitlang/core/builtin:fixedarray_block.mbt:115:5-117:6");
    return;
  }
}
function moonbitlang$core$array$$FixedArray$blit_to$46$inner$17$(self, dst, len, src_offset, dst_offset) {
  if (dst_offset >= 0 && (src_offset >= 0 && ((dst_offset + len | 0) <= dst.length && (src_offset + len | 0) <= self.length))) {
    moonbitlang$core$array$$FixedArray$unsafe_blit$17$(dst, dst_offset, self, src_offset, len);
    return;
  } else {
    moonbitlang$core$builtin$$abort$15$(`bounds check failed: dst_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(dst_offset)}, src_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(src_offset)}, len = ${moonbitlang$core$builtin$$Show$to_string$111$(len)}, dst.length = ${moonbitlang$core$builtin$$Show$to_string$111$(dst.length)}, self.length = ${moonbitlang$core$builtin$$Show$to_string$111$(self.length)}`, "@moonbitlang/core/builtin:fixedarray_block.mbt:115:5-117:6");
    return;
  }
}
function moonbitlang$core$array$$FixedArray$blit_to$46$inner$26$(self, dst, len, src_offset, dst_offset) {
  if (dst_offset >= 0 && (src_offset >= 0 && ((dst_offset + len | 0) <= dst.length && (src_offset + len | 0) <= self.length))) {
    moonbitlang$core$array$$FixedArray$unsafe_blit$26$(dst, dst_offset, self, src_offset, len);
    return;
  } else {
    moonbitlang$core$builtin$$abort$15$(`bounds check failed: dst_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(dst_offset)}, src_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(src_offset)}, len = ${moonbitlang$core$builtin$$Show$to_string$111$(len)}, dst.length = ${moonbitlang$core$builtin$$Show$to_string$111$(dst.length)}, self.length = ${moonbitlang$core$builtin$$Show$to_string$111$(self.length)}`, "@moonbitlang/core/builtin:fixedarray_block.mbt:115:5-117:6");
    return;
  }
}
function moonbitlang$core$array$$FixedArray$blit_to$46$inner$32$(self, dst, len, src_offset, dst_offset) {
  if (dst_offset >= 0 && (src_offset >= 0 && ((dst_offset + len | 0) <= dst.length && (src_offset + len | 0) <= self.length))) {
    moonbitlang$core$array$$FixedArray$unsafe_blit$32$(dst, dst_offset, self, src_offset, len);
    return;
  } else {
    moonbitlang$core$builtin$$abort$15$(`bounds check failed: dst_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(dst_offset)}, src_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(src_offset)}, len = ${moonbitlang$core$builtin$$Show$to_string$111$(len)}, dst.length = ${moonbitlang$core$builtin$$Show$to_string$111$(dst.length)}, self.length = ${moonbitlang$core$builtin$$Show$to_string$111$(self.length)}`, "@moonbitlang/core/builtin:fixedarray_block.mbt:115:5-117:6");
    return;
  }
}
function moonbitlang$core$array$$FixedArray$blit_to$46$inner$31$(self, dst, len, src_offset, dst_offset) {
  if (dst_offset >= 0 && (src_offset >= 0 && ((dst_offset + len | 0) <= dst.length && (src_offset + len | 0) <= self.length))) {
    moonbitlang$core$array$$FixedArray$unsafe_blit$31$(dst, dst_offset, self, src_offset, len);
    return;
  } else {
    moonbitlang$core$builtin$$abort$15$(`bounds check failed: dst_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(dst_offset)}, src_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(src_offset)}, len = ${moonbitlang$core$builtin$$Show$to_string$111$(len)}, dst.length = ${moonbitlang$core$builtin$$Show$to_string$111$(dst.length)}, self.length = ${moonbitlang$core$builtin$$Show$to_string$111$(self.length)}`, "@moonbitlang/core/builtin:fixedarray_block.mbt:115:5-117:6");
    return;
  }
}
function moonbitlang$core$array$$FixedArray$blit_to$46$inner$28$(self, dst, len, src_offset, dst_offset) {
  if (dst_offset >= 0 && (src_offset >= 0 && ((dst_offset + len | 0) <= dst.length && (src_offset + len | 0) <= self.length))) {
    moonbitlang$core$array$$FixedArray$unsafe_blit$28$(dst, dst_offset, self, src_offset, len);
    return;
  } else {
    moonbitlang$core$builtin$$abort$15$(`bounds check failed: dst_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(dst_offset)}, src_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(src_offset)}, len = ${moonbitlang$core$builtin$$Show$to_string$111$(len)}, dst.length = ${moonbitlang$core$builtin$$Show$to_string$111$(dst.length)}, self.length = ${moonbitlang$core$builtin$$Show$to_string$111$(self.length)}`, "@moonbitlang/core/builtin:fixedarray_block.mbt:115:5-117:6");
    return;
  }
}
function moonbitlang$core$array$$FixedArray$blit_to$46$inner$33$(self, dst, len, src_offset, dst_offset) {
  if (dst_offset >= 0 && (src_offset >= 0 && ((dst_offset + len | 0) <= dst.length && (src_offset + len | 0) <= self.length))) {
    moonbitlang$core$array$$FixedArray$unsafe_blit$33$(dst, dst_offset, self, src_offset, len);
    return;
  } else {
    moonbitlang$core$builtin$$abort$15$(`bounds check failed: dst_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(dst_offset)}, src_offset = ${moonbitlang$core$builtin$$Show$to_string$111$(src_offset)}, len = ${moonbitlang$core$builtin$$Show$to_string$111$(len)}, dst.length = ${moonbitlang$core$builtin$$Show$to_string$111$(dst.length)}, self.length = ${moonbitlang$core$builtin$$Show$to_string$111$(self.length)}`, "@moonbitlang/core/builtin:fixedarray_block.mbt:115:5-117:6");
    return;
  }
}
function moonbitlang$core$array$$FixedArray$copy$26$(self) {
  return moonbitlang$core$builtin$$JSArray$copy(self);
}
function moonbitlang$core$array$$FixedArray$copy$17$(self) {
  return moonbitlang$core$builtin$$JSArray$copy(self);
}
function moonbitlang$core$array$$FixedArray$copy$31$(self) {
  return moonbitlang$core$builtin$$JSArray$copy(self);
}
function moonbitlang$core$array$$FixedArray$copy$33$(self) {
  return moonbitlang$core$builtin$$JSArray$copy(self);
}
function moonbitlang$core$bytes$$Bytes$makei$230$(length, value) {
  if (length <= 0) {
    return $bytes_literal$0;
  }
  const arr = $makebytes(length, value(0));
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < length) {
      $bound_check(arr, i);
      arr[i] = value(i);
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$builtin$$println$13$(input) {
  console.log(input);
}
function moonbitlang$core$char$$Char$to_hex(char) {
  const code = char;
  return code >= 0 && code <= 255 ? moonbitlang$core$byte$$Byte$to_hex(code & 255) : code <= 65535 ? `${moonbitlang$core$byte$$Byte$to_hex(code >> 8 & 255)}${moonbitlang$core$byte$$Byte$to_hex(code & 255)}` : `${moonbitlang$core$byte$$Byte$to_hex(code >> 16 & 255)}${moonbitlang$core$byte$$Byte$to_hex(code >> 8 & 255)}${moonbitlang$core$byte$$Byte$to_hex(code & 255)}`;
}
function moonbitlang$core$char$$Char$is_control(self) {
  return self >= 0 && self <= 31 ? true : self >= 127 && self <= 159;
}
function moonbitlang$core$char$$Char$is_printable(self) {
  if (moonbitlang$core$char$$Char$is_control(self)) {
    return false;
  }
  const self$2 = self;
  _L: {
    _L$2: {
      if (self$2 >= 57344 && self$2 <= 63743) {
        break _L$2;
      } else {
        if (self$2 >= 983040 && self$2 <= 1048573) {
          break _L$2;
        } else {
          if (self$2 >= 1048576 && self$2 <= 1114109) {
            break _L$2;
          }
        }
      }
      break _L;
    }
    return false;
  }
  _L$2: {
    _L$3: {
      if (self$2 === 173) {
        break _L$3;
      } else {
        if (self$2 >= 1536 && self$2 <= 1541) {
          break _L$3;
        } else {
          if (self$2 === 1564) {
            break _L$3;
          } else {
            if (self$2 === 1757) {
              break _L$3;
            } else {
              if (self$2 === 1807) {
                break _L$3;
              } else {
                if (self$2 >= 2192 && self$2 <= 2193) {
                  break _L$3;
                } else {
                  if (self$2 === 2274) {
                    break _L$3;
                  } else {
                    if (self$2 === 6158) {
                      break _L$3;
                    } else {
                      if (self$2 >= 8203 && self$2 <= 8207) {
                        break _L$3;
                      } else {
                        if (self$2 >= 8234 && self$2 <= 8238) {
                          break _L$3;
                        } else {
                          if (self$2 >= 8288 && self$2 <= 8292) {
                            break _L$3;
                          } else {
                            if (self$2 >= 8294 && self$2 <= 8303) {
                              break _L$3;
                            } else {
                              if (self$2 === 65279) {
                                break _L$3;
                              } else {
                                if (self$2 >= 65529 && self$2 <= 65531) {
                                  break _L$3;
                                } else {
                                  if (self$2 === 69821) {
                                    break _L$3;
                                  } else {
                                    if (self$2 === 69837) {
                                      break _L$3;
                                    } else {
                                      if (self$2 >= 78896 && self$2 <= 78911) {
                                        break _L$3;
                                      } else {
                                        if (self$2 >= 113824 && self$2 <= 113827) {
                                          break _L$3;
                                        } else {
                                          if (self$2 >= 119155 && self$2 <= 119162) {
                                            break _L$3;
                                          } else {
                                            if (self$2 === 917505) {
                                              break _L$3;
                                            } else {
                                              if (self$2 >= 917536 && self$2 <= 917631) {
                                                break _L$3;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      break _L$2;
    }
    return false;
  }
  if (55296 <= self$2 && self$2 <= 57343) {
    return false;
  }
  if (self$2 === 8232 || self$2 === 8233) {
    return false;
  }
  _L$3: {
    _L$4: {
      if (self$2 >= 64976 && self$2 <= 65007) {
        break _L$4;
      } else {
        if (self$2 >= 65534 && self$2 <= 65535) {
          break _L$4;
        } else {
          if (self$2 >= 131070 && self$2 <= 131071) {
            break _L$4;
          } else {
            if (self$2 >= 196606 && self$2 <= 196607) {
              break _L$4;
            } else {
              if (self$2 >= 262142 && self$2 <= 262143) {
                break _L$4;
              } else {
                if (self$2 >= 327678 && self$2 <= 327679) {
                  break _L$4;
                } else {
                  if (self$2 >= 393214 && self$2 <= 393215) {
                    break _L$4;
                  } else {
                    if (self$2 >= 458750 && self$2 <= 458751) {
                      break _L$4;
                    } else {
                      if (self$2 >= 524286 && self$2 <= 524287) {
                        break _L$4;
                      } else {
                        if (self$2 >= 589822 && self$2 <= 589823) {
                          break _L$4;
                        } else {
                          if (self$2 >= 655358 && self$2 <= 655359) {
                            break _L$4;
                          } else {
                            if (self$2 >= 720894 && self$2 <= 720895) {
                              break _L$4;
                            } else {
                              if (self$2 >= 786430 && self$2 <= 786431) {
                                break _L$4;
                              } else {
                                if (self$2 >= 851966 && self$2 <= 851967) {
                                  break _L$4;
                                } else {
                                  if (self$2 >= 917502 && self$2 <= 917503) {
                                    break _L$4;
                                  } else {
                                    if (self$2 >= 983038 && self$2 <= 983039) {
                                      break _L$4;
                                    } else {
                                      if (self$2 >= 1048574 && self$2 <= 1048575) {
                                        break _L$4;
                                      } else {
                                        if (self$2 >= 1114110 && self$2 <= 1114111) {
                                          break _L$4;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      break _L$3;
    }
    return false;
  }
  return true;
}
function moonbitlang$core$builtin$$Show$output$59$(self, logger) {
  logger.method_table.method_3(logger.self, 39);
  _L: {
    _L$2: {
      if (self === 39) {
        break _L$2;
      } else {
        if (self === 92) {
          break _L$2;
        } else {
          if (self === 10) {
            logger.method_table.method_0(logger.self, "\\n");
          } else {
            if (self === 13) {
              logger.method_table.method_0(logger.self, "\\r");
            } else {
              if (self === 8) {
                logger.method_table.method_0(logger.self, "\\b");
              } else {
                if (self === 9) {
                  logger.method_table.method_0(logger.self, "\\t");
                } else {
                  if (self >= 32 && self <= 126) {
                    logger.method_table.method_3(logger.self, self);
                  } else {
                    if (!moonbitlang$core$char$$Char$is_printable(self)) {
                      logger.method_table.method_0(logger.self, "\\u{");
                      logger.method_table.method_0(logger.self, moonbitlang$core$char$$Char$to_hex(self));
                      logger.method_table.method_3(logger.self, 125);
                    } else {
                      logger.method_table.method_3(logger.self, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
      break _L;
    }
    logger.method_table.method_3(logger.self, 92);
    logger.method_table.method_3(logger.self, self);
  }
  logger.method_table.method_3(logger.self, 39);
}
function moonbitlang$core$bytes$$Bytes$from_array(arr) {
  return moonbitlang$core$bytes$$Bytes$makei$230$(arr.end - arr.start | 0, (i) => moonbitlang$core$array$$ArrayView$at$30$(arr, i));
}
function moonbitlang$core$array$$Array$make$76$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$17$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$34$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$32$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$28$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$27$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$37$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$39$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$44$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$set$76$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$17$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$34$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$32$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$28$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$27$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$37$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$39$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$set$44$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    $bound_check(self, index);
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$ArrayView$sub$46$inner$37$(self, start, end) {
  const len = self.end - self.start | 0;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, end: (self.start + start$2 | 0) + (end$2 - start$2 | 0) | 0 } : moonbitlang$core$builtin$$abort$38$("View index out of bounds", "@moonbitlang/core/builtin:arrayview.mbt:300:5-300:38");
}
function moonbitlang$core$array$$ArrayView$sub$46$inner$39$(self, start, end) {
  const len = self.end - self.start | 0;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, end: (self.start + start$2 | 0) + (end$2 - start$2 | 0) | 0 } : moonbitlang$core$builtin$$abort$40$("View index out of bounds", "@moonbitlang/core/builtin:arrayview.mbt:300:5-300:38");
}
function moonbitlang$core$array$$ArrayView$sub$46$inner$44$(self, start, end) {
  const len = self.end - self.start | 0;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, end: (self.start + start$2 | 0) + (end$2 - start$2 | 0) | 0 } : moonbitlang$core$builtin$$abort$45$("View index out of bounds", "@moonbitlang/core/builtin:arrayview.mbt:300:5-300:38");
}
function moonbitlang$core$array$$ArrayView$sub$46$inner$21$(self, start, end) {
  const len = self.end - self.start | 0;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, end: (self.start + start$2 | 0) + (end$2 - start$2 | 0) | 0 } : moonbitlang$core$builtin$$abort$18$("View index out of bounds", "@moonbitlang/core/builtin:arrayview.mbt:300:5-300:38");
}
function moonbitlang$core$builtin$$Show$output$231$(self, logger) {
  const pkg = self.pkg;
  const _data = pkg.str;
  const _start = pkg.start;
  const _end = _start + (pkg.end - pkg.start | 0) | 0;
  let _cursor = _start;
  let accept_state = -1;
  let match_end = -1;
  let match_tag_saver_0 = -1;
  let tag_0 = -1;
  let _bind;
  _L: {
    _L$2: {
      _L$3: while (true) {
        if (_cursor < _end) {
          _L$4: {
            _L$5: {
              const _p = _cursor;
              const next_char = _data.charCodeAt(_p);
              _cursor = _cursor + 1 | 0;
              if (next_char < 55296) {
                if (next_char < 47) {
                  break _L$5;
                } else {
                  if (next_char > 47) {
                    break _L$5;
                  } else {
                    _L$6: while (true) {
                      tag_0 = _cursor;
                      if (_cursor < _end) {
                        _L$7: {
                          const _p$2 = _cursor;
                          const next_char$2 = _data.charCodeAt(_p$2);
                          _cursor = _cursor + 1 | 0;
                          if (next_char$2 < 55296) {
                            if (next_char$2 < 47) {
                              break _L$7;
                            } else {
                              if (next_char$2 > 47) {
                                break _L$7;
                              } else {
                                while (true) {
                                  if (_cursor < _end) {
                                    _L$8: {
                                      const _p$3 = _cursor;
                                      const next_char$3 = _data.charCodeAt(_p$3);
                                      _cursor = _cursor + 1 | 0;
                                      if (next_char$3 < 56319) {
                                        if (next_char$3 < 55296) {
                                          break _L$8;
                                        } else {
                                          if (_cursor < _end) {
                                            const _p$4 = _cursor;
                                            const next_char$4 = _data.charCodeAt(_p$4);
                                            _cursor = _cursor + 1 | 0;
                                            if (next_char$4 < 56320) {
                                              break _L$2;
                                            } else {
                                              if (next_char$4 > 65535) {
                                                break _L$2;
                                              } else {
                                                continue;
                                              }
                                            }
                                          } else {
                                            break _L$2;
                                          }
                                        }
                                      } else {
                                        if (next_char$3 > 56319) {
                                          if (next_char$3 < 65536) {
                                            break _L$8;
                                          } else {
                                            break _L$2;
                                          }
                                        } else {
                                          if (_cursor < _end) {
                                            const _p$4 = _cursor;
                                            const next_char$4 = _data.charCodeAt(_p$4);
                                            _cursor = _cursor + 1 | 0;
                                            if (next_char$4 < 56320) {
                                              break _L$2;
                                            } else {
                                              if (next_char$4 > 57343) {
                                                break _L$2;
                                              } else {
                                                continue;
                                              }
                                            }
                                          } else {
                                            break _L$2;
                                          }
                                        }
                                      }
                                    }
                                    continue;
                                  } else {
                                    match_tag_saver_0 = tag_0;
                                    accept_state = 0;
                                    match_end = _cursor;
                                    break _L$2;
                                  }
                                }
                              }
                            }
                          } else {
                            if (next_char$2 > 56318) {
                              if (next_char$2 < 57344) {
                                if (_cursor < _end) {
                                  const _p$3 = _cursor;
                                  const next_char$3 = _data.charCodeAt(_p$3);
                                  _cursor = _cursor + 1 | 0;
                                  if (next_char$3 < 56320) {
                                    break _L$2;
                                  } else {
                                    if (next_char$3 > 57343) {
                                      break _L$2;
                                    } else {
                                      continue;
                                    }
                                  }
                                } else {
                                  break _L$2;
                                }
                              } else {
                                if (next_char$2 > 65535) {
                                  break _L$2;
                                } else {
                                  break _L$7;
                                }
                              }
                            } else {
                              if (_cursor < _end) {
                                const _p$3 = _cursor;
                                const next_char$3 = _data.charCodeAt(_p$3);
                                _cursor = _cursor + 1 | 0;
                                if (next_char$3 < 56320) {
                                  break _L$2;
                                } else {
                                  if (next_char$3 > 65535) {
                                    break _L$2;
                                  } else {
                                    continue;
                                  }
                                }
                              } else {
                                break _L$2;
                              }
                            }
                          }
                        }
                        continue;
                      } else {
                        break _L$2;
                      }
                    }
                  }
                }
              } else {
                if (next_char > 56318) {
                  if (next_char < 57344) {
                    if (_cursor < _end) {
                      const _p$2 = _cursor;
                      const next_char$2 = _data.charCodeAt(_p$2);
                      _cursor = _cursor + 1 | 0;
                      if (next_char$2 < 56320) {
                        break _L$2;
                      } else {
                        if (next_char$2 > 57343) {
                          break _L$2;
                        } else {
                          continue;
                        }
                      }
                    } else {
                      break _L$2;
                    }
                  } else {
                    if (next_char > 65535) {
                      break _L$2;
                    } else {
                      break _L$5;
                    }
                  }
                } else {
                  if (_cursor < _end) {
                    const _p$2 = _cursor;
                    const next_char$2 = _data.charCodeAt(_p$2);
                    _cursor = _cursor + 1 | 0;
                    if (next_char$2 < 56320) {
                      break _L$2;
                    } else {
                      if (next_char$2 > 65535) {
                        break _L$2;
                      } else {
                        continue;
                      }
                    }
                  } else {
                    break _L$2;
                  }
                }
              }
              break _L$4;
            }
            continue;
          }
        } else {
          break _L$2;
        }
      }
      break _L;
    }
    if (accept_state === 0) {
      let package_name;
      let _try_err;
      _L$3: {
        _L$4: {
          const _bind$2 = moonbitlang$core$string$$String$sub(_data, match_tag_saver_0 + 1 | 0, match_end);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            package_name = _ok._0;
          } else {
            const _err = _bind$2;
            const _tmp = _err._0;
            _try_err = _tmp;
            break _L$4;
          }
          break _L$3;
        }
        package_name = $panic();
      }
      let module_name;
      let _try_err$2;
      _L$4: {
        _L$5: {
          const _bind$2 = moonbitlang$core$string$$String$sub(_data, _start, match_tag_saver_0);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            module_name = _ok._0;
          } else {
            const _err = _bind$2;
            const _tmp = _err._0;
            _try_err$2 = _tmp;
            break _L$5;
          }
          break _L$4;
        }
        module_name = $panic();
      }
      _bind = { _0: module_name, _1: package_name };
    } else {
      _bind = { _0: pkg, _1: undefined };
    }
  }
  const _module_name = _bind._0;
  const _package_name = _bind._1;
  if (_package_name === undefined) {
  } else {
    const _Some = _package_name;
    const _pkg_name = _Some;
    logger.method_table.method_2(logger.self, _pkg_name);
    logger.method_table.method_3(logger.self, 47);
  }
  logger.method_table.method_2(logger.self, self.filename);
  logger.method_table.method_3(logger.self, 58);
  logger.method_table.method_2(logger.self, self.start_line);
  logger.method_table.method_3(logger.self, 58);
  logger.method_table.method_2(logger.self, self.start_column);
  logger.method_table.method_3(logger.self, 45);
  logger.method_table.method_2(logger.self, self.end_line);
  logger.method_table.method_3(logger.self, 58);
  logger.method_table.method_2(logger.self, self.end_column);
  logger.method_table.method_3(logger.self, 64);
  logger.method_table.method_2(logger.self, _module_name);
}
function moonbitlang$core$builtin$$Show$output$117$(self, logger) {
  moonbitlang$core$builtin$$Show$output$231$(moonbitlang$core$builtin$$SourceLocRepr$parse(self), logger);
}
function moonbitlang$core$array$$Array$sub$46$inner$21$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, end: end$2 } : moonbitlang$core$builtin$$abort$18$("View index out of bounds", "@moonbitlang/core/builtin:arrayview.mbt:251:5-251:38");
}
function moonbitlang$core$array$$Array$sub$46$inner$54$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, end: end$2 } : moonbitlang$core$builtin$$abort$22$("View index out of bounds", "@moonbitlang/core/builtin:arrayview.mbt:251:5-251:38");
}
function moonbitlang$core$array$$Array$sub$46$inner$17$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _end = _Some;
    end$2 = _end < 0 ? len + _end | 0 : _end;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, end: end$2 } : moonbitlang$core$builtin$$abort$25$("View index out of bounds", "@moonbitlang/core/builtin:arrayview.mbt:251:5-251:38");
}
function moonbitlang$core$array$$ArrayView$rev_iter$54$(self) {
  const i = { val: self.end - self.start | 0 };
  const _p = () => {
    if (i.val > 0) {
      i.val = i.val - 1 | 0;
      return self.buf[self.start + i.val | 0];
    } else {
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$array$$ArrayView$join$13$(self, separator) {
  if ((self.end - self.start | 0) === 0) {
    return "";
  } else {
    const _hd = self.buf[self.start];
    const _bind = self.buf;
    const _bind$2 = 1 + self.start | 0;
    const _bind$3 = self.end;
    const _x = { buf: _bind, start: _bind$2, end: _bind$3 };
    const hd = moonbitlang$core$builtin$$ToStringView$to_string_view$13$(_hd);
    let size_hint = hd.end - hd.start | 0;
    const _len = _x.end - _x.start | 0;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const s = _bind[_bind$2 + _i | 0];
        const _tmp$2 = size_hint;
        const _p = moonbitlang$core$builtin$$ToStringView$to_string_view$13$(s);
        size_hint = _tmp$2 + ((_p.end - _p.start | 0) + (separator.end - separator.start | 0) | 0) | 0;
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    size_hint = size_hint << 1;
    const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(size_hint);
    moonbitlang$core$builtin$$Logger$write_view$3$(buf, hd);
    if (moonbitlang$core$string$$String$char_length_eq$46$inner(separator.str, 0, separator.start, separator.end)) {
      const _len$2 = _x.end - _x.start | 0;
      let _tmp$2 = 0;
      while (true) {
        const _i = _tmp$2;
        if (_i < _len$2) {
          const s = _bind[_bind$2 + _i | 0];
          const s$2 = moonbitlang$core$builtin$$ToStringView$to_string_view$13$(s);
          moonbitlang$core$builtin$$Logger$write_view$3$(buf, s$2);
          _tmp$2 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    } else {
      const _len$2 = _x.end - _x.start | 0;
      let _tmp$2 = 0;
      while (true) {
        const _i = _tmp$2;
        if (_i < _len$2) {
          const s = _bind[_bind$2 + _i | 0];
          const s$2 = moonbitlang$core$builtin$$ToStringView$to_string_view$13$(s);
          moonbitlang$core$builtin$$Logger$write_view$3$(buf, separator);
          moonbitlang$core$builtin$$Logger$write_view$3$(buf, s$2);
          _tmp$2 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
    return buf.val;
  }
}
function moonbitlang$core$array$$Array$unsafe_pop$23$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$134$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$21$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$137$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$145$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$146$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$147$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$148$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$149$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$150$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$151$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$152$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$153$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$pop$137$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$137$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$145$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$145$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$146$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$146$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$147$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$147$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$148$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$148$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$149$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$149$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$150$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$150$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$151$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$151$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$152$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$152$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$pop$153$(self) {
  if (self.length === 0) {
    return undefined;
  } else {
    const v = moonbitlang$core$array$$Array$unsafe_pop$153$(self);
    return v;
  }
}
function moonbitlang$core$array$$Array$remove$23$(self, index) {
  if (index >= 0 && index < self.length) {
    $bound_check(self, index);
    const value = self[index];
    moonbitlang$core$builtin$$JSArray$splice(self, index, 1);
    return value;
  } else {
    return moonbitlang$core$builtin$$abort$23$(`index out of bounds: the len is from 0 to ${moonbitlang$core$builtin$$Show$to_string$111$(self.length)} but the index is ${moonbitlang$core$builtin$$Show$to_string$111$(index)}`, "@moonbitlang/core/builtin:arraycore_js.mbt:251:5-253:6");
  }
}
function moonbitlang$core$array$$Array$copy$17$(self) {
  return moonbitlang$core$builtin$$JSArray$copy(self);
}
function moonbitlang$core$array$$MutArrayView$swap$34$(arr, i, j) {
  const temp = moonbitlang$core$array$$MutArrayView$at$34$(arr, i);
  moonbitlang$core$array$$MutArrayView$set$34$(arr, i, moonbitlang$core$array$$MutArrayView$at$34$(arr, j));
  moonbitlang$core$array$$MutArrayView$set$34$(arr, j, temp);
}
function moonbitlang$core$array$$MutArrayView$swap$41$(arr, i, j) {
  const temp = moonbitlang$core$array$$MutArrayView$at$41$(arr, i);
  moonbitlang$core$array$$MutArrayView$set$41$(arr, i, moonbitlang$core$array$$MutArrayView$at$41$(arr, j));
  moonbitlang$core$array$$MutArrayView$set$41$(arr, j, temp);
}
function moonbitlang$core$array$$MutArrayView$slice$34$(arr, start, end) {
  return moonbitlang$core$array$$MutArrayView$mut_view$46$inner$34$(arr, start, end);
}
function moonbitlang$core$array$$MutArrayView$slice$41$(arr, start, end) {
  return moonbitlang$core$array$$MutArrayView$mut_view$46$inner$41$(arr, start, end);
}
function moonbitlang$core$array$$MutArrayView$rev_in_place$34$(arr) {
  const len = arr.end - arr.start | 0;
  const mid_len = len / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (len - i | 0) - 1 | 0;
      const temp = moonbitlang$core$array$$MutArrayView$at$34$(arr, i);
      moonbitlang$core$array$$MutArrayView$set$34$(arr, i, moonbitlang$core$array$$MutArrayView$at$34$(arr, j));
      moonbitlang$core$array$$MutArrayView$set$34$(arr, j, temp);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$MutArrayView$rev_in_place$41$(arr) {
  const len = arr.end - arr.start | 0;
  const mid_len = len / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (len - i | 0) - 1 | 0;
      const temp = moonbitlang$core$array$$MutArrayView$at$41$(arr, i);
      moonbitlang$core$array$$MutArrayView$set$41$(arr, i, moonbitlang$core$array$$MutArrayView$at$41$(arr, j));
      moonbitlang$core$array$$MutArrayView$set$41$(arr, j, temp);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_get_limit(len) {
  let len$2 = len;
  let limit = 0;
  while (true) {
    if (len$2 > 0) {
      len$2 = len$2 / 2 | 0;
      limit = limit + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return limit;
}
function moonbitlang$core$builtin$$fixed_bubble_sort_by$34$(arr, cmp) {
  const _end538 = arr.end - arr.start | 0;
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end538) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$MutArrayView$at$34$(arr, j - 1 | 0), moonbitlang$core$array$$MutArrayView$at$34$(arr, j)) > 0) {
          moonbitlang$core$array$$MutArrayView$swap$34$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_bubble_sort_by$41$(arr, cmp) {
  const _end538 = arr.end - arr.start | 0;
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end538) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$MutArrayView$at$41$(arr, j - 1 | 0), moonbitlang$core$array$$MutArrayView$at$41$(arr, j)) > 0) {
          moonbitlang$core$array$$MutArrayView$swap$41$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$3209(_env, a, b) {
  const arr = _env._2;
  const swaps = _env._1;
  const cmp = _env._0;
  if (cmp(moonbitlang$core$array$$MutArrayView$at$34$(arr, a), moonbitlang$core$array$$MutArrayView$at$34$(arr, b)) > 0) {
    moonbitlang$core$array$$MutArrayView$swap$34$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3210(_env, a, b, c) {
  moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$3209(_env, a, b);
  moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$3209(_env, b, c);
  moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$3209(_env, a, b);
}
function moonbitlang$core$builtin$$fixed_choose_pivot_by$34$(arr, cmp) {
  const len = arr.end - arr.start | 0;
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: cmp, _1: swaps, _2: arr };
    if (len > 50) {
      moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3210(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3210(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3210(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3210(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$MutArrayView$rev_in_place$34$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$3229(_env, a, b) {
  const arr = _env._2;
  const swaps = _env._1;
  const cmp = _env._0;
  if (cmp(moonbitlang$core$array$$MutArrayView$at$41$(arr, a), moonbitlang$core$array$$MutArrayView$at$41$(arr, b)) > 0) {
    moonbitlang$core$array$$MutArrayView$swap$41$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3230(_env, a, b, c) {
  moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$3229(_env, a, b);
  moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$3229(_env, b, c);
  moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_2$47$3229(_env, a, b);
}
function moonbitlang$core$builtin$$fixed_choose_pivot_by$41$(arr, cmp) {
  const len = arr.end - arr.start | 0;
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: cmp, _1: swaps, _2: arr };
    if (len > 50) {
      moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3230(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3230(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3230(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$builtin$$fixed_choose_pivot_by$46$sort_3$47$3230(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$MutArrayView$rev_in_place$41$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$builtin$$fixed_sift_down_by$34$(arr, index, cmp) {
  let index$2 = index;
  const len = arr.end - arr.start | 0;
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$MutArrayView$at$34$(arr, child), moonbitlang$core$array$$MutArrayView$at$34$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$MutArrayView$at$34$(arr, index$2), moonbitlang$core$array$$MutArrayView$at$34$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$MutArrayView$swap$34$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_sift_down_by$41$(arr, index, cmp) {
  let index$2 = index;
  const len = arr.end - arr.start | 0;
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$MutArrayView$at$41$(arr, child), moonbitlang$core$array$$MutArrayView$at$41$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$MutArrayView$at$41$(arr, index$2), moonbitlang$core$array$$MutArrayView$at$41$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$MutArrayView$swap$41$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_heap_sort_by$34$(arr, cmp) {
  const len = arr.end - arr.start | 0;
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$builtin$$fixed_sift_down_by$34$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$MutArrayView$swap$34$(arr, 0, i);
      moonbitlang$core$builtin$$fixed_sift_down_by$34$(moonbitlang$core$array$$MutArrayView$slice$34$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_heap_sort_by$41$(arr, cmp) {
  const len = arr.end - arr.start | 0;
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$builtin$$fixed_sift_down_by$41$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$MutArrayView$swap$41$(arr, 0, i);
      moonbitlang$core$builtin$$fixed_sift_down_by$41$(moonbitlang$core$array$$MutArrayView$slice$41$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$fixed_partition_by$34$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$MutArrayView$swap$34$(arr, pivot_index, (arr.end - arr.start | 0) - 1 | 0);
  const pivot = moonbitlang$core$array$$MutArrayView$at$34$(arr, (arr.end - arr.start | 0) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end527 = (arr.end - arr.start | 0) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end527) {
      if (cmp(moonbitlang$core$array$$MutArrayView$at$34$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$MutArrayView$swap$34$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$MutArrayView$swap$34$(arr, i, (arr.end - arr.start | 0) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$builtin$$fixed_partition_by$41$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$MutArrayView$swap$41$(arr, pivot_index, (arr.end - arr.start | 0) - 1 | 0);
  const pivot = moonbitlang$core$array$$MutArrayView$at$41$(arr, (arr.end - arr.start | 0) - 1 | 0);
  let i = 0;
  let partitioned = true;
  const _end527 = (arr.end - arr.start | 0) - 1 | 0;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < _end527) {
      if (cmp(moonbitlang$core$array$$MutArrayView$at$41$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$MutArrayView$swap$41$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$MutArrayView$swap$41$(arr, i, (arr.end - arr.start | 0) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$builtin$$fixed_try_bubble_sort_by$34$(arr, cmp) {
  let tries = 0;
  const _end548 = arr.end - arr.start | 0;
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end548) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$MutArrayView$at$34$(arr, j - 1 | 0), moonbitlang$core$array$$MutArrayView$at$34$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$MutArrayView$swap$34$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$builtin$$fixed_try_bubble_sort_by$41$(arr, cmp) {
  let tries = 0;
  const _end548 = arr.end - arr.start | 0;
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < _end548) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$MutArrayView$at$41$(arr, j - 1 | 0), moonbitlang$core$array$$MutArrayView$at$41$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$MutArrayView$swap$41$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$builtin$$fixed_quick_sort_by$34$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const _p = arr$2;
    const len = _p.end - _p.start | 0;
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$builtin$$fixed_bubble_sort_by$34$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$builtin$$fixed_heap_sort_by$34$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$builtin$$fixed_choose_pivot_by$34$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$builtin$$fixed_try_bubble_sort_by$34$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$builtin$$fixed_partition_by$34$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    const _p$2 = len - _pivot | 0;
    balanced = (_pivot > _p$2 ? _p$2 : _pivot) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$MutArrayView$at$34$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$MutArrayView$at$34$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$MutArrayView$slice$34$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$MutArrayView$slice$34$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$MutArrayView$slice$34$(arr$2, _pivot + 1 | 0, len);
    if ((left.end - left.start | 0) < (right.end - right.start | 0)) {
      moonbitlang$core$builtin$$fixed_quick_sort_by$34$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$MutArrayView$at$34$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$builtin$$fixed_quick_sort_by$34$(right, cmp, moonbitlang$core$array$$MutArrayView$at$34$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$builtin$$fixed_quick_sort_by$41$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const _p = arr$2;
    const len = _p.end - _p.start | 0;
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$builtin$$fixed_bubble_sort_by$41$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$builtin$$fixed_heap_sort_by$41$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$builtin$$fixed_choose_pivot_by$41$(arr$2, cmp);
    const _pivot_index = _bind._0;
    const _likely_sorted = _bind._1;
    if (was_partitioned && (balanced && _likely_sorted)) {
      if (moonbitlang$core$builtin$$fixed_try_bubble_sort_by$41$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$builtin$$fixed_partition_by$41$(arr$2, cmp, _pivot_index);
    const _pivot = _bind$2._0;
    const _partitioned = _bind$2._1;
    was_partitioned = _partitioned;
    const _p$2 = len - _pivot | 0;
    balanced = (_pivot > _p$2 ? _p$2 : _pivot) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _pred = _Some;
      if (cmp(_pred, moonbitlang$core$array$$MutArrayView$at$41$(arr$2, _pivot)) === 0) {
        let i = _pivot;
        while (true) {
          if (i < len && cmp(_pred, moonbitlang$core$array$$MutArrayView$at$41$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$MutArrayView$slice$41$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$MutArrayView$slice$41$(arr$2, 0, _pivot);
    const right = moonbitlang$core$array$$MutArrayView$slice$41$(arr$2, _pivot + 1 | 0, len);
    if ((left.end - left.start | 0) < (right.end - right.start | 0)) {
      moonbitlang$core$builtin$$fixed_quick_sort_by$41$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$MutArrayView$at$41$(arr$2, _pivot);
      arr$2 = right;
    } else {
      moonbitlang$core$builtin$$fixed_quick_sort_by$41$(right, cmp, moonbitlang$core$array$$MutArrayView$at$41$(arr$2, _pivot), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$MutArrayView$sort_by_key$232$(self, map) {
  moonbitlang$core$builtin$$fixed_quick_sort_by$34$(self, (a, b) => $compare_int(map(a), map(b)), undefined, moonbitlang$core$builtin$$fixed_get_limit(self.end - self.start | 0));
}
function moonbitlang$core$array$$MutArrayView$sort_by_key$233$(self, map) {
  moonbitlang$core$builtin$$fixed_quick_sort_by$41$(self, (a, b) => {
    const _p = map(a);
    const _p$2 = map(b);
    return $compare_int(_p, _p$2);
  }, undefined, moonbitlang$core$builtin$$fixed_get_limit(self.end - self.start | 0));
}
function moonbitlang$core$array$$Array$sort_by_key$232$(self, map) {
  moonbitlang$core$array$$MutArrayView$sort_by_key$232$(moonbitlang$core$array$$Array$mut_view$46$inner$34$(self, 0, undefined), map);
}
function moonbitlang$core$array$$Array$sort_by_key$233$(self, map) {
  moonbitlang$core$array$$MutArrayView$sort_by_key$233$(moonbitlang$core$array$$Array$mut_view$46$inner$41$(self, 0, undefined), map);
}
function moonbitlang$core$array$$Array$get$54$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : undefined;
}
function moonbitlang$core$builtin$$Eq$equal$234$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < self_len) {
        const _p = self[i];
        const _p$2 = other[i];
        if (_p === _p$2) {
        } else {
          return false;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$235$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < self_len) {
        if (self[i] === other[i]) {
        } else {
          return false;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Eq$equal$236$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$equal$75$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Compare$compare$236$(self, other) {
  const len_self = self.length;
  const len_other = other.length;
  const cmp = $compare_int(len_self, len_other);
  if (cmp === 0) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len_self) {
        const cmp$2 = moonbitlang$core$builtin$$Compare$compare$75$(self[i], other[i]);
        if (cmp$2 === 0) {
        } else {
          return cmp$2;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return 0;
      }
    }
  } else {
    return cmp;
  }
}
function moonbitlang$core$array$$Array$contains$34$(self, value) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      if (v.num === value.num) {
        return true;
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$array$$Array$contains$13$(self, value) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      if (v === value) {
        return true;
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$array$$Array$search$34$(self, value) {
  return moonbitlang$core$array$$ArrayView$search$34$({ buf: self, start: 0, end: self.length }, value);
}
function moonbitlang$core$array$$Array$rev_iter$54$(self) {
  return moonbitlang$core$array$$ArrayView$rev_iter$54$({ buf: self, start: 0, end: self.length });
}
function moonbitlang$core$array$$Array$push_iter$13$(self, iter) {
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$13$(iter);
    if (_bind === undefined) {
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      moonbitlang$core$array$$Array$push$13$(self, _x);
      continue;
    }
  }
}
function moonbitlang$core$array$$Array$push_iter$73$(self, iter) {
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$73$(iter);
    if (_bind === undefined) {
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      moonbitlang$core$array$$Array$push$73$(self, _x);
      continue;
    }
  }
}
function moonbitlang$core$array$$Array$push_iter$74$(self, iter) {
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$74$(iter);
    if (_bind === undefined) {
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      moonbitlang$core$array$$Array$push$74$(self, _x);
      continue;
    }
  }
}
function moonbitlang$core$array$$Array$join$13$(self, separator) {
  return moonbitlang$core$array$$ArrayView$join$13$({ buf: self, start: 0, end: self.length }, separator);
}
function moonbitlang$core$double$$Double$to_string(self) {
  return moonbitlang$core$double$internal$ryu$$ryu_to_string(self);
}
function moonbitlang$core$builtin$$Show$output$78$(self, logger) {
  logger.method_table.method_0(logger.self, moonbitlang$core$double$$Double$to_string(self));
}
function moonbitlang$core$strconv$$base_err$237$() {
  return new Result$Err$2$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$base_err_str));
}
function moonbitlang$core$strconv$$check_and_consume_base(view, base) {
  if (base === 0) {
    _L: {
      let rest;
      _L$2: {
        let rest$2;
        _L$3: {
          let rest$3;
          _L$4: {
            if (moonbitlang$core$string$$String$char_length_ge$46$inner(view.str, 2, view.start, view.end)) {
              const _x = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 0, view.start, view.end));
              if (_x === 48) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 1, view.start, view.end));
                switch (_x$2) {
                  case 120: {
                    const _tmp = view.str;
                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$2;
                    if (_bind === undefined) {
                      _tmp$2 = view.end;
                    } else {
                      const _Some = _bind;
                      _tmp$2 = _Some;
                    }
                    const _tmp$3 = _tmp$2;
                    const _x$3 = { str: _tmp, start: _tmp$3, end: view.end };
                    rest$3 = _x$3;
                    break _L$4;
                  }
                  case 88: {
                    const _tmp$4 = view.str;
                    const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$5;
                    if (_bind$2 === undefined) {
                      _tmp$5 = view.end;
                    } else {
                      const _Some = _bind$2;
                      _tmp$5 = _Some;
                    }
                    const _tmp$6 = _tmp$5;
                    const _x$4 = { str: _tmp$4, start: _tmp$6, end: view.end };
                    rest$3 = _x$4;
                    break _L$4;
                  }
                  case 111: {
                    const _tmp$7 = view.str;
                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$8;
                    if (_bind$3 === undefined) {
                      _tmp$8 = view.end;
                    } else {
                      const _Some = _bind$3;
                      _tmp$8 = _Some;
                    }
                    const _tmp$9 = _tmp$8;
                    const _x$5 = { str: _tmp$7, start: _tmp$9, end: view.end };
                    rest$2 = _x$5;
                    break _L$3;
                  }
                  case 79: {
                    const _tmp$10 = view.str;
                    const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$11;
                    if (_bind$4 === undefined) {
                      _tmp$11 = view.end;
                    } else {
                      const _Some = _bind$4;
                      _tmp$11 = _Some;
                    }
                    const _tmp$12 = _tmp$11;
                    const _x$6 = { str: _tmp$10, start: _tmp$12, end: view.end };
                    rest$2 = _x$6;
                    break _L$3;
                  }
                  case 98: {
                    const _tmp$13 = view.str;
                    const _bind$5 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$14;
                    if (_bind$5 === undefined) {
                      _tmp$14 = view.end;
                    } else {
                      const _Some = _bind$5;
                      _tmp$14 = _Some;
                    }
                    const _tmp$15 = _tmp$14;
                    const _x$7 = { str: _tmp$13, start: _tmp$15, end: view.end };
                    rest = _x$7;
                    break _L$2;
                  }
                  case 66: {
                    const _tmp$16 = view.str;
                    const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$17;
                    if (_bind$6 === undefined) {
                      _tmp$17 = view.end;
                    } else {
                      const _Some = _bind$6;
                      _tmp$17 = _Some;
                    }
                    const _tmp$18 = _tmp$17;
                    const _x$8 = { str: _tmp$16, start: _tmp$18, end: view.end };
                    rest = _x$8;
                    break _L$2;
                  }
                  default: {
                    break _L;
                  }
                }
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return new Result$Ok$2$({ _0: 16, _1: rest$3, _2: true });
        }
        return new Result$Ok$2$({ _0: 8, _1: rest$2, _2: true });
      }
      return new Result$Ok$2$({ _0: 2, _1: rest, _2: true });
    }
    return new Result$Ok$2$({ _0: 10, _1: view, _2: false });
  } else {
    _L: {
      let rest;
      _L$2: {
        let rest$2;
        _L$3: {
          let rest$3;
          _L$4: {
            if (moonbitlang$core$string$$String$char_length_ge$46$inner(view.str, 2, view.start, view.end)) {
              const _x = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 0, view.start, view.end));
              if (_x === 48) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(view.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 1, view.start, view.end));
                switch (_x$2) {
                  case 120: {
                    const _tmp = view.str;
                    const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$2;
                    if (_bind === undefined) {
                      _tmp$2 = view.end;
                    } else {
                      const _Some = _bind;
                      _tmp$2 = _Some;
                    }
                    const _tmp$3 = _tmp$2;
                    const _x$3 = { str: _tmp, start: _tmp$3, end: view.end };
                    if (base === 16) {
                      rest$3 = _x$3;
                      break _L$4;
                    } else {
                      break _L;
                    }
                  }
                  case 88: {
                    const _tmp$4 = view.str;
                    const _bind$2 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$5;
                    if (_bind$2 === undefined) {
                      _tmp$5 = view.end;
                    } else {
                      const _Some = _bind$2;
                      _tmp$5 = _Some;
                    }
                    const _tmp$6 = _tmp$5;
                    const _x$4 = { str: _tmp$4, start: _tmp$6, end: view.end };
                    if (base === 16) {
                      rest$3 = _x$4;
                      break _L$4;
                    } else {
                      break _L;
                    }
                  }
                  case 111: {
                    const _tmp$7 = view.str;
                    const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$8;
                    if (_bind$3 === undefined) {
                      _tmp$8 = view.end;
                    } else {
                      const _Some = _bind$3;
                      _tmp$8 = _Some;
                    }
                    const _tmp$9 = _tmp$8;
                    const _x$5 = { str: _tmp$7, start: _tmp$9, end: view.end };
                    if (base === 8) {
                      rest$2 = _x$5;
                      break _L$3;
                    } else {
                      break _L;
                    }
                  }
                  case 79: {
                    const _tmp$10 = view.str;
                    const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$11;
                    if (_bind$4 === undefined) {
                      _tmp$11 = view.end;
                    } else {
                      const _Some = _bind$4;
                      _tmp$11 = _Some;
                    }
                    const _tmp$12 = _tmp$11;
                    const _x$6 = { str: _tmp$10, start: _tmp$12, end: view.end };
                    if (base === 8) {
                      rest$2 = _x$6;
                      break _L$3;
                    } else {
                      break _L;
                    }
                  }
                  case 98: {
                    const _tmp$13 = view.str;
                    const _bind$5 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$14;
                    if (_bind$5 === undefined) {
                      _tmp$14 = view.end;
                    } else {
                      const _Some = _bind$5;
                      _tmp$14 = _Some;
                    }
                    const _tmp$15 = _tmp$14;
                    const _x$7 = { str: _tmp$13, start: _tmp$15, end: view.end };
                    if (base === 2) {
                      rest = _x$7;
                      break _L$2;
                    } else {
                      break _L;
                    }
                  }
                  case 66: {
                    const _tmp$16 = view.str;
                    const _bind$6 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(view.str, 2, view.start, view.end);
                    let _tmp$17;
                    if (_bind$6 === undefined) {
                      _tmp$17 = view.end;
                    } else {
                      const _Some = _bind$6;
                      _tmp$17 = _Some;
                    }
                    const _tmp$18 = _tmp$17;
                    const _x$8 = { str: _tmp$16, start: _tmp$18, end: view.end };
                    if (base === 2) {
                      rest = _x$8;
                      break _L$2;
                    } else {
                      break _L;
                    }
                  }
                  default: {
                    break _L;
                  }
                }
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return new Result$Ok$2$({ _0: 16, _1: rest$3, _2: true });
        }
        return new Result$Ok$2$({ _0: 8, _1: rest$2, _2: true });
      }
      return new Result$Ok$2$({ _0: 2, _1: rest, _2: true });
    }
    return base >= 2 && base <= 36 ? new Result$Ok$2$({ _0: base, _1: view, _2: false }) : moonbitlang$core$strconv$$base_err$237$();
  }
}
function moonbitlang$core$strconv$$range_err$15$() {
  return new Result$Err$3$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$range_err_str));
}
function moonbitlang$core$strconv$$range_err$107$() {
  return new Result$Err$4$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$range_err_str));
}
function moonbitlang$core$strconv$$syntax_err$17$() {
  return new Result$Err$5$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$syntax_err$107$() {
  return new Result$Err$4$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$overflow_threshold(base, neg) {
  return !neg ? (base === 10 ? moonbitlang$core$builtin$$Add$add$107$(moonbitlang$core$builtin$$Div$div$107$($9223372036854775807L, $10L), $1L) : base === 16 ? moonbitlang$core$builtin$$Add$add$107$(moonbitlang$core$builtin$$Div$div$107$($9223372036854775807L, $16L), $1L) : moonbitlang$core$builtin$$Add$add$107$(moonbitlang$core$builtin$$Div$div$107$($9223372036854775807L, moonbitlang$core$int$$Int$to_int64(base)), $1L)) : base === 10 ? moonbitlang$core$builtin$$Div$div$107$($_9223372036854775808L, $10L) : base === 16 ? moonbitlang$core$builtin$$Div$div$107$($_9223372036854775808L, $16L) : moonbitlang$core$builtin$$Div$div$107$($_9223372036854775808L, moonbitlang$core$int$$Int$to_int64(base));
}
function moonbitlang$core$strconv$$parse_int64$46$inner(str, base) {
  if (moonbitlang$core$builtin$$Eq$not_equal$101$(str, { str: moonbitlang$core$strconv$$parse_int64$46$inner$46$42$bind$124$600, start: 0, end: moonbitlang$core$strconv$$parse_int64$46$inner$46$42$bind$124$600.length })) {
    let _bind;
    let rest;
    _L: {
      _L$2: {
        const _bind$2 = moonbitlang$core$string$$StringView$view$46$inner(str, 0, undefined);
        if (moonbitlang$core$string$$String$char_length_ge$46$inner(_bind$2.str, 1, _bind$2.start, _bind$2.end)) {
          const _x = moonbitlang$core$string$$String$unsafe_char_at(_bind$2.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$2.str, 0, _bind$2.start, _bind$2.end));
          switch (_x) {
            case 43: {
              const _tmp = _bind$2.str;
              const _bind$3 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$2.str, 1, _bind$2.start, _bind$2.end);
              let _tmp$2;
              if (_bind$3 === undefined) {
                _tmp$2 = _bind$2.end;
              } else {
                const _Some = _bind$3;
                _tmp$2 = _Some;
              }
              const _tmp$3 = _tmp$2;
              const _x$2 = { str: _tmp, start: _tmp$3, end: _bind$2.end };
              _bind = { _0: false, _1: _x$2 };
              break;
            }
            case 45: {
              const _tmp$4 = _bind$2.str;
              const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_bind$2.str, 1, _bind$2.start, _bind$2.end);
              let _tmp$5;
              if (_bind$4 === undefined) {
                _tmp$5 = _bind$2.end;
              } else {
                const _Some = _bind$4;
                _tmp$5 = _Some;
              }
              const _tmp$6 = _tmp$5;
              const _x$3 = { str: _tmp$4, start: _tmp$6, end: _bind$2.end };
              _bind = { _0: true, _1: _x$3 };
              break;
            }
            default: {
              rest = _bind$2;
              break _L$2;
            }
          }
        } else {
          rest = _bind$2;
          break _L$2;
        }
        break _L;
      }
      _bind = { _0: false, _1: rest };
    }
    const _neg = _bind._0;
    const _rest = _bind._1;
    const _bind$2 = moonbitlang$core$strconv$$check_and_consume_base(_rest, base);
    let _bind$3;
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _bind$3 = _ok._0;
    } else {
      return _bind$2;
    }
    const _num_base = _bind$3._0;
    const _rest$2 = _bind$3._1;
    const _allow_underscore = _bind$3._2;
    const overflow_threshold = moonbitlang$core$strconv$$overflow_threshold(_num_base, _neg);
    let has_digit;
    if (moonbitlang$core$string$$String$char_length_ge$46$inner(_rest$2.str, 1, _rest$2.start, _rest$2.end)) {
      const _x = moonbitlang$core$string$$String$unsafe_char_at(_rest$2.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_rest$2.str, 0, _rest$2.start, _rest$2.end));
      if (_x >= 48 && _x <= 57) {
        has_digit = true;
      } else {
        if (_x >= 97 && _x <= 122) {
          has_digit = true;
        } else {
          if (_x >= 65 && _x <= 90) {
            has_digit = true;
          } else {
            if (moonbitlang$core$string$$String$char_length_ge$46$inner(_rest$2.str, 2, _rest$2.start, _rest$2.end)) {
              if (_x === 95) {
                const _x$2 = moonbitlang$core$string$$String$unsafe_char_at(_rest$2.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_rest$2.str, 1, _rest$2.start, _rest$2.end));
                has_digit = _x$2 >= 48 && _x$2 <= 57 ? true : _x$2 >= 97 && _x$2 <= 122 ? true : _x$2 >= 65 && _x$2 <= 90;
              } else {
                has_digit = false;
              }
            } else {
              has_digit = false;
            }
          }
        }
      }
    } else {
      has_digit = false;
    }
    if (has_digit) {
      let _tmp;
      let _tmp$2 = _rest$2;
      let _tmp$3 = $0L;
      let _tmp$4 = _allow_underscore;
      while (true) {
        const _param_0 = _tmp$2;
        const _param_1 = _tmp$3;
        const _param_2 = _tmp$4;
        let acc;
        let rest$2;
        let c;
        _L$2: {
          if (moonbitlang$core$string$$String$char_length_eq$46$inner(_param_0.str, 1, _param_0.start, _param_0.end)) {
            const _x = moonbitlang$core$string$$String$unsafe_char_at(_param_0.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 0, _param_0.start, _param_0.end));
            if (_x === 95) {
              const _bind$4 = moonbitlang$core$strconv$$syntax_err$107$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            } else {
              const _tmp$5 = _param_0.str;
              const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
              let _tmp$6;
              if (_bind$4 === undefined) {
                _tmp$6 = _param_0.end;
              } else {
                const _Some = _bind$4;
                _tmp$6 = _Some;
              }
              const _tmp$7 = _tmp$6;
              const _x$2 = { str: _tmp$5, start: _tmp$7, end: _param_0.end };
              acc = _param_1;
              rest$2 = _x$2;
              c = _x;
              break _L$2;
            }
          } else {
            if (moonbitlang$core$string$$String$char_length_ge$46$inner(_param_0.str, 1, _param_0.start, _param_0.end)) {
              const _x = moonbitlang$core$string$$String$unsafe_char_at(_param_0.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 0, _param_0.start, _param_0.end));
              if (_x === 95) {
                if (_param_2 === false) {
                  const _bind$4 = moonbitlang$core$strconv$$syntax_err$107$();
                  if (_bind$4.$tag === 1) {
                    const _ok = _bind$4;
                    _tmp = _ok._0;
                    break;
                  } else {
                    return _bind$4;
                  }
                } else {
                  const _tmp$5 = _param_0.str;
                  const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
                  let _tmp$6;
                  if (_bind$4 === undefined) {
                    _tmp$6 = _param_0.end;
                  } else {
                    const _Some = _bind$4;
                    _tmp$6 = _Some;
                  }
                  const _tmp$7 = _tmp$6;
                  const _x$2 = { str: _tmp$5, start: _tmp$7, end: _param_0.end };
                  _tmp$2 = _x$2;
                  _tmp$4 = false;
                  continue;
                }
              } else {
                const _tmp$5 = _param_0.str;
                const _bind$4 = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
                let _tmp$6;
                if (_bind$4 === undefined) {
                  _tmp$6 = _param_0.end;
                } else {
                  const _Some = _bind$4;
                  _tmp$6 = _Some;
                }
                const _tmp$7 = _tmp$6;
                const _x$2 = { str: _tmp$5, start: _tmp$7, end: _param_0.end };
                acc = _param_1;
                rest$2 = _x$2;
                c = _x;
                break _L$2;
              }
            } else {
              _tmp = _param_1;
              break;
            }
          }
        }
        const c$2 = c;
        let d;
        if (c$2 >= 48 && c$2 <= 57) {
          d = c$2 - 48 | 0;
        } else {
          if (c$2 >= 97 && c$2 <= 122) {
            d = c$2 + -87 | 0;
          } else {
            if (c$2 >= 65 && c$2 <= 90) {
              d = c$2 + -55 | 0;
            } else {
              const _bind$4 = moonbitlang$core$strconv$$syntax_err$17$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                d = _ok._0;
              } else {
                return _bind$4;
              }
            }
          }
        }
        if (d < _num_base) {
          if (_neg) {
            if (moonbitlang$core$builtin$$Compare$op_ge$106$(acc, overflow_threshold)) {
              const next_acc = moonbitlang$core$builtin$$Sub$sub$107$(moonbitlang$core$builtin$$Mul$mul$107$(acc, moonbitlang$core$int$$Int$to_int64(_num_base)), moonbitlang$core$int$$Int$to_int64(d));
              if (moonbitlang$core$builtin$$Compare$op_le$106$(next_acc, acc)) {
                _tmp$2 = rest$2;
                _tmp$3 = next_acc;
                _tmp$4 = true;
                continue;
              } else {
                const _bind$4 = moonbitlang$core$strconv$$range_err$107$();
                if (_bind$4.$tag === 1) {
                  const _ok = _bind$4;
                  _tmp = _ok._0;
                  break;
                } else {
                  return _bind$4;
                }
              }
            } else {
              const _bind$4 = moonbitlang$core$strconv$$range_err$107$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            }
          } else {
            if (moonbitlang$core$builtin$$Compare$op_lt$106$(acc, overflow_threshold)) {
              const next_acc = moonbitlang$core$builtin$$Add$add$107$(moonbitlang$core$builtin$$Mul$mul$107$(acc, moonbitlang$core$int$$Int$to_int64(_num_base)), moonbitlang$core$int$$Int$to_int64(d));
              if (moonbitlang$core$builtin$$Compare$op_ge$106$(next_acc, acc)) {
                _tmp$2 = rest$2;
                _tmp$3 = next_acc;
                _tmp$4 = true;
                continue;
              } else {
                const _bind$4 = moonbitlang$core$strconv$$range_err$107$();
                if (_bind$4.$tag === 1) {
                  const _ok = _bind$4;
                  _tmp = _ok._0;
                  break;
                } else {
                  return _bind$4;
                }
              }
            } else {
              const _bind$4 = moonbitlang$core$strconv$$range_err$107$();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp = _ok._0;
                break;
              } else {
                return _bind$4;
              }
            }
          }
        } else {
          const _bind$4 = moonbitlang$core$strconv$$syntax_err$107$();
          if (_bind$4.$tag === 1) {
            const _ok = _bind$4;
            _tmp = _ok._0;
            break;
          } else {
            return _bind$4;
          }
        }
      }
      return new Result$Ok$4$(_tmp);
    } else {
      return moonbitlang$core$strconv$$syntax_err$107$();
    }
  } else {
    return moonbitlang$core$strconv$$syntax_err$107$();
  }
}
function moonbitlang$core$strconv$$parse_int$46$inner(str, base) {
  const _bind = moonbitlang$core$strconv$$parse_int64$46$inner(str, base);
  let n;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    n = _ok._0;
  } else {
    return _bind;
  }
  if (moonbitlang$core$builtin$$Compare$op_lt$106$(n, moonbitlang$core$int$$Int$to_int64(-2147483648)) || moonbitlang$core$builtin$$Compare$op_gt$106$(n, moonbitlang$core$int$$Int$to_int64(2147483647))) {
    const _bind$2 = moonbitlang$core$strconv$$range_err$15$();
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _ok._0;
    } else {
      return _bind$2;
    }
  }
  return new Result$Ok$5$(moonbitlang$core$int64$$Int64$to_int(n));
}
function moonbitlang$core$builtin$$Show$output$125$(self, logger) {
  const _StrConvError = self;
  const _err = _StrConvError._0;
  logger.method_table.method_0(logger.self, _err);
}
function moonbitlang$core$json$$escape(str, escape_slash) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(str.length);
  const _it = moonbitlang$core$string$$String$iter(str);
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$59$(_it);
    if (_bind === -1) {
      break;
    } else {
      const _Some = _bind;
      const _c = _Some;
      switch (_c) {
        case 34: {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, "\\\"");
          break;
        }
        case 92: {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, "\\\\");
          break;
        }
        case 47: {
          if (escape_slash) {
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, "\\/");
          } else {
            moonbitlang$core$builtin$$Logger$write_char$3$(buf, _c);
          }
          break;
        }
        case 10: {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, "\\n");
          break;
        }
        case 13: {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, "\\r");
          break;
        }
        case 8: {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, "\\b");
          break;
        }
        case 9: {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, "\\t");
          break;
        }
        default: {
          const code = _c;
          if (code === 12) {
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, "\\f");
          } else {
            if (code < 32) {
              moonbitlang$core$builtin$$Logger$write_string$3$(buf, "\\u00");
              moonbitlang$core$builtin$$Logger$write_string$3$(buf, moonbitlang$core$byte$$Byte$to_hex(code & 255));
            } else {
              moonbitlang$core$builtin$$Logger$write_char$3$(buf, _c);
            }
          }
        }
      }
      continue;
    }
  }
  return buf.val;
}
function moonbitlang$core$json$$indent_str(level, indent) {
  if (indent === 0) {
    return "";
  } else {
    const spaces = Math.imul(indent, level) | 0;
    switch (spaces) {
      case 0: {
        return "\n";
      }
      case 1: {
        return "\n ";
      }
      case 2: {
        return "\n  ";
      }
      case 3: {
        return "\n   ";
      }
      case 4: {
        return "\n    ";
      }
      case 5: {
        return "\n     ";
      }
      case 6: {
        return "\n      ";
      }
      case 7: {
        return "\n       ";
      }
      case 8: {
        return "\n        ";
      }
      default: {
        return `\n${moonbitlang$core$string$$String$repeat(" ", spaces)}`;
      }
    }
  }
}
function moonbitlang$core$json$$Json$stringify$46$inner(self, escape_slash, indent, replacer) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  const stack = [];
  let depth = 0;
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      if (stack.length === 0) {
        break;
      } else {
        const _x = stack[stack.length - 1 | 0];
        if (_x.$tag === 0) {
          const _Array = _x;
          const _arr = _Array._0;
          const _i = _Array._1;
          if (_i < _arr.length) {
            const element = moonbitlang$core$array$$Array$at$70$(_arr, _i);
            _Array._1 = _i + 1 | 0;
            if (_i > 0) {
              moonbitlang$core$builtin$$Logger$write_char$3$(buf, 44);
              moonbitlang$core$builtin$$Logger$write_string$3$(buf, moonbitlang$core$json$$indent_str(depth, indent));
            }
            _tmp = element;
            continue;
          } else {
            depth = depth - 1 | 0;
            moonbitlang$core$array$$Array$pop$137$(stack);
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, moonbitlang$core$json$$indent_str(depth, indent));
            moonbitlang$core$builtin$$Logger$write_char$3$(buf, 93);
            _tmp = undefined;
            continue;
          }
        } else {
          const _Object = _x;
          const _iterator = _Object._0;
          const _first = _Object._1;
          const _bind = moonbitlang$core$builtin$$Iter$next$164$(_iterator);
          if (_bind === undefined) {
            depth = depth - 1 | 0;
            moonbitlang$core$array$$Array$pop$137$(stack);
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, moonbitlang$core$json$$indent_str(depth, indent));
            moonbitlang$core$builtin$$Logger$write_char$3$(buf, 125);
            _tmp = undefined;
            continue;
          } else {
            const _Some = _bind;
            const _x$2 = _Some;
            const _k = _x$2._0;
            const _v = _x$2._1;
            let v2 = _v;
            if (replacer === undefined) {
            } else {
              const _Some$2 = replacer;
              const _replacer = _Some$2;
              const _func = _replacer;
              const _bind$2 = _func(_k, _v);
              if (_bind$2 === undefined) {
                _tmp = undefined;
                continue;
              } else {
                const _Some$3 = _bind$2;
                const _v$2 = _Some$3;
                v2 = _v$2;
              }
            }
            if (!_first) {
              moonbitlang$core$builtin$$Logger$write_char$3$(buf, 44);
              moonbitlang$core$builtin$$Logger$write_string$3$(buf, moonbitlang$core$json$$indent_str(depth, indent));
            }
            moonbitlang$core$builtin$$Logger$write_char$3$(buf, 34);
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, moonbitlang$core$json$$escape(_k, escape_slash));
            moonbitlang$core$builtin$$Logger$write_char$3$(buf, 34);
            moonbitlang$core$builtin$$Logger$write_char$3$(buf, 58);
            if (indent > 0) {
              moonbitlang$core$builtin$$Logger$write_char$3$(buf, 32);
            }
            _Object._1 = false;
            _tmp = v2;
            continue;
          }
        }
      }
    } else {
      const _Some = _param;
      const _value = _Some;
      switch (_value.$tag) {
        case 6: {
          const _Object = _value;
          const _members = _Object._0;
          if (_members.size === 0) {
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, "{}");
          } else {
            depth = depth + 1 | 0;
            moonbitlang$core$builtin$$Logger$write_char$3$(buf, 123);
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, moonbitlang$core$json$$indent_str(depth, indent));
            moonbitlang$core$array$$Array$push$137$(stack, new $64$moonbitlang$47$core$47$json$46$WriteFrame$Object(moonbitlang$core$builtin$$Map$iter$218$(_members), true));
          }
          break;
        }
        case 5: {
          const _Array = _value;
          const _arr = _Array._0;
          if (_arr.length === 0) {
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, "[]");
          } else {
            depth = depth + 1 | 0;
            moonbitlang$core$builtin$$Logger$write_char$3$(buf, 91);
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, moonbitlang$core$json$$indent_str(depth, indent));
            moonbitlang$core$array$$Array$push$137$(stack, new $64$moonbitlang$47$core$47$json$46$WriteFrame$Array(_arr, 0));
          }
          break;
        }
        case 4: {
          const _String = _value;
          const _s = _String._0;
          moonbitlang$core$builtin$$Logger$write_char$3$(buf, 34);
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, moonbitlang$core$json$$escape(_s, escape_slash));
          moonbitlang$core$builtin$$Logger$write_char$3$(buf, 34);
          break;
        }
        case 3: {
          const _Number = _value;
          const _n = _Number._0;
          const _repr = _Number._1;
          if (_repr === undefined) {
            moonbitlang$core$builtin$$StringBuilder$write_object$78$(buf, _n);
          } else {
            const _Some$2 = _repr;
            const _r = _Some$2;
            moonbitlang$core$builtin$$Logger$write_string$3$(buf, _r);
          }
          break;
        }
        case 1: {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, "true");
          break;
        }
        case 2: {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, "false");
          break;
        }
        default: {
          moonbitlang$core$builtin$$Logger$write_string$3$(buf, "null");
        }
      }
      _tmp = undefined;
      continue;
    }
  }
  return buf.val;
}
function moonbitlang$core$immut$array$$immutable_push$65$(arr, val) {
  const len = arr.length;
  const new_arr = $make_array_len_and_init(len + 1 | 0, val);
  moonbitlang$core$array$$FixedArray$blit_to$46$inner$65$(arr, new_arr, len, 0, 0);
  $bound_check(new_arr, len);
  new_arr[len] = val;
  return new_arr;
}
function moonbitlang$core$immut$array$$immutable_push$17$(arr, val) {
  const len = arr.length;
  const new_arr = $make_array_len_and_init(len + 1 | 0, val);
  moonbitlang$core$array$$FixedArray$blit_to$46$inner$17$(arr, new_arr, len, 0, 0);
  $bound_check(new_arr, len);
  new_arr[len] = val;
  return new_arr;
}
function moonbitlang$core$immut$array$$immutable_push$26$(arr, val) {
  const len = arr.length;
  const new_arr = $make_array_len_and_init(len + 1 | 0, val);
  moonbitlang$core$array$$FixedArray$blit_to$46$inner$26$(arr, new_arr, len, 0, 0);
  $bound_check(new_arr, len);
  new_arr[len] = val;
  return new_arr;
}
function moonbitlang$core$immut$array$$immutable_push$32$(arr, val) {
  const len = arr.length;
  const new_arr = $make_array_len_and_init(len + 1 | 0, val);
  moonbitlang$core$array$$FixedArray$blit_to$46$inner$32$(arr, new_arr, len, 0, 0);
  $bound_check(new_arr, len);
  new_arr[len] = val;
  return new_arr;
}
function moonbitlang$core$immut$array$$immutable_push$31$(arr, val) {
  const len = arr.length;
  const new_arr = $make_array_len_and_init(len + 1 | 0, val);
  moonbitlang$core$array$$FixedArray$blit_to$46$inner$31$(arr, new_arr, len, 0, 0);
  $bound_check(new_arr, len);
  new_arr[len] = val;
  return new_arr;
}
function moonbitlang$core$immut$array$$immutable_push$28$(arr, val) {
  const len = arr.length;
  const new_arr = $make_array_len_and_init(len + 1 | 0, val);
  moonbitlang$core$array$$FixedArray$blit_to$46$inner$28$(arr, new_arr, len, 0, 0);
  $bound_check(new_arr, len);
  new_arr[len] = val;
  return new_arr;
}
function moonbitlang$core$immut$array$$immutable_push$33$(arr, val) {
  const len = arr.length;
  const new_arr = $make_array_len_and_init(len + 1 | 0, val);
  moonbitlang$core$array$$FixedArray$blit_to$46$inner$33$(arr, new_arr, len, 0, 0);
  $bound_check(new_arr, len);
  new_arr[len] = val;
  return new_arr;
}
function moonbitlang$core$immut$array$$radix_indexing(index, shift) {
  return index >>> shift & 31;
}
function moonbitlang$core$immut$array$$get_branch_index(sizes, index) {
  let lo = 0;
  let hi = sizes.length;
  while (true) {
    if (4 < (hi - lo | 0)) {
      const mid = (lo + hi | 0) / 2 | 0;
      $bound_check(sizes, mid);
      if (sizes[mid] <= index) {
        lo = mid;
      } else {
        hi = mid;
      }
      continue;
    } else {
      break;
    }
  }
  while (true) {
    const _tmp = lo;
    $bound_check(sizes, _tmp);
    if (sizes[_tmp] <= index) {
      lo = lo + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return lo;
}
function moonbitlang$core$immut$array$$copy_sizes(sizes) {
  if (sizes === undefined) {
    return undefined;
  } else {
    const _Some = sizes;
    const _sizes = _Some;
    return moonbitlang$core$array$$FixedArray$copy$17$(_sizes);
  }
}
function moonbitlang$core$immut$array$$Tree$is_node$32$(self) {
  if (self.$tag === 1) {
    return true;
  } else {
    return false;
  }
}
function moonbitlang$core$immut$array$$Tree$is_leaf$32$(self) {
  if (self.$tag === 2) {
    return true;
  } else {
    return false;
  }
}
function moonbitlang$core$immut$array$$Tree$right_child$32$(self) {
  _L: {
    switch (self.$tag) {
      case 1: {
        const _Node = self;
        const _children = _Node._0;
        const _tmp = _children.length - 1 | 0;
        $bound_check(_children, _tmp);
        return _children[_tmp];
      }
      case 2: {
        break _L;
      }
      default: {
        break _L;
      }
    }
  }
  return moonbitlang$core$builtin$$abort$31$("Should not get children on non-`Node`s", "@moonbitlang/core/immut/array:tree_utils.mbt:35:24-35:71");
}
function moonbitlang$core$immut$array$$Tree$left_child$32$(self) {
  _L: {
    switch (self.$tag) {
      case 1: {
        const _Node = self;
        const _children = _Node._0;
        $bound_check(_children, 0);
        return _children[0];
      }
      case 2: {
        break _L;
      }
      default: {
        break _L;
      }
    }
  }
  return moonbitlang$core$builtin$$abort$31$("Should not get children on non-`Node`s", "@moonbitlang/core/immut/array:tree_utils.mbt:45:24-45:71");
}
function moonbitlang$core$immut$array$$Tree$leaf_elements$32$(self) {
  if (self.$tag === 2) {
    const _Leaf = self;
    return _Leaf._0;
  } else {
    return moonbitlang$core$builtin$$abort$44$("Should not call `get_leaf_elements` on non-leaf nodes", "@moonbitlang/core/immut/array:tree_utils.mbt:53:5-53:67");
  }
}
function moonbitlang$core$immut$array$$Tree$node_children$32$(self) {
  if (self.$tag === 1) {
    const _Node = self;
    return _Node._0;
  } else {
    return moonbitlang$core$builtin$$abort$46$("Should not call `node_children` on non-`Node`s", "@moonbitlang/core/immut/array:tree_utils.mbt:62:5-62:60");
  }
}
function moonbitlang$core$immut$array$$Tree$local_size$32$(self) {
  switch (self.$tag) {
    case 0: {
      return 0;
    }
    case 2: {
      const _Leaf = self;
      const _l = _Leaf._0;
      return _l.length;
    }
    default: {
      const _Node = self;
      const _children = _Node._0;
      return _children.length;
    }
  }
}
function moonbitlang$core$immut$array$$Tree$size$32$(self, shift) {
  switch (self.$tag) {
    case 0: {
      return 0;
    }
    case 2: {
      const _Leaf = self;
      const _l = _Leaf._0;
      return _l.length;
    }
    default: {
      const _Node = self;
      const _x = _Node._0;
      const _x$2 = _Node._1;
      if (_x$2 === undefined) {
        const len_1 = _x.length - 1 | 0;
        const _tmp = len_1 << shift;
        $bound_check(_x, len_1);
        return _tmp + moonbitlang$core$immut$array$$Tree$size$32$(_x[len_1], shift - 5 | 0) | 0;
      } else {
        const _Some = _x$2;
        const _sizes = _Some;
        const _tmp = _sizes.length - 1 | 0;
        $bound_check(_sizes, _tmp);
        return _sizes[_tmp];
      }
    }
  }
}
function moonbitlang$core$immut$array$$new_branch_left$65$(leaf, shift) {
  if (shift === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$6$(leaf);
  } else {
    return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$6$([moonbitlang$core$immut$array$$new_branch_left$65$(leaf, shift - 5 | 0)], undefined);
  }
}
function moonbitlang$core$immut$array$$new_branch_left$32$(leaf, shift) {
  if (shift === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$7$(leaf);
  } else {
    return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$([moonbitlang$core$immut$array$$new_branch_left$32$(leaf, shift - 5 | 0)], undefined);
  }
}
function moonbitlang$core$immut$array$$new_branch_left$28$(leaf, shift) {
  if (shift === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$8$(leaf);
  } else {
    return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$([moonbitlang$core$immut$array$$new_branch_left$28$(leaf, shift - 5 | 0)], undefined);
  }
}
function moonbitlang$core$immut$array$$Tree$get_first$32$(self) {
  let _tmp = self;
  _L: while (true) {
    const self$2 = _tmp;
    switch (self$2.$tag) {
      case 2: {
        const _Leaf = self$2;
        const _leaf = _Leaf._0;
        $bound_check(_leaf, 0);
        return _leaf[0];
      }
      case 1: {
        const _Node = self$2;
        const _node = _Node._0;
        $bound_check(_node, 0);
        _tmp = _node[0];
        continue _L;
      }
      default: {
        return moonbitlang$core$builtin$$abort$32$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:73:14-73:42");
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$get_first$28$(self) {
  let _tmp = self;
  _L: while (true) {
    const self$2 = _tmp;
    switch (self$2.$tag) {
      case 2: {
        const _Leaf = self$2;
        const _leaf = _Leaf._0;
        $bound_check(_leaf, 0);
        return _leaf[0];
      }
      case 1: {
        const _Node = self$2;
        const _node = _Node._0;
        $bound_check(_node, 0);
        _tmp = _node[0];
        continue _L;
      }
      default: {
        return moonbitlang$core$builtin$$abort$28$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:73:14-73:42");
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$get_first$27$(self) {
  let _tmp = self;
  _L: while (true) {
    const self$2 = _tmp;
    switch (self$2.$tag) {
      case 2: {
        const _Leaf = self$2;
        const _leaf = _Leaf._0;
        $bound_check(_leaf, 0);
        return _leaf[0];
      }
      case 1: {
        const _Node = self$2;
        const _node = _Node._0;
        $bound_check(_node, 0);
        _tmp = _node[0];
        continue _L;
      }
      default: {
        return moonbitlang$core$builtin$$abort$27$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:73:14-73:42");
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$get_last$32$(self) {
  let _tmp = self;
  _L: while (true) {
    const self$2 = _tmp;
    switch (self$2.$tag) {
      case 2: {
        const _Leaf = self$2;
        const _leaf = _Leaf._0;
        const _tmp$2 = _leaf.length - 1 | 0;
        $bound_check(_leaf, _tmp$2);
        return _leaf[_tmp$2];
      }
      case 1: {
        const _Node = self$2;
        const _node = _Node._0;
        const _tmp$3 = _node.length - 1 | 0;
        $bound_check(_node, _tmp$3);
        _tmp = _node[_tmp$3];
        continue _L;
      }
      default: {
        return moonbitlang$core$builtin$$abort$32$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:83:14-83:42");
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$get_last$28$(self) {
  let _tmp = self;
  _L: while (true) {
    const self$2 = _tmp;
    switch (self$2.$tag) {
      case 2: {
        const _Leaf = self$2;
        const _leaf = _Leaf._0;
        const _tmp$2 = _leaf.length - 1 | 0;
        $bound_check(_leaf, _tmp$2);
        return _leaf[_tmp$2];
      }
      case 1: {
        const _Node = self$2;
        const _node = _Node._0;
        const _tmp$3 = _node.length - 1 | 0;
        $bound_check(_node, _tmp$3);
        _tmp = _node[_tmp$3];
        continue _L;
      }
      default: {
        return moonbitlang$core$builtin$$abort$28$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:83:14-83:42");
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$get_last$27$(self) {
  let _tmp = self;
  _L: while (true) {
    const self$2 = _tmp;
    switch (self$2.$tag) {
      case 2: {
        const _Leaf = self$2;
        const _leaf = _Leaf._0;
        const _tmp$2 = _leaf.length - 1 | 0;
        $bound_check(_leaf, _tmp$2);
        return _leaf[_tmp$2];
      }
      case 1: {
        const _Node = self$2;
        const _node = _Node._0;
        const _tmp$3 = _node.length - 1 | 0;
        $bound_check(_node, _tmp$3);
        _tmp = _node[_tmp$3];
        continue _L;
      }
      default: {
        return moonbitlang$core$builtin$$abort$27$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:83:14-83:42");
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$get$32$(self, index, shift) {
  let _tmp = self;
  let _tmp$2 = index;
  let _tmp$3 = shift;
  _L: while (true) {
    const self$2 = _tmp;
    const index$2 = _tmp$2;
    const shift$2 = _tmp$3;
    let node;
    let shift$3;
    _L$2: {
      switch (self$2.$tag) {
        case 2: {
          const _Leaf = self$2;
          const _leaf = _Leaf._0;
          $bound_check(_leaf, index$2);
          return _leaf[index$2];
        }
        case 1: {
          const _Node = self$2;
          const _children = _Node._0;
          const _x = _Node._1;
          if (_x === undefined) {
            node = self$2;
            shift$3 = shift$2;
            break _L$2;
          } else {
            const _Some = _x;
            const _sizes = _Some;
            const branch_index = moonbitlang$core$immut$array$$get_branch_index(_sizes, index$2);
            let sub_index;
            if (branch_index === 0) {
              sub_index = index$2;
            } else {
              const _tmp$4 = branch_index - 1 | 0;
              $bound_check(_sizes, _tmp$4);
              sub_index = index$2 - _sizes[_tmp$4] | 0;
            }
            $bound_check(_children, branch_index);
            _tmp = _children[branch_index];
            _tmp$2 = sub_index;
            _tmp$3 = shift$2 - 5 | 0;
            continue _L;
          }
        }
        default: {
          return moonbitlang$core$builtin$$abort$32$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:116:14-116:42");
        }
      }
    }
    let _tmp$4 = node;
    let _tmp$5 = shift$3;
    _L$3: while (true) {
      const node$2 = _tmp$4;
      const shift$4 = _tmp$5;
      switch (node$2.$tag) {
        case 2: {
          const _Leaf = node$2;
          const _leaf = _Leaf._0;
          const _tmp$6 = index$2 & 31;
          $bound_check(_leaf, _tmp$6);
          return _leaf[_tmp$6];
        }
        case 1: {
          const _Node = node$2;
          const _node = _Node._0;
          const _x = _Node._1;
          if (_x === undefined) {
            const _tmp$7 = moonbitlang$core$immut$array$$radix_indexing(index$2, shift$4);
            $bound_check(_node, _tmp$7);
            _tmp$4 = _node[_tmp$7];
            _tmp$5 = shift$4 - 5 | 0;
            continue _L$3;
          } else {
            return moonbitlang$core$builtin$$abort$32$("Unreachable: Node should not have sizes in get_radix", "@moonbitlang/core/immut/array:tree.mbt:99:9-99:70");
          }
        }
        default: {
          return moonbitlang$core$builtin$$abort$32$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:100:16-100:44");
        }
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$get$28$(self, index, shift) {
  let _tmp = self;
  let _tmp$2 = index;
  let _tmp$3 = shift;
  _L: while (true) {
    const self$2 = _tmp;
    const index$2 = _tmp$2;
    const shift$2 = _tmp$3;
    let node;
    let shift$3;
    _L$2: {
      switch (self$2.$tag) {
        case 2: {
          const _Leaf = self$2;
          const _leaf = _Leaf._0;
          $bound_check(_leaf, index$2);
          return _leaf[index$2];
        }
        case 1: {
          const _Node = self$2;
          const _children = _Node._0;
          const _x = _Node._1;
          if (_x === undefined) {
            node = self$2;
            shift$3 = shift$2;
            break _L$2;
          } else {
            const _Some = _x;
            const _sizes = _Some;
            const branch_index = moonbitlang$core$immut$array$$get_branch_index(_sizes, index$2);
            let sub_index;
            if (branch_index === 0) {
              sub_index = index$2;
            } else {
              const _tmp$4 = branch_index - 1 | 0;
              $bound_check(_sizes, _tmp$4);
              sub_index = index$2 - _sizes[_tmp$4] | 0;
            }
            $bound_check(_children, branch_index);
            _tmp = _children[branch_index];
            _tmp$2 = sub_index;
            _tmp$3 = shift$2 - 5 | 0;
            continue _L;
          }
        }
        default: {
          return moonbitlang$core$builtin$$abort$28$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:116:14-116:42");
        }
      }
    }
    let _tmp$4 = node;
    let _tmp$5 = shift$3;
    _L$3: while (true) {
      const node$2 = _tmp$4;
      const shift$4 = _tmp$5;
      switch (node$2.$tag) {
        case 2: {
          const _Leaf = node$2;
          const _leaf = _Leaf._0;
          const _tmp$6 = index$2 & 31;
          $bound_check(_leaf, _tmp$6);
          return _leaf[_tmp$6];
        }
        case 1: {
          const _Node = node$2;
          const _node = _Node._0;
          const _x = _Node._1;
          if (_x === undefined) {
            const _tmp$7 = moonbitlang$core$immut$array$$radix_indexing(index$2, shift$4);
            $bound_check(_node, _tmp$7);
            _tmp$4 = _node[_tmp$7];
            _tmp$5 = shift$4 - 5 | 0;
            continue _L$3;
          } else {
            return moonbitlang$core$builtin$$abort$28$("Unreachable: Node should not have sizes in get_radix", "@moonbitlang/core/immut/array:tree.mbt:99:9-99:70");
          }
        }
        default: {
          return moonbitlang$core$builtin$$abort$28$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:100:16-100:44");
        }
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$get$27$(self, index, shift) {
  let _tmp = self;
  let _tmp$2 = index;
  let _tmp$3 = shift;
  _L: while (true) {
    const self$2 = _tmp;
    const index$2 = _tmp$2;
    const shift$2 = _tmp$3;
    let node;
    let shift$3;
    _L$2: {
      switch (self$2.$tag) {
        case 2: {
          const _Leaf = self$2;
          const _leaf = _Leaf._0;
          $bound_check(_leaf, index$2);
          return _leaf[index$2];
        }
        case 1: {
          const _Node = self$2;
          const _children = _Node._0;
          const _x = _Node._1;
          if (_x === undefined) {
            node = self$2;
            shift$3 = shift$2;
            break _L$2;
          } else {
            const _Some = _x;
            const _sizes = _Some;
            const branch_index = moonbitlang$core$immut$array$$get_branch_index(_sizes, index$2);
            let sub_index;
            if (branch_index === 0) {
              sub_index = index$2;
            } else {
              const _tmp$4 = branch_index - 1 | 0;
              $bound_check(_sizes, _tmp$4);
              sub_index = index$2 - _sizes[_tmp$4] | 0;
            }
            $bound_check(_children, branch_index);
            _tmp = _children[branch_index];
            _tmp$2 = sub_index;
            _tmp$3 = shift$2 - 5 | 0;
            continue _L;
          }
        }
        default: {
          return moonbitlang$core$builtin$$abort$27$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:116:14-116:42");
        }
      }
    }
    let _tmp$4 = node;
    let _tmp$5 = shift$3;
    _L$3: while (true) {
      const node$2 = _tmp$4;
      const shift$4 = _tmp$5;
      switch (node$2.$tag) {
        case 2: {
          const _Leaf = node$2;
          const _leaf = _Leaf._0;
          const _tmp$6 = index$2 & 31;
          $bound_check(_leaf, _tmp$6);
          return _leaf[_tmp$6];
        }
        case 1: {
          const _Node = node$2;
          const _node = _Node._0;
          const _x = _Node._1;
          if (_x === undefined) {
            const _tmp$7 = moonbitlang$core$immut$array$$radix_indexing(index$2, shift$4);
            $bound_check(_node, _tmp$7);
            _tmp$4 = _node[_tmp$7];
            _tmp$5 = shift$4 - 5 | 0;
            continue _L$3;
          } else {
            return moonbitlang$core$builtin$$abort$27$("Unreachable: Node should not have sizes in get_radix", "@moonbitlang/core/immut/array:tree.mbt:99:9-99:70");
          }
        }
        default: {
          return moonbitlang$core$builtin$$abort$27$("Index out of bounds", "@moonbitlang/core/immut/array:tree.mbt:100:16-100:44");
        }
      }
    }
  }
}
function moonbitlang$core$immut$array$$push_end$46$worker$47$3824(value, node, shift) {
  switch (node.$tag) {
    case 2: {
      const _Leaf = node;
      const _leaf = _Leaf._0;
      if (shift !== 0) {
        moonbitlang$core$builtin$$abort$15$("Unreachable: Leaf should not have a non-zero shift, which means we have not reached the bottom of the tree", "@moonbitlang/core/immut/array:tree.mbt:203:11-205:12");
      }
      return _leaf.length < 32 ? new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$6$(moonbitlang$core$immut$array$$immutable_push$65$(_leaf, value)) : undefined;
    }
    case 1: {
      const _Node = node;
      const _nodes = _Node._0;
      const _sizes = _Node._1;
      const len = _nodes.length;
      const _tmp = len - 1 | 0;
      $bound_check(_nodes, _tmp);
      const _bind = moonbitlang$core$immut$array$$push_end$46$worker$47$3824(value, _nodes[_tmp], shift - 5 | 0);
      if (_bind === undefined) {
        if (len < 32) {
          let sizes;
          if (_sizes === undefined) {
            sizes = undefined;
          } else {
            const _Some = _sizes;
            const _sizes$2 = _Some;
            const _tmp$2 = _sizes$2.length - 1 | 0;
            $bound_check(_sizes$2, _tmp$2);
            sizes = moonbitlang$core$immut$array$$immutable_push$17$(_sizes$2, 1 + _sizes$2[_tmp$2] | 0);
          }
          return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$6$(moonbitlang$core$immut$array$$immutable_push$26$(_nodes, moonbitlang$core$immut$array$$new_branch_left$65$([value], shift - 5 | 0)), sizes);
        } else {
          return undefined;
        }
      } else {
        const _Some = _bind;
        const _new_node = _Some;
        const new_nodes = moonbitlang$core$array$$FixedArray$copy$26$(_nodes);
        const _tmp$2 = len - 1 | 0;
        $bound_check(new_nodes, _tmp$2);
        new_nodes[_tmp$2] = _new_node;
        let sizes;
        if (_sizes === undefined) {
          sizes = undefined;
        } else {
          const _Some$2 = _sizes;
          const _sizes$2 = _Some$2;
          const new_sizes = moonbitlang$core$array$$FixedArray$copy$17$(_sizes$2);
          const _index_2 = new_sizes.length - 1 | 0;
          $bound_check(new_sizes, _index_2);
          $bound_check(new_sizes, _index_2);
          new_sizes[_index_2] = new_sizes[_index_2] + 1 | 0;
          sizes = new_sizes;
        }
        return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$6$(new_nodes, sizes);
      }
    }
    default: {
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$6$([value]);
    }
  }
}
function moonbitlang$core$immut$array$$Tree$push_end$65$(self, shift, value) {
  const _bind = moonbitlang$core$immut$array$$push_end$46$worker$47$3824(value, self, shift);
  if (_bind === undefined) {
    const new_branch = moonbitlang$core$immut$array$$new_branch_left$65$([value], shift);
    let _tmp;
    switch (self.$tag) {
      case 2: {
        _tmp = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$6$([self, new_branch], undefined);
        break;
      }
      case 1: {
        const _Node = self;
        const _x = _Node._1;
        if (_x === undefined) {
          _tmp = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$6$([self, new_branch], undefined);
        } else {
          const _Some = _x;
          const _sizes = _Some;
          const _tmp$2 = _sizes.length - 1 | 0;
          $bound_check(_sizes, _tmp$2);
          const len = _sizes[_tmp$2];
          const _bind$2 = [len, 1 + len | 0];
          const sizes = moonbitlang$core$array$$FixedArray$from_array$17$({ buf: _bind$2, start: 0, end: 2 });
          _tmp = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$6$([self, new_branch], sizes);
        }
        break;
      }
      default: {
        _tmp = moonbitlang$core$builtin$$abort$26$("Unreachable: Empty tree should have fallen into the Some(new_tree) branch", "@moonbitlang/core/immut/array:tree.mbt:259:13-261:14");
      }
    }
    return { _0: _tmp, _1: shift + 5 | 0 };
  } else {
    const _Some = _bind;
    const _new_tree = _Some;
    return { _0: _new_tree, _1: shift };
  }
}
function moonbitlang$core$immut$array$$push_end$46$worker$47$3860(value, node, shift) {
  switch (node.$tag) {
    case 2: {
      const _Leaf = node;
      const _leaf = _Leaf._0;
      if (shift !== 0) {
        moonbitlang$core$builtin$$abort$15$("Unreachable: Leaf should not have a non-zero shift, which means we have not reached the bottom of the tree", "@moonbitlang/core/immut/array:tree.mbt:203:11-205:12");
      }
      return _leaf.length < 32 ? new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$7$(moonbitlang$core$immut$array$$immutable_push$32$(_leaf, value)) : undefined;
    }
    case 1: {
      const _Node = node;
      const _nodes = _Node._0;
      const _sizes = _Node._1;
      const len = _nodes.length;
      const _tmp = len - 1 | 0;
      $bound_check(_nodes, _tmp);
      const _bind = moonbitlang$core$immut$array$$push_end$46$worker$47$3860(value, _nodes[_tmp], shift - 5 | 0);
      if (_bind === undefined) {
        if (len < 32) {
          let sizes;
          if (_sizes === undefined) {
            sizes = undefined;
          } else {
            const _Some = _sizes;
            const _sizes$2 = _Some;
            const _tmp$2 = _sizes$2.length - 1 | 0;
            $bound_check(_sizes$2, _tmp$2);
            sizes = moonbitlang$core$immut$array$$immutable_push$17$(_sizes$2, 1 + _sizes$2[_tmp$2] | 0);
          }
          return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(moonbitlang$core$immut$array$$immutable_push$31$(_nodes, moonbitlang$core$immut$array$$new_branch_left$32$([value], shift - 5 | 0)), sizes);
        } else {
          return undefined;
        }
      } else {
        const _Some = _bind;
        const _new_node = _Some;
        const new_nodes = moonbitlang$core$array$$FixedArray$copy$31$(_nodes);
        const _tmp$2 = len - 1 | 0;
        $bound_check(new_nodes, _tmp$2);
        new_nodes[_tmp$2] = _new_node;
        let sizes;
        if (_sizes === undefined) {
          sizes = undefined;
        } else {
          const _Some$2 = _sizes;
          const _sizes$2 = _Some$2;
          const new_sizes = moonbitlang$core$array$$FixedArray$copy$17$(_sizes$2);
          const _index_2 = new_sizes.length - 1 | 0;
          $bound_check(new_sizes, _index_2);
          $bound_check(new_sizes, _index_2);
          new_sizes[_index_2] = new_sizes[_index_2] + 1 | 0;
          sizes = new_sizes;
        }
        return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(new_nodes, sizes);
      }
    }
    default: {
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$7$([value]);
    }
  }
}
function moonbitlang$core$immut$array$$Tree$push_end$32$(self, shift, value) {
  const _bind = moonbitlang$core$immut$array$$push_end$46$worker$47$3860(value, self, shift);
  if (_bind === undefined) {
    const new_branch = moonbitlang$core$immut$array$$new_branch_left$32$([value], shift);
    let _tmp;
    switch (self.$tag) {
      case 2: {
        _tmp = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$([self, new_branch], undefined);
        break;
      }
      case 1: {
        const _Node = self;
        const _x = _Node._1;
        if (_x === undefined) {
          _tmp = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$([self, new_branch], undefined);
        } else {
          const _Some = _x;
          const _sizes = _Some;
          const _tmp$2 = _sizes.length - 1 | 0;
          $bound_check(_sizes, _tmp$2);
          const len = _sizes[_tmp$2];
          const _bind$2 = [len, 1 + len | 0];
          const sizes = moonbitlang$core$array$$FixedArray$from_array$17$({ buf: _bind$2, start: 0, end: 2 });
          _tmp = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$([self, new_branch], sizes);
        }
        break;
      }
      default: {
        _tmp = moonbitlang$core$builtin$$abort$31$("Unreachable: Empty tree should have fallen into the Some(new_tree) branch", "@moonbitlang/core/immut/array:tree.mbt:259:13-261:14");
      }
    }
    return { _0: _tmp, _1: shift + 5 | 0 };
  } else {
    const _Some = _bind;
    const _new_tree = _Some;
    return { _0: _new_tree, _1: shift };
  }
}
function moonbitlang$core$immut$array$$push_end$46$worker$47$3896(value, node, shift) {
  switch (node.$tag) {
    case 2: {
      const _Leaf = node;
      const _leaf = _Leaf._0;
      if (shift !== 0) {
        moonbitlang$core$builtin$$abort$15$("Unreachable: Leaf should not have a non-zero shift, which means we have not reached the bottom of the tree", "@moonbitlang/core/immut/array:tree.mbt:203:11-205:12");
      }
      return _leaf.length < 32 ? new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$8$(moonbitlang$core$immut$array$$immutable_push$28$(_leaf, value)) : undefined;
    }
    case 1: {
      const _Node = node;
      const _nodes = _Node._0;
      const _sizes = _Node._1;
      const len = _nodes.length;
      const _tmp = len - 1 | 0;
      $bound_check(_nodes, _tmp);
      const _bind = moonbitlang$core$immut$array$$push_end$46$worker$47$3896(value, _nodes[_tmp], shift - 5 | 0);
      if (_bind === undefined) {
        if (len < 32) {
          let sizes;
          if (_sizes === undefined) {
            sizes = undefined;
          } else {
            const _Some = _sizes;
            const _sizes$2 = _Some;
            const _tmp$2 = _sizes$2.length - 1 | 0;
            $bound_check(_sizes$2, _tmp$2);
            sizes = moonbitlang$core$immut$array$$immutable_push$17$(_sizes$2, 1 + _sizes$2[_tmp$2] | 0);
          }
          return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$(moonbitlang$core$immut$array$$immutable_push$33$(_nodes, moonbitlang$core$immut$array$$new_branch_left$28$([value], shift - 5 | 0)), sizes);
        } else {
          return undefined;
        }
      } else {
        const _Some = _bind;
        const _new_node = _Some;
        const new_nodes = moonbitlang$core$array$$FixedArray$copy$33$(_nodes);
        const _tmp$2 = len - 1 | 0;
        $bound_check(new_nodes, _tmp$2);
        new_nodes[_tmp$2] = _new_node;
        let sizes;
        if (_sizes === undefined) {
          sizes = undefined;
        } else {
          const _Some$2 = _sizes;
          const _sizes$2 = _Some$2;
          const new_sizes = moonbitlang$core$array$$FixedArray$copy$17$(_sizes$2);
          const _index_2 = new_sizes.length - 1 | 0;
          $bound_check(new_sizes, _index_2);
          $bound_check(new_sizes, _index_2);
          new_sizes[_index_2] = new_sizes[_index_2] + 1 | 0;
          sizes = new_sizes;
        }
        return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$(new_nodes, sizes);
      }
    }
    default: {
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$8$([value]);
    }
  }
}
function moonbitlang$core$immut$array$$Tree$push_end$28$(self, shift, value) {
  const _bind = moonbitlang$core$immut$array$$push_end$46$worker$47$3896(value, self, shift);
  if (_bind === undefined) {
    const new_branch = moonbitlang$core$immut$array$$new_branch_left$28$([value], shift);
    let _tmp;
    switch (self.$tag) {
      case 2: {
        _tmp = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$([self, new_branch], undefined);
        break;
      }
      case 1: {
        const _Node = self;
        const _x = _Node._1;
        if (_x === undefined) {
          _tmp = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$([self, new_branch], undefined);
        } else {
          const _Some = _x;
          const _sizes = _Some;
          const _tmp$2 = _sizes.length - 1 | 0;
          $bound_check(_sizes, _tmp$2);
          const len = _sizes[_tmp$2];
          const _bind$2 = [len, 1 + len | 0];
          const sizes = moonbitlang$core$array$$FixedArray$from_array$17$({ buf: _bind$2, start: 0, end: 2 });
          _tmp = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$([self, new_branch], sizes);
        }
        break;
      }
      default: {
        _tmp = moonbitlang$core$builtin$$abort$33$("Unreachable: Empty tree should have fallen into the Some(new_tree) branch", "@moonbitlang/core/immut/array:tree.mbt:259:13-261:14");
      }
    }
    return { _0: _tmp, _1: shift + 5 | 0 };
  } else {
    const _Some = _bind;
    const _new_tree = _Some;
    return { _0: _new_tree, _1: shift };
  }
}
function moonbitlang$core$immut$array$$Tree$iter$65$(self) {
  const curr_tree = { val: self };
  const curr_index = { val: 0 };
  const parents = [];
  const _p = () => {
    let _tmp = curr_tree.val;
    _L: while (true) {
      const _param = _tmp;
      _L$2: {
        let parent_tree;
        let parent_index;
        _L$3: {
          switch (_param.$tag) {
            case 1: {
              const _Node = _param;
              const _children = _Node._0;
              if (curr_index.val < _children.length) {
                const child = _children[curr_index.val];
                moonbitlang$core$array$$Array$push$150$(parents, { _0: _Node, _1: curr_index.val + 1 | 0 });
                curr_tree.val = child;
                curr_index.val = 0;
                _tmp = child;
                continue _L;
              } else {
                const _bind = moonbitlang$core$array$$Array$pop$150$(parents);
                if (_bind === undefined) {
                  break _L$2;
                } else {
                  const _Some = _bind;
                  const _x = _Some;
                  const _parent_tree = _x._0;
                  const _parent_index = _x._1;
                  parent_tree = _parent_tree;
                  parent_index = _parent_index;
                  break _L$3;
                }
              }
            }
            case 2: {
              const _Leaf = _param;
              const _elems = _Leaf._0;
              if (curr_index.val < _elems.length) {
                const elem = _elems[curr_index.val];
                curr_index.val = curr_index.val + 1 | 0;
                return elem;
              } else {
                const _bind = moonbitlang$core$array$$Array$pop$150$(parents);
                if (_bind === undefined) {
                  break _L$2;
                } else {
                  const _Some = _bind;
                  const _x = _Some;
                  const _parent_tree = _x._0;
                  const _parent_index = _x._1;
                  parent_tree = _parent_tree;
                  parent_index = _parent_index;
                  break _L$3;
                }
              }
            }
            default: {
              const _bind = moonbitlang$core$array$$Array$pop$150$(parents);
              if (_bind === undefined) {
                break _L$2;
              } else {
                const _Some = _bind;
                const _x = _Some;
                const _parent_tree = _x._0;
                const _parent_index = _x._1;
                parent_tree = _parent_tree;
                parent_index = _parent_index;
                break _L$3;
              }
            }
          }
        }
        curr_tree.val = parent_tree;
        curr_index.val = parent_index;
        _tmp = parent_tree;
        continue;
      }
      return undefined;
    }
  };
  return _p;
}
function moonbitlang$core$immut$array$$Tree$eachi$194$(self, f, shift, start) {
  switch (self.$tag) {
    case 0: {
      return;
    }
    case 2: {
      const _Leaf = self;
      const _l = _Leaf._0;
      const _end292 = _l.length;
      let _tmp = 0;
      while (true) {
        const i = _tmp;
        if (i < _end292) {
          const _tmp$2 = start + i | 0;
          $bound_check(_l, i);
          f(_tmp$2, _l[i]);
          _tmp = i + 1 | 0;
          continue;
        } else {
          return;
        }
      }
    }
    default: {
      const _Node = self;
      const _ns = _Node._0;
      const _x = _Node._1;
      if (_x === undefined) {
        const child_shift = shift - 5 | 0;
        let start$2 = start;
        const _end300 = _ns.length;
        let _tmp$2 = 0;
        while (true) {
          const i = _tmp$2;
          if (i < _end300) {
            $bound_check(_ns, i);
            moonbitlang$core$immut$array$$Tree$eachi$194$(_ns[i], f, child_shift, start$2);
            start$2 = start$2 + (1 << shift) | 0;
            _tmp$2 = i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      } else {
        const _Some = _x;
        const _sizes = _Some;
        const child_shift = shift - 5 | 0;
        let start$2 = start;
        const _end309 = _ns.length;
        let _tmp$2 = 0;
        while (true) {
          const i = _tmp$2;
          if (i < _end309) {
            $bound_check(_ns, i);
            moonbitlang$core$immut$array$$Tree$eachi$194$(_ns[i], f, child_shift, start$2);
            const _tmp$3 = start$2;
            $bound_check(_sizes, i);
            start$2 = _tmp$3 + _sizes[i] | 0;
            _tmp$2 = i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$eachi$192$(self, f, shift, start) {
  switch (self.$tag) {
    case 0: {
      return;
    }
    case 2: {
      const _Leaf = self;
      const _l = _Leaf._0;
      const _end292 = _l.length;
      let _tmp = 0;
      while (true) {
        const i = _tmp;
        if (i < _end292) {
          const _tmp$2 = start + i | 0;
          $bound_check(_l, i);
          f(_tmp$2, _l[i]);
          _tmp = i + 1 | 0;
          continue;
        } else {
          return;
        }
      }
    }
    default: {
      const _Node = self;
      const _ns = _Node._0;
      const _x = _Node._1;
      if (_x === undefined) {
        const child_shift = shift - 5 | 0;
        let start$2 = start;
        const _end300 = _ns.length;
        let _tmp$2 = 0;
        while (true) {
          const i = _tmp$2;
          if (i < _end300) {
            $bound_check(_ns, i);
            moonbitlang$core$immut$array$$Tree$eachi$192$(_ns[i], f, child_shift, start$2);
            start$2 = start$2 + (1 << shift) | 0;
            _tmp$2 = i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      } else {
        const _Some = _x;
        const _sizes = _Some;
        const child_shift = shift - 5 | 0;
        let start$2 = start;
        const _end309 = _ns.length;
        let _tmp$2 = 0;
        while (true) {
          const i = _tmp$2;
          if (i < _end309) {
            $bound_check(_ns, i);
            moonbitlang$core$immut$array$$Tree$eachi$192$(_ns[i], f, child_shift, start$2);
            const _tmp$3 = start$2;
            $bound_check(_sizes, i);
            start$2 = _tmp$3 + _sizes[i] | 0;
            _tmp$2 = i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$eachi$191$(self, f, shift, start) {
  switch (self.$tag) {
    case 0: {
      return;
    }
    case 2: {
      const _Leaf = self;
      const _l = _Leaf._0;
      const _end292 = _l.length;
      let _tmp = 0;
      while (true) {
        const i = _tmp;
        if (i < _end292) {
          const _tmp$2 = start + i | 0;
          $bound_check(_l, i);
          f(_tmp$2, _l[i]);
          _tmp = i + 1 | 0;
          continue;
        } else {
          return;
        }
      }
    }
    default: {
      const _Node = self;
      const _ns = _Node._0;
      const _x = _Node._1;
      if (_x === undefined) {
        const child_shift = shift - 5 | 0;
        let start$2 = start;
        const _end300 = _ns.length;
        let _tmp$2 = 0;
        while (true) {
          const i = _tmp$2;
          if (i < _end300) {
            $bound_check(_ns, i);
            moonbitlang$core$immut$array$$Tree$eachi$191$(_ns[i], f, child_shift, start$2);
            start$2 = start$2 + (1 << shift) | 0;
            _tmp$2 = i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      } else {
        const _Some = _x;
        const _sizes = _Some;
        const child_shift = shift - 5 | 0;
        let start$2 = start;
        const _end309 = _ns.length;
        let _tmp$2 = 0;
        while (true) {
          const i = _tmp$2;
          if (i < _end309) {
            $bound_check(_ns, i);
            moonbitlang$core$immut$array$$Tree$eachi$191$(_ns[i], f, child_shift, start$2);
            const _tmp$3 = start$2;
            $bound_check(_sizes, i);
            start$2 = _tmp$3 + _sizes[i] | 0;
            _tmp$2 = i + 1 | 0;
            continue;
          } else {
            return;
          }
        }
      }
    }
  }
}
function moonbitlang$core$immut$array$$Tree$map$198$(self, f) {
  switch (self.$tag) {
    case 0: {
      return $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$9$;
    }
    case 2: {
      const _Leaf = self;
      const _l = _Leaf._0;
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$9$(moonbitlang$core$array$$FixedArray$map$198$(_l, f));
    }
    default: {
      const _Node = self;
      const _n = _Node._0;
      const _szs = _Node._1;
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$9$(moonbitlang$core$array$$FixedArray$makei$195$(_n.length, (i) => {
        $bound_check(_n, i);
        return moonbitlang$core$immut$array$$Tree$map$198$(_n[i], f);
      }), moonbitlang$core$immut$array$$copy_sizes(_szs));
    }
  }
}
function moonbitlang$core$immut$array$$compute_sizes$32$(children, shift) {
  const len = children.length;
  const sizes = $make_array_len_and_init(len, 0);
  let sum = 0;
  let flag = true;
  const full_subtree_size = 32 << shift;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      $bound_check(children, i);
      const sz = moonbitlang$core$immut$array$$Tree$size$32$(children[i], shift);
      flag = flag && sz === full_subtree_size;
      sum = sum + sz | 0;
      $bound_check(sizes, i);
      sizes[i] = sum;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return flag ? undefined : sizes;
}
function moonbitlang$core$immut$array$$redis$32$(old_t, node_counts, node_nums, shift) {
  const old_len = old_t.length;
  const new_t = $make_array_len_and_init(node_nums, $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$7$);
  let old_offset = 0;
  let j = 0;
  if (shift === 0) {
    let old_leaf_elems = moonbitlang$core$builtin$$Default$default$200$();
    let old_leaf_len = 0;
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < node_nums) {
        const _tmp$2 = j;
        $bound_check(old_t, _tmp$2);
        old_leaf_elems = moonbitlang$core$immut$array$$Tree$leaf_elements$32$(old_t[_tmp$2]);
        old_leaf_len = old_leaf_elems.length;
        let _tmp$3;
        if (old_offset === 0) {
          const _tmp$4 = old_leaf_len;
          $bound_check(node_counts, i);
          _tmp$3 = _tmp$4 === node_counts[i];
        } else {
          _tmp$3 = false;
        }
        if (_tmp$3) {
          const _tmp$4 = j;
          $bound_check(old_t, _tmp$4);
          $bound_check(new_t, i);
          new_t[i] = old_t[_tmp$4];
          j = j + 1 | 0;
        } else {
          let new_offset = 0;
          $bound_check(node_counts, i);
          const new_leaf_len = node_counts[i];
          const _tmp$4 = old_leaf_elems;
          $bound_check(_tmp$4, 0);
          const new_leaf_elems = $make_array_len_and_init(new_leaf_len, _tmp$4[0]);
          while (true) {
            if (new_offset < new_leaf_len) {
              const _tmp$5 = j;
              $bound_check(old_t, _tmp$5);
              old_leaf_elems = moonbitlang$core$immut$array$$Tree$leaf_elements$32$(old_t[_tmp$5]);
              old_leaf_len = old_leaf_elems.length;
              if (j < old_len) {
                const _p = new_leaf_len - new_offset | 0;
                const _p$2 = old_leaf_len - old_offset | 0;
                const remaining = _p < _p$2 ? _p : _p$2;
                moonbitlang$core$array$$FixedArray$unsafe_blit$32$(new_leaf_elems, new_offset, old_leaf_elems, old_offset, remaining);
                new_offset = new_offset + remaining | 0;
                old_offset = old_offset + remaining | 0;
                if (old_offset === old_leaf_len) {
                  j = j + 1 | 0;
                  old_offset = 0;
                }
              } else {
                $panic();
              }
              continue;
            } else {
              break;
            }
          }
          $bound_check(new_t, i);
          new_t[i] = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$7$(new_leaf_elems);
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  } else {
    let old_node_chldrn = moonbitlang$core$builtin$$Default$default$201$();
    let old_node_len = 0;
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < node_nums) {
        const _tmp$2 = j;
        $bound_check(old_t, _tmp$2);
        old_node_chldrn = moonbitlang$core$immut$array$$Tree$node_children$32$(old_t[_tmp$2]);
        old_node_len = old_node_chldrn.length;
        let _tmp$3;
        if (old_offset === 0) {
          const _tmp$4 = old_node_len;
          $bound_check(node_counts, i);
          _tmp$3 = _tmp$4 === node_counts[i];
        } else {
          _tmp$3 = false;
        }
        if (_tmp$3) {
          const _tmp$4 = j;
          $bound_check(old_t, _tmp$4);
          $bound_check(new_t, i);
          new_t[i] = old_t[_tmp$4];
          j = j + 1 | 0;
        } else {
          let new_offset = 0;
          $bound_check(node_counts, i);
          const new_node_len = node_counts[i];
          const _tmp$4 = old_node_chldrn;
          $bound_check(_tmp$4, 0);
          const new_node_chldrn = $make_array_len_and_init(new_node_len, _tmp$4[0]);
          while (true) {
            if (new_offset < new_node_len) {
              const _tmp$5 = j;
              $bound_check(old_t, _tmp$5);
              old_node_chldrn = moonbitlang$core$immut$array$$Tree$node_children$32$(old_t[_tmp$5]);
              old_node_len = old_node_chldrn.length;
              if (j < old_len) {
                const _p = new_node_len - new_offset | 0;
                const _p$2 = old_node_len - old_offset | 0;
                const remaining = _p < _p$2 ? _p : _p$2;
                moonbitlang$core$array$$FixedArray$unsafe_blit$31$(new_node_chldrn, new_offset, old_node_chldrn, old_offset, remaining);
                new_offset = new_offset + remaining | 0;
                old_offset = old_offset + remaining | 0;
                if (old_offset === old_node_len) {
                  j = j + 1 | 0;
                  old_offset = 0;
                }
              } else {
                $panic();
              }
              continue;
            } else {
              break;
            }
          }
          $bound_check(new_t, i);
          new_t[i] = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(new_node_chldrn, moonbitlang$core$immut$array$$compute_sizes$32$(new_node_chldrn, shift - 5 | 0));
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  }
  return new_t;
}
function moonbitlang$core$immut$array$$redis_plan$32$(t) {
  const node_counts = moonbitlang$core$array$$FixedArray$makei$193$(t.length, (i) => {
    $bound_check(t, i);
    return moonbitlang$core$immut$array$$Tree$local_size$32$(t[i]);
  });
  const total_nodes = moonbitlang$core$array$$FixedArray$fold$199$(node_counts, 0, (acc, x) => acc + x | 0);
  const opt_len = ((total_nodes + 32 | 0) - 1 | 0) / 32 | 0;
  let new_len = t.length;
  let i = 0;
  while (true) {
    if ((opt_len + 1 | 0) < new_len) {
      while (true) {
        const _tmp = i;
        $bound_check(node_counts, _tmp);
        if (node_counts[_tmp] > 31) {
          i = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const _tmp = i;
      $bound_check(node_counts, _tmp);
      let remaining_nodes = node_counts[_tmp];
      while (true) {
        if (remaining_nodes > 0) {
          const _tmp$2 = remaining_nodes;
          const _tmp$3 = i + 1 | 0;
          $bound_check(node_counts, _tmp$3);
          const _p = _tmp$2 + node_counts[_tmp$3] | 0;
          const _p$2 = 32;
          const min_size = _p < _p$2 ? _p : _p$2;
          const _tmp$4 = i;
          $bound_check(node_counts, _tmp$4);
          node_counts[_tmp$4] = min_size;
          const _tmp$5 = remaining_nodes;
          const _tmp$6 = i + 1 | 0;
          $bound_check(node_counts, _tmp$6);
          remaining_nodes = (_tmp$5 + node_counts[_tmp$6] | 0) - min_size | 0;
          i = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const _start212 = i;
      const _end213 = new_len - 1 | 0;
      let _tmp$2 = _start212;
      while (true) {
        const j = _tmp$2;
        if (j < _end213) {
          const _tmp$3 = j + 1 | 0;
          $bound_check(node_counts, _tmp$3);
          $bound_check(node_counts, j);
          node_counts[j] = node_counts[_tmp$3];
          _tmp$2 = j + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      new_len = new_len - 1 | 0;
      i = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: node_counts, _1: new_len };
}
function moonbitlang$core$immut$array$$tri_merge$46$get_children$47$4097(self) {
  switch (self.$tag) {
    case 1: {
      const _Node = self;
      return _Node._0;
    }
    case 0: {
      return [];
    }
    default: {
      return moonbitlang$core$builtin$$abort$46$("Unreachable", "@moonbitlang/core/immut/array:tree.mbt:536:18-536:38");
    }
  }
}
function moonbitlang$core$immut$array$$tri_merge$32$(left, center, right) {
  if (moonbitlang$core$immut$array$$Tree$is_leaf$32$(left) || (!moonbitlang$core$immut$array$$Tree$is_node$32$(center) || moonbitlang$core$immut$array$$Tree$is_leaf$32$(right))) {
    moonbitlang$core$builtin$$abort$15$("Unreachable: input to merge is invalid", "@moonbitlang/core/immut/array:tree.mbt:530:5-530:52");
  }
  const left_children = moonbitlang$core$immut$array$$tri_merge$46$get_children$47$4097(left);
  const center_children = moonbitlang$core$immut$array$$tri_merge$46$get_children$47$4097(center);
  const right_children = moonbitlang$core$immut$array$$tri_merge$46$get_children$47$4097(right);
  const left_len = left_children.length;
  const left_len$2 = left_len === 0 ? 0 : left_len - 1 | 0;
  const center_len = center_children.length;
  const right_len = right_children.length;
  const right_len$2 = right_len === 0 ? 0 : right_len - 1 | 0;
  return moonbitlang$core$array$$FixedArray$makei$197$((left_len$2 + center_len | 0) + right_len$2 | 0, (i) => {
    if (i < left_len$2) {
      $bound_check(left_children, i);
      return left_children[i];
    } else {
      if (i < (left_len$2 + center_len | 0)) {
        const _tmp = i - left_len$2 | 0;
        $bound_check(center_children, _tmp);
        return center_children[_tmp];
      } else {
        if (right_len$2 > 0) {
          const _tmp = ((1 + i | 0) - left_len$2 | 0) - center_len | 0;
          $bound_check(right_children, _tmp);
          return right_children[_tmp];
        } else {
          return moonbitlang$core$builtin$$abort$31$("Unreachable", "@moonbitlang/core/immut/array:tree.mbt:555:5-555:25");
        }
      }
    }
  });
}
function moonbitlang$core$immut$array$$rebalance$32$(left, center, right, shift, top) {
  const t = moonbitlang$core$immut$array$$tri_merge$32$(left, center, right);
  const _bind = moonbitlang$core$immut$array$$redis_plan$32$(t);
  const _nc = _bind._0;
  const _nc_len = _bind._1;
  const new_t = moonbitlang$core$immut$array$$redis$32$(t, _nc, _nc_len, shift - 5 | 0);
  if (new_t.length === _nc_len) {
    if (_nc_len <= 32) {
      const node = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(new_t, moonbitlang$core$immut$array$$compute_sizes$32$(new_t, shift - 5 | 0));
      if (!top) {
        const _bind$2 = [node];
        return { _0: new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(moonbitlang$core$array$$FixedArray$from_array$31$({ buf: _bind$2, start: 0, end: 1 }), undefined), _1: shift + 5 | 0 };
      } else {
        return { _0: node, _1: shift };
      }
    } else {
      const _p = 32;
      let new_child_1;
      if (_p <= 0) {
        new_child_1 = [];
      } else {
        const _p$2 = 0;
        $bound_check(new_t, _p$2);
        const _p$3 = $make_array_len_and_init(_p, new_t[_p$2]);
        let _tmp = 1;
        while (true) {
          const _p$4 = _tmp;
          if (_p$4 < _p) {
            $bound_check(new_t, _p$4);
            $bound_check(_p$3, _p$4);
            _p$3[_p$4] = new_t[_p$4];
            _tmp = _p$4 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        new_child_1 = _p$3;
      }
      const _p$2 = new_t.length - 32 | 0;
      let new_child_2;
      if (_p$2 <= 0) {
        new_child_2 = [];
      } else {
        const _p$3 = 0;
        const _tmp = _p$3 + 32 | 0;
        $bound_check(new_t, _tmp);
        const _p$4 = $make_array_len_and_init(_p$2, new_t[_tmp]);
        let _tmp$2 = 1;
        while (true) {
          const _p$5 = _tmp$2;
          if (_p$5 < _p$2) {
            const _tmp$3 = _p$5 + 32 | 0;
            $bound_check(new_t, _tmp$3);
            $bound_check(_p$4, _p$5);
            _p$4[_p$5] = new_t[_tmp$3];
            _tmp$2 = _p$5 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        new_child_2 = _p$4;
      }
      const new_node_1 = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(new_child_1, moonbitlang$core$immut$array$$compute_sizes$32$(new_child_1, shift - 5 | 0));
      const new_node_2 = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(new_child_2, moonbitlang$core$immut$array$$compute_sizes$32$(new_child_2, shift - 5 | 0));
      const _bind$2 = [new_node_1, new_node_2];
      const new_children = moonbitlang$core$array$$FixedArray$from_array$31$({ buf: _bind$2, start: 0, end: 2 });
      return { _0: new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(new_children, moonbitlang$core$immut$array$$compute_sizes$32$(new_children, shift)), _1: shift + 5 | 0 };
    }
  } else {
    return $panic();
  }
}
function moonbitlang$core$immut$array$$Tree$concat$32$(left, left_shift, right, right_shift, top) {
  if (left_shift > right_shift) {
    const _bind = moonbitlang$core$immut$array$$Tree$concat$32$(moonbitlang$core$immut$array$$Tree$right_child$32$(left), left_shift - 5 | 0, right, right_shift, false);
    const _c = _bind._0;
    const _c_shift = _bind._1;
    return _c_shift === left_shift ? moonbitlang$core$immut$array$$rebalance$32$(left, _c, $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$7$, left_shift, top) : $panic();
  } else {
    if (right_shift > left_shift) {
      const _bind = moonbitlang$core$immut$array$$Tree$concat$32$(left, left_shift, moonbitlang$core$immut$array$$Tree$left_child$32$(right), right_shift - 5 | 0, false);
      const _c = _bind._0;
      const _c_shift = _bind._1;
      return _c_shift === right_shift ? moonbitlang$core$immut$array$$rebalance$32$($64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$7$, _c, right, right_shift, top) : $panic();
    } else {
      if (left_shift === 0) {
        const left_elems = moonbitlang$core$immut$array$$Tree$leaf_elements$32$(left);
        const right_elems = moonbitlang$core$immut$array$$Tree$leaf_elements$32$(right);
        const left_len = left_elems.length;
        const right_len = right_elems.length;
        const len = left_len + right_len | 0;
        if (top && len <= 32) {
          let _tmp;
          if (len <= 0) {
            _tmp = [];
          } else {
            const _p = 0;
            let _tmp$2;
            if (_p < left_len) {
              $bound_check(left_elems, _p);
              _tmp$2 = left_elems[_p];
            } else {
              const _tmp$3 = _p - left_len | 0;
              $bound_check(right_elems, _tmp$3);
              _tmp$2 = right_elems[_tmp$3];
            }
            const _p$2 = $make_array_len_and_init(len, _tmp$2);
            let _tmp$3 = 1;
            while (true) {
              const _p$3 = _tmp$3;
              if (_p$3 < len) {
                let _tmp$4;
                if (_p$3 < left_len) {
                  $bound_check(left_elems, _p$3);
                  _tmp$4 = left_elems[_p$3];
                } else {
                  const _tmp$5 = _p$3 - left_len | 0;
                  $bound_check(right_elems, _tmp$5);
                  _tmp$4 = right_elems[_tmp$5];
                }
                $bound_check(_p$2, _p$3);
                _p$2[_p$3] = _tmp$4;
                _tmp$3 = _p$3 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            _tmp = _p$2;
          }
          return { _0: new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$7$(_tmp), _1: 0 };
        } else {
          const _bind = [left, right];
          const _bind$2 = [left_len, len];
          return { _0: new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(moonbitlang$core$array$$FixedArray$from_array$31$({ buf: _bind, start: 0, end: 2 }), moonbitlang$core$array$$FixedArray$from_array$17$({ buf: _bind$2, start: 0, end: 2 })), _1: 5 };
        }
      } else {
        const _bind = moonbitlang$core$immut$array$$Tree$concat$32$(moonbitlang$core$immut$array$$Tree$right_child$32$(left), left_shift - 5 | 0, moonbitlang$core$immut$array$$Tree$left_child$32$(right), right_shift - 5 | 0, false);
        const _c = _bind._0;
        const _c_shift = _bind._1;
        return _c_shift === left_shift ? (_c_shift === right_shift ? moonbitlang$core$immut$array$$rebalance$32$(left, _c, right, left_shift, top) : $panic()) : $panic();
      }
    }
  }
}
function moonbitlang$core$immut$array$$T$new$65$() {
  return { tree: $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$6$, size: 0, shift: 0 };
}
function moonbitlang$core$immut$array$$T$new$32$() {
  return { tree: $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$7$, size: 0, shift: 0 };
}
function moonbitlang$core$immut$array$$from_leaves$27$(leaves, cap) {
  if (cap === 32) {
    return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$9$(moonbitlang$core$array$$ArrayView$at$37$(leaves, 0));
  } else {
    if ((leaves.end - leaves.start | 0) <= 32) {
      const arr = $make_array_len_and_init(leaves.end - leaves.start | 0, $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$9$);
      const _end11 = leaves.end - leaves.start | 0;
      let _tmp = 0;
      while (true) {
        const i = _tmp;
        if (i < _end11) {
          $bound_check(arr, i);
          arr[i] = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$9$(moonbitlang$core$array$$ArrayView$at$37$(leaves, i));
          _tmp = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$9$(arr, undefined);
    } else {
      const len = Math.imul(leaves.end - leaves.start | 0, 32) | 0;
      const child_cap = cap / 32 | 0;
      const quot = len / child_cap | 0;
      const rem = len % child_cap | 0;
      const times = child_cap / 32 | 0;
      let arr;
      if (rem === 0) {
        arr = moonbitlang$core$array$$FixedArray$makei$195$(quot, (i) => moonbitlang$core$immut$array$$from_leaves$27$(moonbitlang$core$array$$ArrayView$sub$46$inner$37$(leaves, Math.imul(i, times) | 0, Math.imul(i + 1 | 0, times) | 0), child_cap));
      } else {
        const arr$2 = $make_array_len_and_init(quot + 1 | 0, $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$9$);
        let _tmp = 0;
        while (true) {
          const i = _tmp;
          if (i < quot) {
            $bound_check(arr$2, i);
            arr$2[i] = moonbitlang$core$immut$array$$from_leaves$27$(moonbitlang$core$array$$ArrayView$sub$46$inner$37$(leaves, Math.imul(i, times) | 0, Math.imul(i + 1 | 0, times) | 0), child_cap);
            _tmp = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        $bound_check(arr$2, quot);
        arr$2[quot] = moonbitlang$core$immut$array$$from_leaves$27$(moonbitlang$core$array$$ArrayView$sub$46$inner$37$(leaves, Math.imul(times, quot) | 0, undefined), child_cap);
        arr = arr$2;
      }
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$9$(arr, undefined);
    }
  }
}
function moonbitlang$core$immut$array$$from_leaves$28$(leaves, cap) {
  if (cap === 32) {
    return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$8$(moonbitlang$core$array$$ArrayView$at$39$(leaves, 0));
  } else {
    if ((leaves.end - leaves.start | 0) <= 32) {
      const arr = $make_array_len_and_init(leaves.end - leaves.start | 0, $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$8$);
      const _end11 = leaves.end - leaves.start | 0;
      let _tmp = 0;
      while (true) {
        const i = _tmp;
        if (i < _end11) {
          $bound_check(arr, i);
          arr[i] = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$8$(moonbitlang$core$array$$ArrayView$at$39$(leaves, i));
          _tmp = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$(arr, undefined);
    } else {
      const len = Math.imul(leaves.end - leaves.start | 0, 32) | 0;
      const child_cap = cap / 32 | 0;
      const quot = len / child_cap | 0;
      const rem = len % child_cap | 0;
      const times = child_cap / 32 | 0;
      let arr;
      if (rem === 0) {
        arr = moonbitlang$core$array$$FixedArray$makei$196$(quot, (i) => moonbitlang$core$immut$array$$from_leaves$28$(moonbitlang$core$array$$ArrayView$sub$46$inner$39$(leaves, Math.imul(i, times) | 0, Math.imul(i + 1 | 0, times) | 0), child_cap));
      } else {
        const arr$2 = $make_array_len_and_init(quot + 1 | 0, $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$8$);
        let _tmp = 0;
        while (true) {
          const i = _tmp;
          if (i < quot) {
            $bound_check(arr$2, i);
            arr$2[i] = moonbitlang$core$immut$array$$from_leaves$28$(moonbitlang$core$array$$ArrayView$sub$46$inner$39$(leaves, Math.imul(i, times) | 0, Math.imul(i + 1 | 0, times) | 0), child_cap);
            _tmp = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        $bound_check(arr$2, quot);
        arr$2[quot] = moonbitlang$core$immut$array$$from_leaves$28$(moonbitlang$core$array$$ArrayView$sub$46$inner$39$(leaves, Math.imul(times, quot) | 0, undefined), child_cap);
        arr = arr$2;
      }
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$8$(arr, undefined);
    }
  }
}
function moonbitlang$core$immut$array$$from_leaves$32$(leaves, cap) {
  if (cap === 32) {
    return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$7$(moonbitlang$core$array$$ArrayView$at$44$(leaves, 0));
  } else {
    if ((leaves.end - leaves.start | 0) <= 32) {
      const arr = $make_array_len_and_init(leaves.end - leaves.start | 0, $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$7$);
      const _end11 = leaves.end - leaves.start | 0;
      let _tmp = 0;
      while (true) {
        const i = _tmp;
        if (i < _end11) {
          $bound_check(arr, i);
          arr[i] = new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Leaf$7$(moonbitlang$core$array$$ArrayView$at$44$(leaves, i));
          _tmp = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(arr, undefined);
    } else {
      const len = Math.imul(leaves.end - leaves.start | 0, 32) | 0;
      const child_cap = cap / 32 | 0;
      const quot = len / child_cap | 0;
      const rem = len % child_cap | 0;
      const times = child_cap / 32 | 0;
      let arr;
      if (rem === 0) {
        arr = moonbitlang$core$array$$FixedArray$makei$197$(quot, (i) => moonbitlang$core$immut$array$$from_leaves$32$(moonbitlang$core$array$$ArrayView$sub$46$inner$44$(leaves, Math.imul(i, times) | 0, Math.imul(i + 1 | 0, times) | 0), child_cap));
      } else {
        const arr$2 = $make_array_len_and_init(quot + 1 | 0, $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$7$);
        let _tmp = 0;
        while (true) {
          const i = _tmp;
          if (i < quot) {
            $bound_check(arr$2, i);
            arr$2[i] = moonbitlang$core$immut$array$$from_leaves$32$(moonbitlang$core$array$$ArrayView$sub$46$inner$44$(leaves, Math.imul(i, times) | 0, Math.imul(i + 1 | 0, times) | 0), child_cap);
            _tmp = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        $bound_check(arr$2, quot);
        arr$2[quot] = moonbitlang$core$immut$array$$from_leaves$32$(moonbitlang$core$array$$ArrayView$sub$46$inner$44$(leaves, Math.imul(times, quot) | 0, undefined), child_cap);
        arr = arr$2;
      }
      return new $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Node$7$(arr, undefined);
    }
  }
}
function moonbitlang$core$immut$array$$shift_cap_of_size(size) {
  let cap = 32;
  let depth = 0;
  while (true) {
    if (cap < size) {
      cap = Math.imul(cap, 32) | 0;
      depth = depth + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const shift = Math.imul(5, depth) | 0;
  return { _0: shift, _1: cap };
}
function moonbitlang$core$immut$array$$T$makei$191$(len, f) {
  const quot = len / 32 | 0;
  const rem = len % 32 | 0;
  let leaves;
  if (rem === 0) {
    if (quot <= 0) {
      leaves = [];
    } else {
      const _p = new Array(quot);
      let _tmp = 0;
      while (true) {
        const _p$2 = _tmp;
        if (_p$2 < quot) {
          _p[_p$2] = moonbitlang$core$array$$FixedArray$makei$191$(32, (_p$3) => f((Math.imul(_p$2, 32) | 0) + _p$3 | 0));
          _tmp = _p$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      leaves = _p;
    }
  } else {
    const arr = moonbitlang$core$array$$Array$make$37$(quot + 1 | 0, []);
    let _tmp = 0;
    while (true) {
      const k = _tmp;
      if (k < quot) {
        moonbitlang$core$array$$Array$set$37$(arr, k, moonbitlang$core$array$$FixedArray$makei$191$(32, (i) => f((Math.imul(k, 32) | 0) + i | 0)));
        _tmp = k + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$array$$Array$set$37$(arr, quot, moonbitlang$core$array$$FixedArray$makei$191$(rem, (i) => f((Math.imul(quot, 32) | 0) + i | 0)));
    leaves = arr;
  }
  const _bind = moonbitlang$core$immut$array$$shift_cap_of_size(len);
  const _shift = _bind._0;
  const _cap = _bind._1;
  const tree = len === 0 ? $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$9$ : moonbitlang$core$immut$array$$from_leaves$27$({ buf: leaves, start: 0, end: leaves.length }, _cap);
  return { tree: tree, size: len, shift: _shift };
}
function moonbitlang$core$immut$array$$T$makei$192$(len, f) {
  const quot = len / 32 | 0;
  const rem = len % 32 | 0;
  let leaves;
  if (rem === 0) {
    if (quot <= 0) {
      leaves = [];
    } else {
      const _p = new Array(quot);
      let _tmp = 0;
      while (true) {
        const _p$2 = _tmp;
        if (_p$2 < quot) {
          _p[_p$2] = moonbitlang$core$array$$FixedArray$makei$192$(32, (_p$3) => f((Math.imul(_p$2, 32) | 0) + _p$3 | 0));
          _tmp = _p$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      leaves = _p;
    }
  } else {
    const arr = moonbitlang$core$array$$Array$make$39$(quot + 1 | 0, []);
    let _tmp = 0;
    while (true) {
      const k = _tmp;
      if (k < quot) {
        moonbitlang$core$array$$Array$set$39$(arr, k, moonbitlang$core$array$$FixedArray$makei$192$(32, (i) => f((Math.imul(k, 32) | 0) + i | 0)));
        _tmp = k + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$array$$Array$set$39$(arr, quot, moonbitlang$core$array$$FixedArray$makei$192$(rem, (i) => f((Math.imul(quot, 32) | 0) + i | 0)));
    leaves = arr;
  }
  const _bind = moonbitlang$core$immut$array$$shift_cap_of_size(len);
  const _shift = _bind._0;
  const _cap = _bind._1;
  const tree = len === 0 ? $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$8$ : moonbitlang$core$immut$array$$from_leaves$28$({ buf: leaves, start: 0, end: leaves.length }, _cap);
  return { tree: tree, size: len, shift: _shift };
}
function moonbitlang$core$immut$array$$T$makei$194$(len, f) {
  const quot = len / 32 | 0;
  const rem = len % 32 | 0;
  let leaves;
  if (rem === 0) {
    if (quot <= 0) {
      leaves = [];
    } else {
      const _p = new Array(quot);
      let _tmp = 0;
      while (true) {
        const _p$2 = _tmp;
        if (_p$2 < quot) {
          _p[_p$2] = moonbitlang$core$array$$FixedArray$makei$194$(32, (_p$3) => f((Math.imul(_p$2, 32) | 0) + _p$3 | 0));
          _tmp = _p$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      leaves = _p;
    }
  } else {
    const arr = moonbitlang$core$array$$Array$make$44$(quot + 1 | 0, []);
    let _tmp = 0;
    while (true) {
      const k = _tmp;
      if (k < quot) {
        moonbitlang$core$array$$Array$set$44$(arr, k, moonbitlang$core$array$$FixedArray$makei$194$(32, (i) => f((Math.imul(k, 32) | 0) + i | 0)));
        _tmp = k + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$array$$Array$set$44$(arr, quot, moonbitlang$core$array$$FixedArray$makei$194$(rem, (i) => f((Math.imul(quot, 32) | 0) + i | 0)));
    leaves = arr;
  }
  const _bind = moonbitlang$core$immut$array$$shift_cap_of_size(len);
  const _shift = _bind._0;
  const _cap = _bind._1;
  const tree = len === 0 ? $64$moonbitlang$47$core$47$immut$47$array$46$Tree$Empty$7$ : moonbitlang$core$immut$array$$from_leaves$32$({ buf: leaves, start: 0, end: leaves.length }, _cap);
  return { tree: tree, size: len, shift: _shift };
}
function moonbitlang$core$immut$array$$T$from_array$27$(arr) {
  return moonbitlang$core$immut$array$$T$makei$191$(arr.end - arr.start | 0, (i) => moonbitlang$core$array$$ArrayView$at$27$(arr, i));
}
function moonbitlang$core$immut$array$$T$from_array$28$(arr) {
  return moonbitlang$core$immut$array$$T$makei$192$(arr.end - arr.start | 0, (i) => moonbitlang$core$array$$ArrayView$at$28$(arr, i));
}
function moonbitlang$core$immut$array$$T$from_array$32$(arr) {
  return moonbitlang$core$immut$array$$T$makei$194$(arr.end - arr.start | 0, (i) => moonbitlang$core$array$$ArrayView$at$32$(arr, i));
}
function moonbitlang$core$immut$array$$T$at$32$(self, index) {
  return index === 0 ? moonbitlang$core$immut$array$$Tree$get_first$32$(self.tree) : index === (self.size - 1 | 0) ? moonbitlang$core$immut$array$$Tree$get_last$32$(self.tree) : moonbitlang$core$immut$array$$Tree$get$32$(self.tree, index, self.shift);
}
function moonbitlang$core$immut$array$$T$at$28$(self, index) {
  return index === 0 ? moonbitlang$core$immut$array$$Tree$get_first$28$(self.tree) : index === (self.size - 1 | 0) ? moonbitlang$core$immut$array$$Tree$get_last$28$(self.tree) : moonbitlang$core$immut$array$$Tree$get$28$(self.tree, index, self.shift);
}
function moonbitlang$core$immut$array$$T$at$27$(self, index) {
  return index === 0 ? moonbitlang$core$immut$array$$Tree$get_first$27$(self.tree) : index === (self.size - 1 | 0) ? moonbitlang$core$immut$array$$Tree$get_last$27$(self.tree) : moonbitlang$core$immut$array$$Tree$get$27$(self.tree, index, self.shift);
}
function moonbitlang$core$immut$array$$T$eachi$194$(self, f) {
  moonbitlang$core$immut$array$$Tree$eachi$194$(self.tree, f, self.shift, 0);
}
function moonbitlang$core$immut$array$$T$eachi$192$(self, f) {
  moonbitlang$core$immut$array$$Tree$eachi$192$(self.tree, f, self.shift, 0);
}
function moonbitlang$core$immut$array$$T$eachi$191$(self, f) {
  moonbitlang$core$immut$array$$Tree$eachi$191$(self.tree, f, self.shift, 0);
}
function moonbitlang$core$immut$array$$T$to_array$32$(self) {
  if (self.size === 0) {
    return [];
  } else {
    const arr = moonbitlang$core$array$$Array$make$32$(self.size, moonbitlang$core$immut$array$$T$at$32$(self, 0));
    moonbitlang$core$immut$array$$T$eachi$194$(self, (i, v) => {
      moonbitlang$core$array$$Array$set$32$(arr, i, v);
    });
    return arr;
  }
}
function moonbitlang$core$immut$array$$T$to_array$28$(self) {
  if (self.size === 0) {
    return [];
  } else {
    const arr = moonbitlang$core$array$$Array$make$28$(self.size, moonbitlang$core$immut$array$$T$at$28$(self, 0));
    moonbitlang$core$immut$array$$T$eachi$192$(self, (i, v) => {
      moonbitlang$core$array$$Array$set$28$(arr, i, v);
    });
    return arr;
  }
}
function moonbitlang$core$immut$array$$T$to_array$27$(self) {
  if (self.size === 0) {
    return [];
  } else {
    const arr = moonbitlang$core$array$$Array$make$27$(self.size, moonbitlang$core$immut$array$$T$at$27$(self, 0));
    moonbitlang$core$immut$array$$T$eachi$191$(self, (i, v) => {
      moonbitlang$core$array$$Array$set$27$(arr, i, v);
    });
    return arr;
  }
}
function moonbitlang$core$immut$array$$T$push$65$(self, value) {
  const _bind = moonbitlang$core$immut$array$$Tree$push_end$65$(self.tree, self.shift, value);
  const _tree = _bind._0;
  const _shift = _bind._1;
  return { tree: _tree, size: self.size + 1 | 0, shift: _shift };
}
function moonbitlang$core$immut$array$$T$push$32$(self, value) {
  const _bind = moonbitlang$core$immut$array$$Tree$push_end$32$(self.tree, self.shift, value);
  const _tree = _bind._0;
  const _shift = _bind._1;
  return { tree: _tree, size: self.size + 1 | 0, shift: _shift };
}
function moonbitlang$core$immut$array$$T$push$28$(self, value) {
  const _bind = moonbitlang$core$immut$array$$Tree$push_end$28$(self.tree, self.shift, value);
  const _tree = _bind._0;
  const _shift = _bind._1;
  return { tree: _tree, size: self.size + 1 | 0, shift: _shift };
}
function moonbitlang$core$immut$array$$T$concat$32$(self, other) {
  if (self.size === 0) {
    return other;
  }
  if (other.size === 0) {
    return self;
  }
  const _bind = moonbitlang$core$immut$array$$Tree$concat$32$(self.tree, self.shift, other.tree, other.shift, true);
  const _tree = _bind._0;
  const _shift = _bind._1;
  return { tree: _tree, size: self.size + other.size | 0, shift: _shift };
}
function moonbitlang$core$builtin$$Add$add$238$(self, other) {
  return moonbitlang$core$immut$array$$T$concat$32$(self, other);
}
function moonbitlang$core$immut$array$$T$iter$65$(self) {
  return moonbitlang$core$immut$array$$Tree$iter$65$(self.tree);
}
function moonbitlang$core$immut$array$$T$map$198$(self, f) {
  return { tree: moonbitlang$core$immut$array$$Tree$map$198$(self.tree, f), size: self.size, shift: self.shift };
}
function moonbitlang$core$builtin$$Eq$equal$239$(_x_469, _x_470) {
  let _tmp = _x_469;
  let _tmp$2 = _x_470;
  while (true) {
    const _x_469$2 = _tmp;
    const _x_470$2 = _tmp$2;
    if (_x_469$2.$tag === 0) {
      if (_x_470$2.$tag === 0) {
        return true;
      } else {
        return false;
      }
    } else {
      const _More = _x_469$2;
      const _$42$x0_471 = _More._0;
      const _$42$x1_472 = _More._1;
      if (_x_470$2.$tag === 1) {
        const _More$2 = _x_470$2;
        const _$42$y0_473 = _More$2._0;
        const _$42$y1_474 = _More$2._1;
        if (moonbitlang$core$builtin$$Eq$equal$86$(_$42$x0_471, _$42$y0_473)) {
          _tmp = _$42$x1_472;
          _tmp$2 = _$42$y1_474;
          continue;
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$list$$List$iter$86$(self) {
  const next = { val: self };
  const _p = () => {
    const _bind = next.val;
    if (_bind.$tag === 0) {
      return undefined;
    } else {
      const _More = _bind;
      const _head = _More._0;
      const _tail = _More._1;
      next.val = _tail;
      return _head;
    }
  };
  return _p;
}
function moonbitlang$core$list$$List$iter$171$(self) {
  const next = { val: self };
  const _p = () => {
    const _bind = next.val;
    if (_bind.$tag === 0) {
      return undefined;
    } else {
      const _More = _bind;
      const _head = _More._0;
      const _tail = _More._1;
      next.val = _tail;
      return _head;
    }
  };
  return _p;
}
function moonbitlang$core$list$$List$iter$140$(self) {
  const next = { val: self };
  const _p = () => {
    const _bind = next.val;
    if (_bind.$tag === 0) {
      return undefined;
    } else {
      const _More = _bind;
      const _head = _More._0;
      const _tail = _More._1;
      next.val = _tail;
      return _head;
    }
  };
  return _p;
}
function moonbitlang$core$list$$List$to_array$154$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$154$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$to_array$155$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$155$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$to_array$131$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$131$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$to_array$156$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$156$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$to_array$13$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$13$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$to_array$157$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$157$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$to_array$158$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$158$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$to_array$51$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$51$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$to_array$159$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$159$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$to_array$160$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _More = self;
    const _x = _More._0;
    const _xs = _More._1;
    const arr = [_x];
    let _tmp = _xs;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _More$2 = _param;
        const _x$2 = _More$2._0;
        const _xs$2 = _More$2._1;
        moonbitlang$core$array$$Array$push$160$(arr, _x$2);
        _tmp = _xs$2;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$list$$List$unsafe_head$20$(self) {
  if (self.$tag === 0) {
    return moonbitlang$core$builtin$$abort$20$("head of empty list", "@moonbitlang/core/list:list.mbt:435:14-435:41");
  } else {
    const _More = self;
    return _More._0;
  }
}
function moonbitlang$core$list$$List$unsafe_head$43$(self) {
  if (self.$tag === 0) {
    return moonbitlang$core$builtin$$abort$43$("head of empty list", "@moonbitlang/core/list:list.mbt:435:14-435:41");
  } else {
    const _More = self;
    return _More._0;
  }
}
function moonbitlang$core$list$$List$unsafe_tail$20$(self) {
  if (self.$tag === 0) {
    return moonbitlang$core$builtin$$abort$19$("tail of empty list", "@moonbitlang/core/list:list.mbt:461:14-461:41");
  } else {
    const _More = self;
    return _More._1;
  }
}
function moonbitlang$core$list$$List$unsafe_tail$43$(self) {
  if (self.$tag === 0) {
    return moonbitlang$core$builtin$$abort$42$("tail of empty list", "@moonbitlang/core/list:list.mbt:461:14-461:41");
  } else {
    const _More = self;
    return _More._1;
  }
}
function moonbitlang$core$list$$List$contains$86$(self, value) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (_param.$tag === 0) {
      return false;
    } else {
      const _More = _param;
      const _x = _More._0;
      const _xs = _More._1;
      if (moonbitlang$core$builtin$$Eq$equal$86$(_x, value)) {
        return true;
      } else {
        _tmp = _xs;
        continue;
      }
    }
  }
}
function moonbitlang$core$list$$List$drop$20$(self, n) {
  if (n <= 0) {
    return self;
  } else {
    let _tmp = n;
    let _tmp$2 = self;
    while (true) {
      const _param_0 = _tmp;
      const _param_1 = _tmp$2;
      if (_param_1.$tag === 0) {
        return $64$moonbitlang$47$core$47$list$46$List$Empty$10$;
      } else {
        if (_param_0 === 1) {
          const _More = _param_1;
          return _More._1;
        } else {
          const _More = _param_1;
          const _xs = _More._1;
          _tmp = _param_0 - 1 | 0;
          _tmp$2 = _xs;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$list$$List$drop$43$(self, n) {
  if (n <= 0) {
    return self;
  } else {
    let _tmp = n;
    let _tmp$2 = self;
    while (true) {
      const _param_0 = _tmp;
      const _param_1 = _tmp$2;
      if (_param_1.$tag === 0) {
        return $64$moonbitlang$47$core$47$list$46$List$Empty$17$;
      } else {
        if (_param_0 === 1) {
          const _More = _param_1;
          return _More._1;
        } else {
          const _More = _param_1;
          const _xs = _More._1;
          _tmp = _param_0 - 1 | 0;
          _tmp$2 = _xs;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$list$$List$iter2$171$(self) {
  const i = { val: 0 };
  const next = { val: self };
  return moonbitlang$core$builtin$$Iter2$new$127$(() => {
    const _bind = next.val;
    if (_bind.$tag === 0) {
      return undefined;
    } else {
      const _More = _bind;
      const _head = _More._0;
      const _tail = _More._1;
      const result = { _0: i.val, _1: _head };
      next.val = _tail;
      i.val = i.val + 1 | 0;
      return result;
    }
  });
}
function moonbitlang$core$immut$sorted_map$$SortedMap$length$240$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Tree = self;
    return _Tree._2;
  }
}
function moonbitlang$core$immut$sorted_map$$SortedMap$length$241$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Tree = self;
    return _Tree._2;
  }
}
function moonbitlang$core$immut$sorted_map$$make_tree$240$(key, value, l, r) {
  const size = (moonbitlang$core$immut$sorted_map$$SortedMap$length$240$(l) + moonbitlang$core$immut$sorted_map$$SortedMap$length$240$(r) | 0) + 1 | 0;
  return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Tree$25$(key, value, size, l, r);
}
function moonbitlang$core$immut$sorted_map$$make_tree$241$(key, value, l, r) {
  const size = (moonbitlang$core$immut$sorted_map$$SortedMap$length$241$(l) + moonbitlang$core$immut$sorted_map$$SortedMap$length$241$(r) | 0) + 1 | 0;
  return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Tree$26$(key, value, size, l, r);
}
function moonbitlang$core$immut$sorted_map$$SortedMap$get$240$(self, key) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (_param.$tag === 0) {
      return undefined;
    } else {
      const _Tree = _param;
      const _k = _Tree._0;
      const _value = _Tree._1;
      const _l = _Tree._3;
      const _r = _Tree._4;
      const c = $compare_int(key, _k);
      if (c === 0) {
        return _value;
      } else {
        if (c < 0) {
          _tmp = _l;
          continue;
        } else {
          _tmp = _r;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$SortedMap$get$241$(self, key) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (_param.$tag === 0) {
      return undefined;
    } else {
      const _Tree = _param;
      const _k = _Tree._0;
      const _value = _Tree._1;
      const _l = _Tree._3;
      const _r = _Tree._4;
      const c = moonbitlang$core$builtin$$Compare$compare$13$(key, _k);
      if (c === 0) {
        return _value;
      } else {
        if (c < 0) {
          _tmp = _l;
          continue;
        } else {
          _tmp = _r;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$balance$240$(key, value, l, r) {
  const ln = moonbitlang$core$immut$sorted_map$$SortedMap$length$240$(l);
  const rn = moonbitlang$core$immut$sorted_map$$SortedMap$length$240$(r);
  if ((ln + rn | 0) < 2) {
    return moonbitlang$core$immut$sorted_map$$make_tree$240$(key, value, l, r);
  } else {
    if (rn > (Math.imul(5, ln) | 0)) {
      if (r.$tag === 1) {
        const _Tree = r;
        const _rl = _Tree._3;
        const _rr = _Tree._4;
        const rln = moonbitlang$core$immut$sorted_map$$SortedMap$length$240$(_rl);
        const rrn = moonbitlang$core$immut$sorted_map$$SortedMap$length$240$(_rr);
        if (rln < rrn) {
          if (r.$tag === 1) {
            const _Tree$2 = r;
            const _k2 = _Tree$2._0;
            const _v2 = _Tree$2._1;
            const _y = _Tree$2._3;
            const _z = _Tree$2._4;
            return moonbitlang$core$immut$sorted_map$$make_tree$240$(_k2, _v2, moonbitlang$core$immut$sorted_map$$make_tree$240$(key, value, l, _y), _z);
          } else {
            return $panic();
          }
        } else {
          _L: {
            if (r.$tag === 1) {
              const _Tree$2 = r;
              const _k3 = _Tree$2._0;
              const _v3 = _Tree$2._1;
              const _x = _Tree$2._3;
              if (_x.$tag === 1) {
                const _Tree$3 = _x;
                const _k2 = _Tree$3._0;
                const _v2 = _Tree$3._1;
                const _y1 = _Tree$3._3;
                const _y2 = _Tree$3._4;
                const _z = _Tree$2._4;
                return moonbitlang$core$immut$sorted_map$$make_tree$240$(_k2, _v2, moonbitlang$core$immut$sorted_map$$make_tree$240$(key, value, l, _y1), moonbitlang$core$immut$sorted_map$$make_tree$240$(_k3, _v3, _y2, _z));
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return $panic();
        }
      } else {
        return $panic();
      }
    } else {
      if (ln > (Math.imul(5, rn) | 0)) {
        if (l.$tag === 1) {
          const _Tree = l;
          const _ll = _Tree._3;
          const _lr = _Tree._4;
          const lln = moonbitlang$core$immut$sorted_map$$SortedMap$length$240$(_ll);
          const lrn = moonbitlang$core$immut$sorted_map$$SortedMap$length$240$(_lr);
          if (lrn < lln) {
            if (l.$tag === 1) {
              const _Tree$2 = l;
              const _k1 = _Tree$2._0;
              const _v1 = _Tree$2._1;
              const _x = _Tree$2._3;
              const _y = _Tree$2._4;
              return moonbitlang$core$immut$sorted_map$$make_tree$240$(_k1, _v1, _x, moonbitlang$core$immut$sorted_map$$make_tree$240$(key, value, _y, r));
            } else {
              return $panic();
            }
          } else {
            _L: {
              if (l.$tag === 1) {
                const _Tree$2 = l;
                const _k1 = _Tree$2._0;
                const _v1 = _Tree$2._1;
                const _x = _Tree$2._3;
                const _x$2 = _Tree$2._4;
                if (_x$2.$tag === 1) {
                  const _Tree$3 = _x$2;
                  const _k2 = _Tree$3._0;
                  const _v2 = _Tree$3._1;
                  const _y1 = _Tree$3._3;
                  const _y2 = _Tree$3._4;
                  return moonbitlang$core$immut$sorted_map$$make_tree$240$(_k2, _v2, moonbitlang$core$immut$sorted_map$$make_tree$240$(_k1, _v1, _x, _y1), moonbitlang$core$immut$sorted_map$$make_tree$240$(key, value, _y2, r));
                } else {
                  break _L;
                }
              } else {
                break _L;
              }
            }
            return $panic();
          }
        } else {
          return $panic();
        }
      } else {
        return moonbitlang$core$immut$sorted_map$$make_tree$240$(key, value, l, r);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$balance$241$(key, value, l, r) {
  const ln = moonbitlang$core$immut$sorted_map$$SortedMap$length$241$(l);
  const rn = moonbitlang$core$immut$sorted_map$$SortedMap$length$241$(r);
  if ((ln + rn | 0) < 2) {
    return moonbitlang$core$immut$sorted_map$$make_tree$241$(key, value, l, r);
  } else {
    if (rn > (Math.imul(5, ln) | 0)) {
      if (r.$tag === 1) {
        const _Tree = r;
        const _rl = _Tree._3;
        const _rr = _Tree._4;
        const rln = moonbitlang$core$immut$sorted_map$$SortedMap$length$241$(_rl);
        const rrn = moonbitlang$core$immut$sorted_map$$SortedMap$length$241$(_rr);
        if (rln < rrn) {
          if (r.$tag === 1) {
            const _Tree$2 = r;
            const _k2 = _Tree$2._0;
            const _v2 = _Tree$2._1;
            const _y = _Tree$2._3;
            const _z = _Tree$2._4;
            return moonbitlang$core$immut$sorted_map$$make_tree$241$(_k2, _v2, moonbitlang$core$immut$sorted_map$$make_tree$241$(key, value, l, _y), _z);
          } else {
            return $panic();
          }
        } else {
          _L: {
            if (r.$tag === 1) {
              const _Tree$2 = r;
              const _k3 = _Tree$2._0;
              const _v3 = _Tree$2._1;
              const _x = _Tree$2._3;
              if (_x.$tag === 1) {
                const _Tree$3 = _x;
                const _k2 = _Tree$3._0;
                const _v2 = _Tree$3._1;
                const _y1 = _Tree$3._3;
                const _y2 = _Tree$3._4;
                const _z = _Tree$2._4;
                return moonbitlang$core$immut$sorted_map$$make_tree$241$(_k2, _v2, moonbitlang$core$immut$sorted_map$$make_tree$241$(key, value, l, _y1), moonbitlang$core$immut$sorted_map$$make_tree$241$(_k3, _v3, _y2, _z));
              } else {
                break _L;
              }
            } else {
              break _L;
            }
          }
          return $panic();
        }
      } else {
        return $panic();
      }
    } else {
      if (ln > (Math.imul(5, rn) | 0)) {
        if (l.$tag === 1) {
          const _Tree = l;
          const _ll = _Tree._3;
          const _lr = _Tree._4;
          const lln = moonbitlang$core$immut$sorted_map$$SortedMap$length$241$(_ll);
          const lrn = moonbitlang$core$immut$sorted_map$$SortedMap$length$241$(_lr);
          if (lrn < lln) {
            if (l.$tag === 1) {
              const _Tree$2 = l;
              const _k1 = _Tree$2._0;
              const _v1 = _Tree$2._1;
              const _x = _Tree$2._3;
              const _y = _Tree$2._4;
              return moonbitlang$core$immut$sorted_map$$make_tree$241$(_k1, _v1, _x, moonbitlang$core$immut$sorted_map$$make_tree$241$(key, value, _y, r));
            } else {
              return $panic();
            }
          } else {
            _L: {
              if (l.$tag === 1) {
                const _Tree$2 = l;
                const _k1 = _Tree$2._0;
                const _v1 = _Tree$2._1;
                const _x = _Tree$2._3;
                const _x$2 = _Tree$2._4;
                if (_x$2.$tag === 1) {
                  const _Tree$3 = _x$2;
                  const _k2 = _Tree$3._0;
                  const _v2 = _Tree$3._1;
                  const _y1 = _Tree$3._3;
                  const _y2 = _Tree$3._4;
                  return moonbitlang$core$immut$sorted_map$$make_tree$241$(_k2, _v2, moonbitlang$core$immut$sorted_map$$make_tree$241$(_k1, _v1, _x, _y1), moonbitlang$core$immut$sorted_map$$make_tree$241$(key, value, _y2, r));
                } else {
                  break _L;
                }
              } else {
                break _L;
              }
            }
            return $panic();
          }
        } else {
          return $panic();
        }
      } else {
        return moonbitlang$core$immut$sorted_map$$make_tree$241$(key, value, l, r);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$SortedMap$add$240$(self, key, value) {
  if (self.$tag === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Tree$25$(key, value, 1, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$25$, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$25$);
  } else {
    const _Tree = self;
    const _k = _Tree._0;
    const _v = _Tree._1;
    const _l = _Tree._3;
    const _r = _Tree._4;
    const c = $compare_int(key, _k);
    return c === 0 ? moonbitlang$core$immut$sorted_map$$make_tree$240$(_k, value, _l, _r) : c < 0 ? moonbitlang$core$immut$sorted_map$$balance$240$(_k, _v, moonbitlang$core$immut$sorted_map$$SortedMap$add$240$(_l, key, value), _r) : moonbitlang$core$immut$sorted_map$$balance$240$(_k, _v, _l, moonbitlang$core$immut$sorted_map$$SortedMap$add$240$(_r, key, value));
  }
}
function moonbitlang$core$immut$sorted_map$$SortedMap$add$241$(self, key, value) {
  if (self.$tag === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Tree$26$(key, value, 1, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$26$, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$26$);
  } else {
    const _Tree = self;
    const _k = _Tree._0;
    const _v = _Tree._1;
    const _l = _Tree._3;
    const _r = _Tree._4;
    const c = moonbitlang$core$builtin$$Compare$compare$13$(key, _k);
    return c === 0 ? moonbitlang$core$immut$sorted_map$$make_tree$241$(_k, value, _l, _r) : c < 0 ? moonbitlang$core$immut$sorted_map$$balance$241$(_k, _v, moonbitlang$core$immut$sorted_map$$SortedMap$add$241$(_l, key, value), _r) : moonbitlang$core$immut$sorted_map$$balance$241$(_k, _v, _l, moonbitlang$core$immut$sorted_map$$SortedMap$add$241$(_r, key, value));
  }
}
function moonbitlang$core$immut$sorted_set$$SortedSet$length$170$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Node = self;
    return _Node._2;
  }
}
function moonbitlang$core$immut$sorted_set$$SortedSet$length$176$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Node = self;
    return _Node._2;
  }
}
function moonbitlang$core$immut$sorted_set$$create$170$(left, value, right) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Node$27$(left, right, (moonbitlang$core$immut$sorted_set$$SortedSet$length$170$(left) + moonbitlang$core$immut$sorted_set$$SortedSet$length$170$(right) | 0) + 1 | 0, value);
}
function moonbitlang$core$immut$sorted_set$$create$176$(left, value, right) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Node$28$(left, right, (moonbitlang$core$immut$sorted_set$$SortedSet$length$176$(left) + moonbitlang$core$immut$sorted_set$$SortedSet$length$176$(right) | 0) + 1 | 0, value);
}
function moonbitlang$core$immut$sorted_set$$balance$170$(left, value, right) {
  const left_size = moonbitlang$core$immut$sorted_set$$SortedSet$length$170$(left);
  const right_size = moonbitlang$core$immut$sorted_set$$SortedSet$length$170$(right);
  if ((left_size + right_size | 0) < 2) {
    return moonbitlang$core$immut$sorted_set$$create$170$(left, value, right);
  } else {
    if (left_size > (Math.imul(right_size, 5) | 0)) {
      if (left.$tag === 0) {
        return moonbitlang$core$builtin$$abort$35$("balance: left is empty.", "@moonbitlang/core/immut/sorted_set:immutable_set.mbt:823:16-823:48");
      } else {
        const _Node = left;
        const _ll = _Node._0;
        const _lv = _Node._3;
        const _lr = _Node._1;
        if (moonbitlang$core$immut$sorted_set$$SortedSet$length$170$(_ll) >= moonbitlang$core$immut$sorted_set$$SortedSet$length$170$(_lr)) {
          return moonbitlang$core$immut$sorted_set$$create$170$(_ll, _lv, moonbitlang$core$immut$sorted_set$$create$170$(_lr, value, right));
        } else {
          if (_lr.$tag === 0) {
            return moonbitlang$core$builtin$$abort$35$("balance: right left.right is empty.", "@moonbitlang/core/immut/sorted_set:immutable_set.mbt:829:22-829:66");
          } else {
            const _Node$2 = _lr;
            const _lrl = _Node$2._0;
            const _lrv = _Node$2._3;
            const _lrr = _Node$2._1;
            return moonbitlang$core$immut$sorted_set$$create$170$(moonbitlang$core$immut$sorted_set$$create$170$(_ll, _lv, _lrl), _lrv, moonbitlang$core$immut$sorted_set$$create$170$(_lrr, value, right));
          }
        }
      }
    } else {
      if (right_size > (Math.imul(left_size, 5) | 0)) {
        if (right.$tag === 0) {
          return moonbitlang$core$builtin$$abort$35$("balance: right is empty", "@moonbitlang/core/immut/sorted_set:immutable_set.mbt:837:16-837:48");
        } else {
          const _Node = right;
          const _rl = _Node._0;
          const _rv = _Node._3;
          const _rr = _Node._1;
          if (moonbitlang$core$immut$sorted_set$$SortedSet$length$170$(_rr) >= moonbitlang$core$immut$sorted_set$$SortedSet$length$170$(_rl)) {
            return moonbitlang$core$immut$sorted_set$$create$170$(moonbitlang$core$immut$sorted_set$$create$170$(left, value, _rl), _rv, _rr);
          } else {
            if (_rl.$tag === 0) {
              return moonbitlang$core$builtin$$abort$35$("balance: right.left is empty", "@moonbitlang/core/immut/sorted_set:immutable_set.mbt:843:22-843:59");
            } else {
              const _Node$2 = _rl;
              const _rll = _Node$2._0;
              const _rlv = _Node$2._3;
              const _rlr = _Node$2._1;
              return moonbitlang$core$immut$sorted_set$$create$170$(moonbitlang$core$immut$sorted_set$$create$170$(left, value, _rll), _rlv, moonbitlang$core$immut$sorted_set$$create$170$(_rlr, _rv, _rr));
            }
          }
        }
      } else {
        return moonbitlang$core$immut$sorted_set$$create$170$(left, value, right);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$balance$176$(left, value, right) {
  const left_size = moonbitlang$core$immut$sorted_set$$SortedSet$length$176$(left);
  const right_size = moonbitlang$core$immut$sorted_set$$SortedSet$length$176$(right);
  if ((left_size + right_size | 0) < 2) {
    return moonbitlang$core$immut$sorted_set$$create$176$(left, value, right);
  } else {
    if (left_size > (Math.imul(right_size, 5) | 0)) {
      if (left.$tag === 0) {
        return moonbitlang$core$builtin$$abort$36$("balance: left is empty.", "@moonbitlang/core/immut/sorted_set:immutable_set.mbt:823:16-823:48");
      } else {
        const _Node = left;
        const _ll = _Node._0;
        const _lv = _Node._3;
        const _lr = _Node._1;
        if (moonbitlang$core$immut$sorted_set$$SortedSet$length$176$(_ll) >= moonbitlang$core$immut$sorted_set$$SortedSet$length$176$(_lr)) {
          return moonbitlang$core$immut$sorted_set$$create$176$(_ll, _lv, moonbitlang$core$immut$sorted_set$$create$176$(_lr, value, right));
        } else {
          if (_lr.$tag === 0) {
            return moonbitlang$core$builtin$$abort$36$("balance: right left.right is empty.", "@moonbitlang/core/immut/sorted_set:immutable_set.mbt:829:22-829:66");
          } else {
            const _Node$2 = _lr;
            const _lrl = _Node$2._0;
            const _lrv = _Node$2._3;
            const _lrr = _Node$2._1;
            return moonbitlang$core$immut$sorted_set$$create$176$(moonbitlang$core$immut$sorted_set$$create$176$(_ll, _lv, _lrl), _lrv, moonbitlang$core$immut$sorted_set$$create$176$(_lrr, value, right));
          }
        }
      }
    } else {
      if (right_size > (Math.imul(left_size, 5) | 0)) {
        if (right.$tag === 0) {
          return moonbitlang$core$builtin$$abort$36$("balance: right is empty", "@moonbitlang/core/immut/sorted_set:immutable_set.mbt:837:16-837:48");
        } else {
          const _Node = right;
          const _rl = _Node._0;
          const _rv = _Node._3;
          const _rr = _Node._1;
          if (moonbitlang$core$immut$sorted_set$$SortedSet$length$176$(_rr) >= moonbitlang$core$immut$sorted_set$$SortedSet$length$176$(_rl)) {
            return moonbitlang$core$immut$sorted_set$$create$176$(moonbitlang$core$immut$sorted_set$$create$176$(left, value, _rl), _rv, _rr);
          } else {
            if (_rl.$tag === 0) {
              return moonbitlang$core$builtin$$abort$36$("balance: right.left is empty", "@moonbitlang/core/immut/sorted_set:immutable_set.mbt:843:22-843:59");
            } else {
              const _Node$2 = _rl;
              const _rll = _Node$2._0;
              const _rlv = _Node$2._3;
              const _rlr = _Node$2._1;
              return moonbitlang$core$immut$sorted_set$$create$176$(moonbitlang$core$immut$sorted_set$$create$176$(left, value, _rll), _rlv, moonbitlang$core$immut$sorted_set$$create$176$(_rlr, _rv, _rr));
            }
          }
        }
      } else {
        return moonbitlang$core$immut$sorted_set$$create$176$(left, value, right);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$SortedSet$add$170$(self, value) {
  if (self.$tag === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Node$27$($64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Empty$27$, $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Empty$27$, 1, value);
  } else {
    const _Node = self;
    const _left = _Node._0;
    const _right = _Node._1;
    const _node_value = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$170$(value, _node_value);
    if (compare_result === 0) {
      return self;
    } else {
      if (compare_result < 0) {
        const ll = moonbitlang$core$immut$sorted_set$$SortedSet$add$170$(_left, value);
        return _left === ll ? self : moonbitlang$core$immut$sorted_set$$balance$170$(ll, _node_value, _right);
      } else {
        const rr = moonbitlang$core$immut$sorted_set$$SortedSet$add$170$(_right, value);
        return _right === rr ? self : moonbitlang$core$immut$sorted_set$$balance$170$(_left, _node_value, rr);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$SortedSet$add$176$(self, value) {
  if (self.$tag === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Node$28$($64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Empty$28$, $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Empty$28$, 1, value);
  } else {
    const _Node = self;
    const _left = _Node._0;
    const _right = _Node._1;
    const _node_value = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$176$(value, _node_value);
    if (compare_result === 0) {
      return self;
    } else {
      if (compare_result < 0) {
        const ll = moonbitlang$core$immut$sorted_set$$SortedSet$add$176$(_left, value);
        return _left === ll ? self : moonbitlang$core$immut$sorted_set$$balance$176$(ll, _node_value, _right);
      } else {
        const rr = moonbitlang$core$immut$sorted_set$$SortedSet$add$176$(_right, value);
        return _right === rr ? self : moonbitlang$core$immut$sorted_set$$balance$176$(_left, _node_value, rr);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$SortedSet$iter$176$(self) {
  const curr_node = { val: self };
  const parents = [];
  const _p = () => {
    let _tmp = curr_node.val;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 1) {
        const _Node = _param;
        const _x = _Node._0;
        if (_x.$tag === 0) {
          const _right = _Node._1;
          const _value = _Node._3;
          curr_node.val = _right;
          return _value;
        } else {
          const _right = _Node._1;
          const _value = _Node._3;
          moonbitlang$core$array$$Array$push$149$(parents, { _0: _value, _1: _right });
          _tmp = _x;
          continue;
        }
      } else {
        const _bind = moonbitlang$core$array$$Array$pop$149$(parents);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _value = _x._0;
          const _right = _x._1;
          curr_node.val = _right;
          return _value;
        }
      }
    }
  };
  return _p;
}
function moonbitlang$core$builtin$$Show$output$115$(self, logger) {
  logger.method_table.method_0(logger.self, Error$$to_string(self));
}
function moonbitlang$core$set$$Set$new$46$inner$13$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$set$$Set$new$46$inner$81$(capacity) {
  const capacity$2 = moonbitlang$core$int$$Int$next_power_of_two(capacity);
  const _bind = capacity$2 - 1 | 0;
  const _bind$2 = (Math.imul(capacity$2, 13) | 0) / 16 | 0;
  const _bind$3 = $make_array_len_and_init(capacity$2, undefined);
  const _bind$4 = undefined;
  return { entries: _bind$3, size: 0, capacity: capacity$2, capacity_mask: _bind, grow_at: _bind$2, head: _bind$4, tail: -1 };
}
function moonbitlang$core$set$$Set$add_entry_to_tail$13$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$set$$Set$add_entry_to_tail$81$(self, idx, entry) {
  const _bind = self.tail;
  if (_bind === -1) {
    self.head = entry;
  } else {
    const _tmp = self.entries;
    $bound_check(_tmp, _bind);
    const _p = _tmp[_bind];
    let _tmp$2;
    if (_p === undefined) {
      _tmp$2 = $panic();
    } else {
      const _p$2 = _p;
      _tmp$2 = _p$2;
    }
    _tmp$2.next = entry;
  }
  self.tail = idx;
  const _tmp = self.entries;
  $bound_check(_tmp, idx);
  _tmp[idx] = entry;
  self.size = self.size + 1 | 0;
}
function moonbitlang$core$set$$Set$set_entry$13$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$set$$Set$set_entry$81$(self, entry, new_idx) {
  const _tmp = self.entries;
  $bound_check(_tmp, new_idx);
  _tmp[new_idx] = entry;
  const _bind = entry.next;
  if (_bind === undefined) {
    self.tail = new_idx;
    return;
  } else {
    const _Some = _bind;
    const _next = _Some;
    _next.prev = new_idx;
    return;
  }
}
function moonbitlang$core$set$$Set$push_away$13$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$set$$Set$set_entry$13$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$set$$Set$set_entry$13$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$set$$Set$push_away$81$(self, idx, entry) {
  let _tmp = entry.psl + 1 | 0;
  let _tmp$2 = idx + 1 & self.capacity_mask;
  let _tmp$3 = entry;
  while (true) {
    const psl = _tmp;
    const idx$2 = _tmp$2;
    const entry$2 = _tmp$3;
    const _tmp$4 = self.entries;
    $bound_check(_tmp$4, idx$2);
    const _bind = _tmp$4[idx$2];
    if (_bind === undefined) {
      entry$2.psl = psl;
      moonbitlang$core$set$$Set$set_entry$81$(self, entry$2, idx$2);
      break;
    } else {
      const _Some = _bind;
      const _curr_entry = _Some;
      if (psl > _curr_entry.psl) {
        entry$2.psl = psl;
        moonbitlang$core$set$$Set$set_entry$81$(self, entry$2, idx$2);
        _tmp = _curr_entry.psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        _tmp$3 = _curr_entry;
        continue;
      } else {
        _tmp = psl + 1 | 0;
        _tmp$2 = idx$2 + 1 & self.capacity_mask;
        continue;
      }
    }
  }
}
function moonbitlang$core$set$$Set$add_with_hash$13$(self, key, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$set$$Set$grow$13$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      if (_curr_entry.hash === hash && _curr_entry.key === key) {
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$set$$Set$push_away$13$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key };
  moonbitlang$core$set$$Set$add_entry_to_tail$13$(self, _idx, entry);
}
function moonbitlang$core$set$$Set$add_with_hash$81$(self, key, hash) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$set$$Set$grow$81$(self);
  }
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      let _tmp$4;
      if (_curr_entry.hash === hash) {
        const _p = _curr_entry.key;
        _tmp$4 = _p === key;
      } else {
        _tmp$4 = false;
      }
      if (_tmp$4) {
        return undefined;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$set$$Set$push_away$81$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _bind$2 = self.tail;
  const _bind$3 = undefined;
  const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key };
  moonbitlang$core$set$$Set$add_entry_to_tail$81$(self, _idx, entry);
}
function moonbitlang$core$set$$Set$grow$13$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _hash = _x.hash;
      moonbitlang$core$set$$Set$add_with_hash$13$(self, _key, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$set$$Set$grow$81$(self) {
  const old_head = self.head;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  const _p = self.capacity;
  self.grow_at = (Math.imul(_p, 13) | 0) / 16 | 0;
  self.size = 0;
  self.head = undefined;
  self.tail = -1;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _next = _x.next;
      const _key = _x.key;
      const _hash = _x.hash;
      moonbitlang$core$set$$Set$add_with_hash$81$(self, _key, _hash);
      _tmp = _next;
      continue;
    }
  }
}
function moonbitlang$core$set$$Set$add$13$(self, key) {
  moonbitlang$core$set$$Set$add_with_hash$13$(self, key, moonbitlang$core$builtin$$Hash$hash$108$(key));
}
function moonbitlang$core$set$$Set$from_array$13$(arr) {
  const length = arr.end - arr.start | 0;
  let capacity = moonbitlang$core$int$$Int$next_power_of_two(length);
  const _p = capacity;
  if (length > ((Math.imul(_p, 13) | 0) / 16 | 0)) {
    capacity = Math.imul(capacity, 2) | 0;
  }
  const m = moonbitlang$core$set$$Set$new$46$inner$13$(capacity);
  const _len = arr.end - arr.start | 0;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const e = arr.buf[arr.start + _i | 0];
      moonbitlang$core$set$$Set$add$13$(m, e);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return m;
}
function moonbitlang$core$set$$Set$add_and_check$81$(self, key) {
  if (self.size >= self.grow_at) {
    moonbitlang$core$set$$Set$grow$81$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$82$(key);
  let _bind;
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const psl = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind$2 = _tmp$3[idx];
    if (_bind$2 === undefined) {
      _bind = { _0: idx, _1: psl, _2: true };
      break;
    } else {
      const _Some = _bind$2;
      const _curr_entry = _Some;
      let _tmp$4;
      if (_curr_entry.hash === hash) {
        const _p = _curr_entry.key;
        _tmp$4 = _p === key;
      } else {
        _tmp$4 = false;
      }
      if (_tmp$4) {
        _bind = { _0: idx, _1: psl, _2: false };
        break;
      }
      if (psl > _curr_entry.psl) {
        moonbitlang$core$set$$Set$push_away$81$(self, idx, _curr_entry);
        _bind = { _0: idx, _1: psl, _2: true };
        break;
      }
      _tmp = psl + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
  const _idx = _bind._0;
  const _psl = _bind._1;
  const _added = _bind._2;
  if (_added) {
    const _bind$2 = self.tail;
    const _bind$3 = undefined;
    const entry = { prev: _bind$2, next: _bind$3, psl: _psl, hash: hash, key: key };
    moonbitlang$core$set$$Set$add_entry_to_tail$81$(self, _idx, entry);
  }
  return _added;
}
function moonbitlang$core$set$$Set$contains$13$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _tmp$3 = self.entries;
    $bound_check(_tmp$3, idx);
    const _bind = _tmp$3[idx];
    if (_bind === undefined) {
      return false;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return true;
      }
      if (i > _entry.psl) {
        return false;
      }
      _tmp = i + 1 | 0;
      _tmp$2 = idx + 1 & self.capacity_mask;
      continue;
    }
  }
}
function moonbitlang$core$set$$Set$from_iter$13$(iter) {
  const m = moonbitlang$core$set$$Set$new$46$inner$13$(8);
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$13$(iter);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _e = _Some;
      moonbitlang$core$set$$Set$add$13$(m, _e);
      continue;
    }
  }
  return m;
}
function moonbitlang$core$sorted_map$$new_node$227$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$sorted_map$$new_node$226$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$sorted_map$$new_node$242$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$sorted_map$$new_node$243$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$sorted_map$$new_node$228$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$builtin$$Eq$equal$202$(self, other) {
  return moonbitlang$core$builtin$$Eq$equal$54$(self.key, other.key);
}
function moonbitlang$core$builtin$$Eq$equal$203$(self, other) {
  return moonbitlang$core$builtin$$Eq$equal$52$(self.key, other.key);
}
function moonbitlang$core$builtin$$Eq$equal$206$(self, other) {
  return moonbitlang$core$builtin$$Eq$equal$73$(self.key, other.key);
}
function moonbitlang$core$builtin$$Eq$equal$207$(self, other) {
  return moonbitlang$core$builtin$$Eq$equal$74$(self.key, other.key);
}
function moonbitlang$core$sorted_map$$SortedMap$iter$226$(self) {
  const todo_list = [];
  const next_node = { val: self.root };
  const _p = () => {
    let _tmp = next_node.val;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        const _bind = moonbitlang$core$array$$Array$pop$151$(todo_list);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _key = _x._0;
          const _value = _x._1;
          const _right = _x._2;
          next_node.val = _right;
          return { _0: _key, _1: _value };
        }
      } else {
        const _Some = _param;
        const _x = _Some;
        const _left = _x.left;
        const _key = _x.key;
        const _value = _x.value;
        const _right = _x.right;
        moonbitlang$core$array$$Array$push$151$(todo_list, { _0: _key, _1: _value, _2: _right });
        _tmp = _left;
        continue;
      }
    }
  };
  return _p;
}
function moonbitlang$core$sorted_map$$SortedMap$iter$227$(self) {
  const todo_list = [];
  const next_node = { val: self.root };
  const _p = () => {
    let _tmp = next_node.val;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        const _bind = moonbitlang$core$array$$Array$pop$152$(todo_list);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _key = _x._0;
          const _value = _x._1;
          const _right = _x._2;
          next_node.val = _right;
          return { _0: _key, _1: _value };
        }
      } else {
        const _Some = _param;
        const _x = _Some;
        const _left = _x.left;
        const _key = _x.key;
        const _value = _x.value;
        const _right = _x.right;
        moonbitlang$core$array$$Array$push$152$(todo_list, { _0: _key, _1: _value, _2: _right });
        _tmp = _left;
        continue;
      }
    }
  };
  return _p;
}
function moonbitlang$core$sorted_map$$SortedMap$iter$228$(self) {
  const todo_list = [];
  const next_node = { val: self.root };
  const _p = () => {
    let _tmp = next_node.val;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        const _bind = moonbitlang$core$array$$Array$pop$153$(todo_list);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _key = _x._0;
          const _value = _x._1;
          const _right = _x._2;
          next_node.val = _right;
          return { _0: _key, _1: _value };
        }
      } else {
        const _Some = _param;
        const _x = _Some;
        const _left = _x.left;
        const _key = _x.key;
        const _value = _x.value;
        const _right = _x.right;
        moonbitlang$core$array$$Array$push$153$(todo_list, { _0: _key, _1: _value, _2: _right });
        _tmp = _left;
        continue;
      }
    }
  };
  return _p;
}
function moonbitlang$core$sorted_map$$SortedMap$new$242$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$SortedMap$new$227$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$SortedMap$new$226$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$SortedMap$new$243$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$SortedMap$new$228$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$height_ge$227$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _n2 = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _n1 = _Some$2;
      return _n1.height >= _n2.height;
    }
  }
}
function moonbitlang$core$sorted_map$$height_ge$226$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _n2 = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _n1 = _Some$2;
      return _n1.height >= _n2.height;
    }
  }
}
function moonbitlang$core$sorted_map$$height_ge$242$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _n2 = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _n1 = _Some$2;
      return _n1.height >= _n2.height;
    }
  }
}
function moonbitlang$core$sorted_map$$height_ge$243$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _n2 = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _n1 = _Some$2;
      return _n1.height >= _n2.height;
    }
  }
}
function moonbitlang$core$sorted_map$$height_ge$228$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _n2 = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _n1 = _Some$2;
      return _n1.height >= _n2.height;
    }
  }
}
function moonbitlang$core$sorted_map$$Node$update_height$227$(self) {
  const _p = self.left;
  let _p$2;
  if (_p === undefined) {
    _p$2 = 0;
  } else {
    const _p$3 = _p;
    const _p$4 = _p$3;
    _p$2 = _p$4.height;
  }
  const _p$3 = self.right;
  let _p$4;
  if (_p$3 === undefined) {
    _p$4 = 0;
  } else {
    const _p$5 = _p$3;
    const _p$6 = _p$5;
    _p$4 = _p$6.height;
  }
  self.height = 1 + (_p$2 > _p$4 ? _p$2 : _p$4) | 0;
}
function moonbitlang$core$sorted_map$$Node$update_height$226$(self) {
  const _p = self.left;
  let _p$2;
  if (_p === undefined) {
    _p$2 = 0;
  } else {
    const _p$3 = _p;
    const _p$4 = _p$3;
    _p$2 = _p$4.height;
  }
  const _p$3 = self.right;
  let _p$4;
  if (_p$3 === undefined) {
    _p$4 = 0;
  } else {
    const _p$5 = _p$3;
    const _p$6 = _p$5;
    _p$4 = _p$6.height;
  }
  self.height = 1 + (_p$2 > _p$4 ? _p$2 : _p$4) | 0;
}
function moonbitlang$core$sorted_map$$Node$update_height$242$(self) {
  const _p = self.left;
  let _p$2;
  if (_p === undefined) {
    _p$2 = 0;
  } else {
    const _p$3 = _p;
    const _p$4 = _p$3;
    _p$2 = _p$4.height;
  }
  const _p$3 = self.right;
  let _p$4;
  if (_p$3 === undefined) {
    _p$4 = 0;
  } else {
    const _p$5 = _p$3;
    const _p$6 = _p$5;
    _p$4 = _p$6.height;
  }
  self.height = 1 + (_p$2 > _p$4 ? _p$2 : _p$4) | 0;
}
function moonbitlang$core$sorted_map$$Node$update_height$243$(self) {
  const _p = self.left;
  let _p$2;
  if (_p === undefined) {
    _p$2 = 0;
  } else {
    const _p$3 = _p;
    const _p$4 = _p$3;
    _p$2 = _p$4.height;
  }
  const _p$3 = self.right;
  let _p$4;
  if (_p$3 === undefined) {
    _p$4 = 0;
  } else {
    const _p$5 = _p$3;
    const _p$6 = _p$5;
    _p$4 = _p$6.height;
  }
  self.height = 1 + (_p$2 > _p$4 ? _p$2 : _p$4) | 0;
}
function moonbitlang$core$sorted_map$$Node$update_height$228$(self) {
  const _p = self.left;
  let _p$2;
  if (_p === undefined) {
    _p$2 = 0;
  } else {
    const _p$3 = _p;
    const _p$4 = _p$3;
    _p$2 = _p$4.height;
  }
  const _p$3 = self.right;
  let _p$4;
  if (_p$3 === undefined) {
    _p$4 = 0;
  } else {
    const _p$5 = _p$3;
    const _p$6 = _p$5;
    _p$4 = _p$6.height;
  }
  self.height = 1 + (_p$2 > _p$4 ? _p$2 : _p$4) | 0;
}
function moonbitlang$core$sorted_map$$rotate_l$227$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$227$(n);
  moonbitlang$core$sorted_map$$Node$update_height$227$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_l$226$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$226$(n);
  moonbitlang$core$sorted_map$$Node$update_height$226$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_l$242$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$242$(n);
  moonbitlang$core$sorted_map$$Node$update_height$242$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_l$243$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$243$(n);
  moonbitlang$core$sorted_map$$Node$update_height$243$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_l$228$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$228$(n);
  moonbitlang$core$sorted_map$$Node$update_height$228$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_r$227$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$227$(n);
  moonbitlang$core$sorted_map$$Node$update_height$227$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_r$226$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$226$(n);
  moonbitlang$core$sorted_map$$Node$update_height$226$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_r$242$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$242$(n);
  moonbitlang$core$sorted_map$$Node$update_height$242$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_r$243$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$243$(n);
  moonbitlang$core$sorted_map$$Node$update_height$243$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_r$228$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$228$(n);
  moonbitlang$core$sorted_map$$Node$update_height$228$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_lr$227$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_l$227$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$227$(n);
}
function moonbitlang$core$sorted_map$$rotate_lr$226$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_l$226$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$226$(n);
}
function moonbitlang$core$sorted_map$$rotate_lr$242$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_l$242$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$242$(n);
}
function moonbitlang$core$sorted_map$$rotate_lr$243$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_l$243$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$243$(n);
}
function moonbitlang$core$sorted_map$$rotate_lr$228$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_l$228$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$228$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$227$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_r$227$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$227$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$226$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_r$226$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$226$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$242$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_r$242$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$242$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$243$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_r$243$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$243$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$228$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  const v = moonbitlang$core$sorted_map$$rotate_r$228$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$228$(n);
}
function moonbitlang$core$sorted_map$$balance$227$(root) {
  const l = root.left;
  const r = root.right;
  let hl;
  if (l === undefined) {
    hl = 0;
  } else {
    const _p = l;
    const _p$2 = _p;
    hl = _p$2.height;
  }
  let hr;
  if (r === undefined) {
    hr = 0;
  } else {
    const _p = r;
    const _p$2 = _p;
    hr = _p$2.height;
  }
  let new_root;
  if (hl > (hr + 1 | 0)) {
    let _bind;
    if (l === undefined) {
      _bind = $panic();
    } else {
      const _p = l;
      _bind = _p;
    }
    const _ll = _bind.left;
    const _lr = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$227$(_ll, _lr) ? moonbitlang$core$sorted_map$$rotate_r$227$(root) : moonbitlang$core$sorted_map$$rotate_lr$227$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      let _bind;
      if (r === undefined) {
        _bind = $panic();
      } else {
        const _p = r;
        _bind = _p;
      }
      const _rl = _bind.left;
      const _rr = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$227$(_rr, _rl) ? moonbitlang$core$sorted_map$$rotate_l$227$(root) : moonbitlang$core$sorted_map$$rotate_rl$227$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$227$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$balance$226$(root) {
  const l = root.left;
  const r = root.right;
  let hl;
  if (l === undefined) {
    hl = 0;
  } else {
    const _p = l;
    const _p$2 = _p;
    hl = _p$2.height;
  }
  let hr;
  if (r === undefined) {
    hr = 0;
  } else {
    const _p = r;
    const _p$2 = _p;
    hr = _p$2.height;
  }
  let new_root;
  if (hl > (hr + 1 | 0)) {
    let _bind;
    if (l === undefined) {
      _bind = $panic();
    } else {
      const _p = l;
      _bind = _p;
    }
    const _ll = _bind.left;
    const _lr = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$226$(_ll, _lr) ? moonbitlang$core$sorted_map$$rotate_r$226$(root) : moonbitlang$core$sorted_map$$rotate_lr$226$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      let _bind;
      if (r === undefined) {
        _bind = $panic();
      } else {
        const _p = r;
        _bind = _p;
      }
      const _rl = _bind.left;
      const _rr = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$226$(_rr, _rl) ? moonbitlang$core$sorted_map$$rotate_l$226$(root) : moonbitlang$core$sorted_map$$rotate_rl$226$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$226$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$balance$242$(root) {
  const l = root.left;
  const r = root.right;
  let hl;
  if (l === undefined) {
    hl = 0;
  } else {
    const _p = l;
    const _p$2 = _p;
    hl = _p$2.height;
  }
  let hr;
  if (r === undefined) {
    hr = 0;
  } else {
    const _p = r;
    const _p$2 = _p;
    hr = _p$2.height;
  }
  let new_root;
  if (hl > (hr + 1 | 0)) {
    let _bind;
    if (l === undefined) {
      _bind = $panic();
    } else {
      const _p = l;
      _bind = _p;
    }
    const _ll = _bind.left;
    const _lr = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$242$(_ll, _lr) ? moonbitlang$core$sorted_map$$rotate_r$242$(root) : moonbitlang$core$sorted_map$$rotate_lr$242$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      let _bind;
      if (r === undefined) {
        _bind = $panic();
      } else {
        const _p = r;
        _bind = _p;
      }
      const _rl = _bind.left;
      const _rr = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$242$(_rr, _rl) ? moonbitlang$core$sorted_map$$rotate_l$242$(root) : moonbitlang$core$sorted_map$$rotate_rl$242$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$242$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$balance$243$(root) {
  const l = root.left;
  const r = root.right;
  let hl;
  if (l === undefined) {
    hl = 0;
  } else {
    const _p = l;
    const _p$2 = _p;
    hl = _p$2.height;
  }
  let hr;
  if (r === undefined) {
    hr = 0;
  } else {
    const _p = r;
    const _p$2 = _p;
    hr = _p$2.height;
  }
  let new_root;
  if (hl > (hr + 1 | 0)) {
    let _bind;
    if (l === undefined) {
      _bind = $panic();
    } else {
      const _p = l;
      _bind = _p;
    }
    const _ll = _bind.left;
    const _lr = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$243$(_ll, _lr) ? moonbitlang$core$sorted_map$$rotate_r$243$(root) : moonbitlang$core$sorted_map$$rotate_lr$243$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      let _bind;
      if (r === undefined) {
        _bind = $panic();
      } else {
        const _p = r;
        _bind = _p;
      }
      const _rl = _bind.left;
      const _rr = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$243$(_rr, _rl) ? moonbitlang$core$sorted_map$$rotate_l$243$(root) : moonbitlang$core$sorted_map$$rotate_rl$243$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$243$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$balance$228$(root) {
  const l = root.left;
  const r = root.right;
  let hl;
  if (l === undefined) {
    hl = 0;
  } else {
    const _p = l;
    const _p$2 = _p;
    hl = _p$2.height;
  }
  let hr;
  if (r === undefined) {
    hr = 0;
  } else {
    const _p = r;
    const _p$2 = _p;
    hr = _p$2.height;
  }
  let new_root;
  if (hl > (hr + 1 | 0)) {
    let _bind;
    if (l === undefined) {
      _bind = $panic();
    } else {
      const _p = l;
      _bind = _p;
    }
    const _ll = _bind.left;
    const _lr = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$228$(_ll, _lr) ? moonbitlang$core$sorted_map$$rotate_r$228$(root) : moonbitlang$core$sorted_map$$rotate_lr$228$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      let _bind;
      if (r === undefined) {
        _bind = $panic();
      } else {
        const _p = r;
        _bind = _p;
      }
      const _rl = _bind.left;
      const _rr = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$228$(_rr, _rl) ? moonbitlang$core$sorted_map$$rotate_l$228$(root) : moonbitlang$core$sorted_map$$rotate_rl$228$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$228$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$add_node$227$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$227$(key, value), _1: true };
  } else {
    const _Some = root;
    const _n = _Some;
    if (moonbitlang$core$builtin$$Eq$equal$54$(key, _n.key)) {
      _n.value = value;
      return { _0: _n, _1: false };
    } else {
      const l = _n.left;
      const r = _n.right;
      if (moonbitlang$core$builtin$$Compare$op_lt$104$(key, _n.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$227$(l, key, value);
        const _nl = _bind._0;
        const _inserted = _bind._1;
        _n.left = _nl;
        return { _0: moonbitlang$core$sorted_map$$balance$227$(_n), _1: _inserted };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$227$(r, key, value);
        const _nr = _bind._0;
        const _inserted = _bind._1;
        _n.right = _nr;
        return { _0: moonbitlang$core$sorted_map$$balance$227$(_n), _1: _inserted };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$add_node$226$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$226$(key, value), _1: true };
  } else {
    const _Some = root;
    const _n = _Some;
    if (moonbitlang$core$builtin$$Eq$equal$52$(key, _n.key)) {
      _n.value = value;
      return { _0: _n, _1: false };
    } else {
      const l = _n.left;
      const r = _n.right;
      if (moonbitlang$core$builtin$$Compare$op_lt$105$(key, _n.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$226$(l, key, value);
        const _nl = _bind._0;
        const _inserted = _bind._1;
        _n.left = _nl;
        return { _0: moonbitlang$core$sorted_map$$balance$226$(_n), _1: _inserted };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$226$(r, key, value);
        const _nr = _bind._0;
        const _inserted = _bind._1;
        _n.right = _nr;
        return { _0: moonbitlang$core$sorted_map$$balance$226$(_n), _1: _inserted };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$add_node$242$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$242$(key, value), _1: true };
  } else {
    const _Some = root;
    const _n = _Some;
    if (key === _n.key) {
      _n.value = value;
      return { _0: _n, _1: false };
    } else {
      const l = _n.left;
      const r = _n.right;
      if (moonbitlang$core$builtin$$Compare$op_lt$108$(key, _n.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$242$(l, key, value);
        const _nl = _bind._0;
        const _inserted = _bind._1;
        _n.left = _nl;
        return { _0: moonbitlang$core$sorted_map$$balance$242$(_n), _1: _inserted };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$242$(r, key, value);
        const _nr = _bind._0;
        const _inserted = _bind._1;
        _n.right = _nr;
        return { _0: moonbitlang$core$sorted_map$$balance$242$(_n), _1: _inserted };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$add_node$243$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$243$(key, value), _1: true };
  } else {
    const _Some = root;
    const _n = _Some;
    if (moonbitlang$core$builtin$$Eq$equal$73$(key, _n.key)) {
      _n.value = value;
      return { _0: _n, _1: false };
    } else {
      const l = _n.left;
      const r = _n.right;
      if (moonbitlang$core$builtin$$Compare$op_lt$109$(key, _n.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$243$(l, key, value);
        const _nl = _bind._0;
        const _inserted = _bind._1;
        _n.left = _nl;
        return { _0: moonbitlang$core$sorted_map$$balance$243$(_n), _1: _inserted };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$243$(r, key, value);
        const _nr = _bind._0;
        const _inserted = _bind._1;
        _n.right = _nr;
        return { _0: moonbitlang$core$sorted_map$$balance$243$(_n), _1: _inserted };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$add_node$228$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$228$(key, value), _1: true };
  } else {
    const _Some = root;
    const _n = _Some;
    if (moonbitlang$core$builtin$$Eq$equal$74$(key, _n.key)) {
      _n.value = value;
      return { _0: _n, _1: false };
    } else {
      const l = _n.left;
      const r = _n.right;
      if (moonbitlang$core$builtin$$Compare$op_lt$110$(key, _n.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$228$(l, key, value);
        const _nl = _bind._0;
        const _inserted = _bind._1;
        _n.left = _nl;
        return { _0: moonbitlang$core$sorted_map$$balance$228$(_n), _1: _inserted };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$228$(r, key, value);
        const _nr = _bind._0;
        const _inserted = _bind._1;
        _n.right = _nr;
        return { _0: moonbitlang$core$sorted_map$$balance$228$(_n), _1: _inserted };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$SortedMap$set$227$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$227$(self.root, key, value);
  const _new_root = _bind._0;
  const _inserted = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$83$(self.root, _new_root)) {
    self.root = _new_root;
  }
  if (_inserted) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$SortedMap$set$226$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$226$(self.root, key, value);
  const _new_root = _bind._0;
  const _inserted = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$87$(self.root, _new_root)) {
    self.root = _new_root;
  }
  if (_inserted) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$SortedMap$set$242$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$242$(self.root, key, value);
  const _new_root = _bind._0;
  const _inserted = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$89$(self.root, _new_root)) {
    self.root = _new_root;
  }
  if (_inserted) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$SortedMap$set$243$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$243$(self.root, key, value);
  const _new_root = _bind._0;
  const _inserted = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$97$(self.root, _new_root)) {
    self.root = _new_root;
  }
  if (_inserted) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$SortedMap$set$228$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$228$(self.root, key, value);
  const _new_root = _bind._0;
  const _inserted = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$99$(self.root, _new_root)) {
    self.root = _new_root;
  }
  if (_inserted) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$SortedMap$get$227$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _node = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$54$(key, _node.key);
      if (cmp === 0) {
        return _node.value;
      } else {
        if (cmp > 0) {
          _tmp = _node.right;
          continue;
        } else {
          _tmp = _node.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$SortedMap$get$242$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _node = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$13$(key, _node.key);
      if (cmp === 0) {
        return _node.value;
      } else {
        if (cmp > 0) {
          _tmp = _node.right;
          continue;
        } else {
          _tmp = _node.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$SortedMap$get$226$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _node = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$52$(key, _node.key);
      if (cmp === 0) {
        return _node.value;
      } else {
        if (cmp > 0) {
          _tmp = _node.right;
          continue;
        } else {
          _tmp = _node.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$SortedMap$get$243$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _node = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$73$(key, _node.key);
      if (cmp === 0) {
        return _node.value;
      } else {
        if (cmp > 0) {
          _tmp = _node.right;
          continue;
        } else {
          _tmp = _node.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$SortedMap$get$228$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _node = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$74$(key, _node.key);
      if (cmp === 0) {
        return _node.value;
      } else {
        if (cmp > 0) {
          _tmp = _node.right;
          continue;
        } else {
          _tmp = _node.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$SortedMap$keys_as_iter$243$(self) {
  const todo_list = [];
  const next_node = { val: self.root };
  const _p = () => {
    let _tmp = next_node.val;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        const _bind = moonbitlang$core$array$$Array$pop$146$(todo_list);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _key = _x._0;
          const _right = _x._1;
          next_node.val = _right;
          return _key;
        }
      } else {
        const _Some = _param;
        const _x = _Some;
        const _left = _x.left;
        const _key = _x.key;
        const _right = _x.right;
        moonbitlang$core$array$$Array$push$146$(todo_list, { _0: _key, _1: _right });
        _tmp = _left;
        continue;
      }
    }
  };
  return _p;
}
function moonbitlang$core$sorted_map$$SortedMap$keys_as_iter$228$(self) {
  const todo_list = [];
  const next_node = { val: self.root };
  const _p = () => {
    let _tmp = next_node.val;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        const _bind = moonbitlang$core$array$$Array$pop$148$(todo_list);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _key = _x._0;
          const _right = _x._1;
          next_node.val = _right;
          return _key;
        }
      } else {
        const _Some = _param;
        const _x = _Some;
        const _left = _x.left;
        const _key = _x.key;
        const _right = _x.right;
        moonbitlang$core$array$$Array$push$148$(todo_list, { _0: _key, _1: _right });
        _tmp = _left;
        continue;
      }
    }
  };
  return _p;
}
function moonbitlang$core$sorted_map$$SortedMap$iter2$226$(self) {
  return moonbitlang$core$sorted_map$$SortedMap$iter$226$(self);
}
function moonbitlang$core$sorted_map$$SortedMap$iter2$227$(self) {
  return moonbitlang$core$sorted_map$$SortedMap$iter$227$(self);
}
function moonbitlang$core$sorted_map$$SortedMap$iter2$228$(self) {
  return moonbitlang$core$sorted_map$$SortedMap$iter$228$(self);
}
function moonbitlang$core$builtin$$Eq$equal$204$(self, other) {
  return moonbitlang$core$builtin$$Eq$equal$75$(self.value, other.value);
}
function moonbitlang$core$builtin$$Eq$equal$205$(self, other) {
  const _p = self.value;
  const _p$2 = other.value;
  return _p.num === _p$2.num;
}
function moonbitlang$core$builtin$$Eq$equal$208$(self, other) {
  return moonbitlang$core$builtin$$Eq$equal$244$(self.value, other.value);
}
function moonbitlang$core$sorted_set$$SortedSet$new$13$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_set$$SortedSet$new$75$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_set$$SortedSet$new$34$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_set$$SortedSet$new$244$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_set$$height_ge$75$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _n2 = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _n1 = _Some$2;
      return _n1.height >= _n2.height;
    }
  }
}
function moonbitlang$core$sorted_set$$height_ge$13$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _n2 = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _n1 = _Some$2;
      return _n1.height >= _n2.height;
    }
  }
}
function moonbitlang$core$sorted_set$$height_ge$34$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _n2 = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _n1 = _Some$2;
      return _n1.height >= _n2.height;
    }
  }
}
function moonbitlang$core$sorted_set$$height_ge$244$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _n2 = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _n1 = _Some$2;
      return _n1.height >= _n2.height;
    }
  }
}
function moonbitlang$core$sorted_set$$Node$update_height$75$(self) {
  const _p = self.left;
  let _p$2;
  if (_p === undefined) {
    _p$2 = 0;
  } else {
    const _p$3 = _p;
    const _p$4 = _p$3;
    _p$2 = _p$4.height;
  }
  const _p$3 = self.right;
  let _p$4;
  if (_p$3 === undefined) {
    _p$4 = 0;
  } else {
    const _p$5 = _p$3;
    const _p$6 = _p$5;
    _p$4 = _p$6.height;
  }
  self.height = 1 + (_p$2 > _p$4 ? _p$2 : _p$4) | 0;
}
function moonbitlang$core$sorted_set$$Node$update_height$13$(self) {
  const _p = self.left;
  let _p$2;
  if (_p === undefined) {
    _p$2 = 0;
  } else {
    const _p$3 = _p;
    const _p$4 = _p$3;
    _p$2 = _p$4.height;
  }
  const _p$3 = self.right;
  let _p$4;
  if (_p$3 === undefined) {
    _p$4 = 0;
  } else {
    const _p$5 = _p$3;
    const _p$6 = _p$5;
    _p$4 = _p$6.height;
  }
  self.height = 1 + (_p$2 > _p$4 ? _p$2 : _p$4) | 0;
}
function moonbitlang$core$sorted_set$$Node$update_height$34$(self) {
  const _p = self.left;
  let _p$2;
  if (_p === undefined) {
    _p$2 = 0;
  } else {
    const _p$3 = _p;
    const _p$4 = _p$3;
    _p$2 = _p$4.height;
  }
  const _p$3 = self.right;
  let _p$4;
  if (_p$3 === undefined) {
    _p$4 = 0;
  } else {
    const _p$5 = _p$3;
    const _p$6 = _p$5;
    _p$4 = _p$6.height;
  }
  self.height = 1 + (_p$2 > _p$4 ? _p$2 : _p$4) | 0;
}
function moonbitlang$core$sorted_set$$Node$update_height$244$(self) {
  const _p = self.left;
  let _p$2;
  if (_p === undefined) {
    _p$2 = 0;
  } else {
    const _p$3 = _p;
    const _p$4 = _p$3;
    _p$2 = _p$4.height;
  }
  const _p$3 = self.right;
  let _p$4;
  if (_p$3 === undefined) {
    _p$4 = 0;
  } else {
    const _p$5 = _p$3;
    const _p$6 = _p$5;
    _p$4 = _p$6.height;
  }
  self.height = 1 + (_p$2 > _p$4 ? _p$2 : _p$4) | 0;
}
function moonbitlang$core$sorted_set$$rotate_l$75$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_set$$Node$update_height$75$(n);
  moonbitlang$core$sorted_set$$Node$update_height$75$(r);
  return r;
}
function moonbitlang$core$sorted_set$$rotate_l$13$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_set$$Node$update_height$13$(n);
  moonbitlang$core$sorted_set$$Node$update_height$13$(r);
  return r;
}
function moonbitlang$core$sorted_set$$rotate_l$34$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_set$$Node$update_height$34$(n);
  moonbitlang$core$sorted_set$$Node$update_height$34$(r);
  return r;
}
function moonbitlang$core$sorted_set$$rotate_l$244$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_set$$Node$update_height$244$(n);
  moonbitlang$core$sorted_set$$Node$update_height$244$(r);
  return r;
}
function moonbitlang$core$sorted_set$$rotate_r$75$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_set$$Node$update_height$75$(n);
  moonbitlang$core$sorted_set$$Node$update_height$75$(l);
  return l;
}
function moonbitlang$core$sorted_set$$rotate_r$13$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_set$$Node$update_height$13$(n);
  moonbitlang$core$sorted_set$$Node$update_height$13$(l);
  return l;
}
function moonbitlang$core$sorted_set$$rotate_r$34$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_set$$Node$update_height$34$(n);
  moonbitlang$core$sorted_set$$Node$update_height$34$(l);
  return l;
}
function moonbitlang$core$sorted_set$$rotate_r$244$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_set$$Node$update_height$244$(n);
  moonbitlang$core$sorted_set$$Node$update_height$244$(l);
  return l;
}
function moonbitlang$core$sorted_set$$rotate_lr$75$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  const v = moonbitlang$core$sorted_set$$rotate_l$75$(l);
  n.left = v;
  return moonbitlang$core$sorted_set$$rotate_r$75$(n);
}
function moonbitlang$core$sorted_set$$rotate_lr$13$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  const v = moonbitlang$core$sorted_set$$rotate_l$13$(l);
  n.left = v;
  return moonbitlang$core$sorted_set$$rotate_r$13$(n);
}
function moonbitlang$core$sorted_set$$rotate_lr$34$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  const v = moonbitlang$core$sorted_set$$rotate_l$34$(l);
  n.left = v;
  return moonbitlang$core$sorted_set$$rotate_r$34$(n);
}
function moonbitlang$core$sorted_set$$rotate_lr$244$(n) {
  const _p = n.left;
  let l;
  if (_p === undefined) {
    l = $panic();
  } else {
    const _p$2 = _p;
    l = _p$2;
  }
  const v = moonbitlang$core$sorted_set$$rotate_l$244$(l);
  n.left = v;
  return moonbitlang$core$sorted_set$$rotate_r$244$(n);
}
function moonbitlang$core$sorted_set$$rotate_rl$75$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  const v = moonbitlang$core$sorted_set$$rotate_r$75$(r);
  n.right = v;
  return moonbitlang$core$sorted_set$$rotate_l$75$(n);
}
function moonbitlang$core$sorted_set$$rotate_rl$13$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  const v = moonbitlang$core$sorted_set$$rotate_r$13$(r);
  n.right = v;
  return moonbitlang$core$sorted_set$$rotate_l$13$(n);
}
function moonbitlang$core$sorted_set$$rotate_rl$34$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  const v = moonbitlang$core$sorted_set$$rotate_r$34$(r);
  n.right = v;
  return moonbitlang$core$sorted_set$$rotate_l$34$(n);
}
function moonbitlang$core$sorted_set$$rotate_rl$244$(n) {
  const _p = n.right;
  let r;
  if (_p === undefined) {
    r = $panic();
  } else {
    const _p$2 = _p;
    r = _p$2;
  }
  const v = moonbitlang$core$sorted_set$$rotate_r$244$(r);
  n.right = v;
  return moonbitlang$core$sorted_set$$rotate_l$244$(n);
}
function moonbitlang$core$sorted_set$$balance$75$(root) {
  const l = root.left;
  const r = root.right;
  let hl;
  if (l === undefined) {
    hl = 0;
  } else {
    const _p = l;
    const _p$2 = _p;
    hl = _p$2.height;
  }
  let hr;
  if (r === undefined) {
    hr = 0;
  } else {
    const _p = r;
    const _p$2 = _p;
    hr = _p$2.height;
  }
  let new_root;
  if (hl > (hr + 1 | 0)) {
    let _bind;
    if (l === undefined) {
      _bind = $panic();
    } else {
      const _p = l;
      _bind = _p;
    }
    const _ll = _bind.left;
    const _lr = _bind.right;
    new_root = moonbitlang$core$sorted_set$$height_ge$75$(_ll, _lr) ? moonbitlang$core$sorted_set$$rotate_r$75$(root) : moonbitlang$core$sorted_set$$rotate_lr$75$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      let _bind;
      if (r === undefined) {
        _bind = $panic();
      } else {
        const _p = r;
        _bind = _p;
      }
      const _rl = _bind.left;
      const _rr = _bind.right;
      new_root = moonbitlang$core$sorted_set$$height_ge$75$(_rr, _rl) ? moonbitlang$core$sorted_set$$rotate_l$75$(root) : moonbitlang$core$sorted_set$$rotate_rl$75$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_set$$Node$update_height$75$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_set$$balance$13$(root) {
  const l = root.left;
  const r = root.right;
  let hl;
  if (l === undefined) {
    hl = 0;
  } else {
    const _p = l;
    const _p$2 = _p;
    hl = _p$2.height;
  }
  let hr;
  if (r === undefined) {
    hr = 0;
  } else {
    const _p = r;
    const _p$2 = _p;
    hr = _p$2.height;
  }
  let new_root;
  if (hl > (hr + 1 | 0)) {
    let _bind;
    if (l === undefined) {
      _bind = $panic();
    } else {
      const _p = l;
      _bind = _p;
    }
    const _ll = _bind.left;
    const _lr = _bind.right;
    new_root = moonbitlang$core$sorted_set$$height_ge$13$(_ll, _lr) ? moonbitlang$core$sorted_set$$rotate_r$13$(root) : moonbitlang$core$sorted_set$$rotate_lr$13$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      let _bind;
      if (r === undefined) {
        _bind = $panic();
      } else {
        const _p = r;
        _bind = _p;
      }
      const _rl = _bind.left;
      const _rr = _bind.right;
      new_root = moonbitlang$core$sorted_set$$height_ge$13$(_rr, _rl) ? moonbitlang$core$sorted_set$$rotate_l$13$(root) : moonbitlang$core$sorted_set$$rotate_rl$13$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_set$$Node$update_height$13$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_set$$balance$34$(root) {
  const l = root.left;
  const r = root.right;
  let hl;
  if (l === undefined) {
    hl = 0;
  } else {
    const _p = l;
    const _p$2 = _p;
    hl = _p$2.height;
  }
  let hr;
  if (r === undefined) {
    hr = 0;
  } else {
    const _p = r;
    const _p$2 = _p;
    hr = _p$2.height;
  }
  let new_root;
  if (hl > (hr + 1 | 0)) {
    let _bind;
    if (l === undefined) {
      _bind = $panic();
    } else {
      const _p = l;
      _bind = _p;
    }
    const _ll = _bind.left;
    const _lr = _bind.right;
    new_root = moonbitlang$core$sorted_set$$height_ge$34$(_ll, _lr) ? moonbitlang$core$sorted_set$$rotate_r$34$(root) : moonbitlang$core$sorted_set$$rotate_lr$34$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      let _bind;
      if (r === undefined) {
        _bind = $panic();
      } else {
        const _p = r;
        _bind = _p;
      }
      const _rl = _bind.left;
      const _rr = _bind.right;
      new_root = moonbitlang$core$sorted_set$$height_ge$34$(_rr, _rl) ? moonbitlang$core$sorted_set$$rotate_l$34$(root) : moonbitlang$core$sorted_set$$rotate_rl$34$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_set$$Node$update_height$34$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_set$$balance$244$(root) {
  const l = root.left;
  const r = root.right;
  let hl;
  if (l === undefined) {
    hl = 0;
  } else {
    const _p = l;
    const _p$2 = _p;
    hl = _p$2.height;
  }
  let hr;
  if (r === undefined) {
    hr = 0;
  } else {
    const _p = r;
    const _p$2 = _p;
    hr = _p$2.height;
  }
  let new_root;
  if (hl > (hr + 1 | 0)) {
    let _bind;
    if (l === undefined) {
      _bind = $panic();
    } else {
      const _p = l;
      _bind = _p;
    }
    const _ll = _bind.left;
    const _lr = _bind.right;
    new_root = moonbitlang$core$sorted_set$$height_ge$244$(_ll, _lr) ? moonbitlang$core$sorted_set$$rotate_r$244$(root) : moonbitlang$core$sorted_set$$rotate_lr$244$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      let _bind;
      if (r === undefined) {
        _bind = $panic();
      } else {
        const _p = r;
        _bind = _p;
      }
      const _rl = _bind.left;
      const _rr = _bind.right;
      new_root = moonbitlang$core$sorted_set$$height_ge$244$(_rr, _rl) ? moonbitlang$core$sorted_set$$rotate_l$244$(root) : moonbitlang$core$sorted_set$$rotate_rl$244$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_set$$Node$update_height$244$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_set$$new_node$46$inner$75$(value, left, right, height) {
  return { value: value, left: left, right: right, height: height };
}
function moonbitlang$core$sorted_set$$new_node$46$inner$13$(value, left, right, height) {
  return { value: value, left: left, right: right, height: height };
}
function moonbitlang$core$sorted_set$$new_node$46$inner$34$(value, left, right, height) {
  return { value: value, left: left, right: right, height: height };
}
function moonbitlang$core$sorted_set$$new_node$46$inner$244$(value, left, right, height) {
  return { value: value, left: left, right: right, height: height };
}
function moonbitlang$core$sorted_set$$new_node$75$(value, left$46$opt, right$46$opt, height$46$opt) {
  let left;
  if (left$46$opt.$tag === 1) {
    const _Some = left$46$opt;
    left = _Some._0;
  } else {
    left = undefined;
  }
  let right;
  if (right$46$opt.$tag === 1) {
    const _Some = right$46$opt;
    right = _Some._0;
  } else {
    right = undefined;
  }
  let height;
  if (height$46$opt === undefined) {
    height = 1;
  } else {
    const _Some = height$46$opt;
    height = _Some;
  }
  return moonbitlang$core$sorted_set$$new_node$46$inner$75$(value, left, right, height);
}
function moonbitlang$core$sorted_set$$new_node$13$(value, left$46$opt, right$46$opt, height$46$opt) {
  let left;
  if (left$46$opt.$tag === 1) {
    const _Some = left$46$opt;
    left = _Some._0;
  } else {
    left = undefined;
  }
  let right;
  if (right$46$opt.$tag === 1) {
    const _Some = right$46$opt;
    right = _Some._0;
  } else {
    right = undefined;
  }
  let height;
  if (height$46$opt === undefined) {
    height = 1;
  } else {
    const _Some = height$46$opt;
    height = _Some;
  }
  return moonbitlang$core$sorted_set$$new_node$46$inner$13$(value, left, right, height);
}
function moonbitlang$core$sorted_set$$new_node$34$(value, left$46$opt, right$46$opt, height$46$opt) {
  let left;
  if (left$46$opt.$tag === 1) {
    const _Some = left$46$opt;
    left = _Some._0;
  } else {
    left = undefined;
  }
  let right;
  if (right$46$opt.$tag === 1) {
    const _Some = right$46$opt;
    right = _Some._0;
  } else {
    right = undefined;
  }
  let height;
  if (height$46$opt === undefined) {
    height = 1;
  } else {
    const _Some = height$46$opt;
    height = _Some;
  }
  return moonbitlang$core$sorted_set$$new_node$46$inner$34$(value, left, right, height);
}
function moonbitlang$core$sorted_set$$new_node$244$(value, left$46$opt, right$46$opt, height$46$opt) {
  let left;
  if (left$46$opt.$tag === 1) {
    const _Some = left$46$opt;
    left = _Some._0;
  } else {
    left = undefined;
  }
  let right;
  if (right$46$opt.$tag === 1) {
    const _Some = right$46$opt;
    right = _Some._0;
  } else {
    right = undefined;
  }
  let height;
  if (height$46$opt === undefined) {
    height = 1;
  } else {
    const _Some = height$46$opt;
    height = _Some;
  }
  return moonbitlang$core$sorted_set$$new_node$46$inner$244$(value, left, right, height);
}
function moonbitlang$core$sorted_set$$add_node$75$(root, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_set$$new_node$75$(value, Option$None$29$, Option$None$29$, undefined), _1: true };
  } else {
    const _Some = root;
    const _n = _Some;
    const comp = moonbitlang$core$builtin$$Compare$compare$75$(value, _n.value);
    if (comp === 0) {
      _n.value = value;
      return { _0: _n, _1: false };
    } else {
      const l = _n.left;
      const r = _n.right;
      if (comp < 0) {
        const _bind = moonbitlang$core$sorted_set$$add_node$75$(l, value);
        const _nl = _bind._0;
        const _inserted = _bind._1;
        _n.left = _nl;
        return { _0: moonbitlang$core$sorted_set$$balance$75$(_n), _1: _inserted };
      } else {
        const _bind = moonbitlang$core$sorted_set$$add_node$75$(r, value);
        const _nr = _bind._0;
        const _inserted = _bind._1;
        _n.right = _nr;
        return { _0: moonbitlang$core$sorted_set$$balance$75$(_n), _1: _inserted };
      }
    }
  }
}
function moonbitlang$core$sorted_set$$add_node$13$(root, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_set$$new_node$13$(value, Option$None$30$, Option$None$30$, undefined), _1: true };
  } else {
    const _Some = root;
    const _n = _Some;
    const comp = moonbitlang$core$builtin$$Compare$compare$13$(value, _n.value);
    if (comp === 0) {
      _n.value = value;
      return { _0: _n, _1: false };
    } else {
      const l = _n.left;
      const r = _n.right;
      if (comp < 0) {
        const _bind = moonbitlang$core$sorted_set$$add_node$13$(l, value);
        const _nl = _bind._0;
        const _inserted = _bind._1;
        _n.left = _nl;
        return { _0: moonbitlang$core$sorted_set$$balance$13$(_n), _1: _inserted };
      } else {
        const _bind = moonbitlang$core$sorted_set$$add_node$13$(r, value);
        const _nr = _bind._0;
        const _inserted = _bind._1;
        _n.right = _nr;
        return { _0: moonbitlang$core$sorted_set$$balance$13$(_n), _1: _inserted };
      }
    }
  }
}
function moonbitlang$core$sorted_set$$add_node$34$(root, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_set$$new_node$34$(value, Option$None$31$, Option$None$31$, undefined), _1: true };
  } else {
    const _Some = root;
    const _n = _Some;
    const _p = _n.value;
    const comp = $compare_int(value.num, _p.num);
    if (comp === 0) {
      _n.value = value;
      return { _0: _n, _1: false };
    } else {
      const l = _n.left;
      const r = _n.right;
      if (comp < 0) {
        const _bind = moonbitlang$core$sorted_set$$add_node$34$(l, value);
        const _nl = _bind._0;
        const _inserted = _bind._1;
        _n.left = _nl;
        return { _0: moonbitlang$core$sorted_set$$balance$34$(_n), _1: _inserted };
      } else {
        const _bind = moonbitlang$core$sorted_set$$add_node$34$(r, value);
        const _nr = _bind._0;
        const _inserted = _bind._1;
        _n.right = _nr;
        return { _0: moonbitlang$core$sorted_set$$balance$34$(_n), _1: _inserted };
      }
    }
  }
}
function moonbitlang$core$sorted_set$$add_node$244$(root, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_set$$new_node$244$(value, Option$None$32$, Option$None$32$, undefined), _1: true };
  } else {
    const _Some = root;
    const _n = _Some;
    const comp = moonbitlang$core$builtin$$Compare$compare$244$(value, _n.value);
    if (comp === 0) {
      _n.value = value;
      return { _0: _n, _1: false };
    } else {
      const l = _n.left;
      const r = _n.right;
      if (comp < 0) {
        const _bind = moonbitlang$core$sorted_set$$add_node$244$(l, value);
        const _nl = _bind._0;
        const _inserted = _bind._1;
        _n.left = _nl;
        return { _0: moonbitlang$core$sorted_set$$balance$244$(_n), _1: _inserted };
      } else {
        const _bind = moonbitlang$core$sorted_set$$add_node$244$(r, value);
        const _nr = _bind._0;
        const _inserted = _bind._1;
        _n.right = _nr;
        return { _0: moonbitlang$core$sorted_set$$balance$244$(_n), _1: _inserted };
      }
    }
  }
}
function moonbitlang$core$sorted_set$$SortedSet$add$75$(self, value) {
  const _bind = moonbitlang$core$sorted_set$$add_node$75$(self.root, value);
  const _new_root = _bind._0;
  const _inserted = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$91$(self.root, _new_root)) {
    self.root = _new_root;
  }
  if (_inserted) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_set$$SortedSet$add$13$(self, value) {
  const _bind = moonbitlang$core$sorted_set$$add_node$13$(self.root, value);
  const _new_root = _bind._0;
  const _inserted = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$93$(self.root, _new_root)) {
    self.root = _new_root;
  }
  if (_inserted) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_set$$SortedSet$add$34$(self, value) {
  const _bind = moonbitlang$core$sorted_set$$add_node$34$(self.root, value);
  const _new_root = _bind._0;
  const _inserted = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$95$(self.root, _new_root)) {
    self.root = _new_root;
  }
  if (_inserted) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_set$$SortedSet$add$244$(self, value) {
  const _bind = moonbitlang$core$sorted_set$$add_node$244$(self.root, value);
  const _new_root = _bind._0;
  const _inserted = _bind._1;
  if (moonbitlang$core$builtin$$Eq$not_equal$102$(self.root, _new_root)) {
    self.root = _new_root;
  }
  if (_inserted) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_set$$SortedSet$contains$244$(self, value) {
  const _bind = self.root;
  let _tmp = _bind;
  while (true) {
    const _param_0 = _tmp;
    if (_param_0 === undefined) {
      return false;
    } else {
      const _Some = _param_0;
      const _node = _Some;
      const compare_result = moonbitlang$core$builtin$$Compare$compare$244$(value, _node.value);
      if (compare_result === 0) {
        return true;
      } else {
        if (compare_result < 0) {
          _tmp = _node.left;
          continue;
        } else {
          _tmp = _node.right;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_set$$SortedSet$iter$75$(self) {
  const curr_node = { val: self.root };
  const parents = [];
  const _p = () => {
    let _tmp = curr_node.val;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        const _bind = moonbitlang$core$array$$Array$pop$145$(parents);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _value = _x._0;
          const _right = _x._1;
          curr_node.val = _right;
          return _value;
        }
      } else {
        const _Some = _param;
        const _x = _Some;
        const _x$2 = _x.left;
        if (_x$2 === undefined) {
          const _value = _x.value;
          const _right = _x.right;
          curr_node.val = _right;
          return _value;
        } else {
          const _value = _x.value;
          const _right = _x.right;
          moonbitlang$core$array$$Array$push$145$(parents, { _0: _value, _1: _right });
          _tmp = _x$2;
          continue;
        }
      }
    }
  };
  return _p;
}
function moonbitlang$core$sorted_set$$SortedSet$iter$13$(self) {
  const curr_node = { val: self.root };
  const parents = [];
  const _p = () => {
    let _tmp = curr_node.val;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        const _bind = moonbitlang$core$array$$Array$pop$147$(parents);
        if (_bind === undefined) {
          return undefined;
        } else {
          const _Some = _bind;
          const _x = _Some;
          const _value = _x._0;
          const _right = _x._1;
          curr_node.val = _right;
          return _value;
        }
      } else {
        const _Some = _param;
        const _x = _Some;
        const _x$2 = _x.left;
        if (_x$2 === undefined) {
          const _value = _x.value;
          const _right = _x.right;
          curr_node.val = _right;
          return _value;
        } else {
          const _value = _x.value;
          const _right = _x.right;
          moonbitlang$core$array$$Array$push$147$(parents, { _0: _value, _1: _right });
          _tmp = _x$2;
          continue;
        }
      }
    }
  };
  return _p;
}
function moonbitlang$core$sorted_set$$to_array$46$dfs$47$5605(_env, root) {
  const arr = _env._1;
  const i = _env._0;
  let _tmp = root;
  while (true) {
    const root$2 = _tmp;
    if (root$2 === undefined) {
      return;
    } else {
      const _Some = root$2;
      const _root = _Some;
      moonbitlang$core$sorted_set$$to_array$46$dfs$47$5605(_env, _root.left);
      moonbitlang$core$array$$Array$set$34$(arr, i.val, _root.value);
      i.val = i.val + 1 | 0;
      _tmp = _root.right;
      continue;
    }
  }
}
function moonbitlang$core$sorted_set$$SortedSet$to_array$34$(self) {
  if (self.size === 0) {
    return [];
  } else {
    const _p = self.root;
    let _tmp;
    if (_p === undefined) {
      _tmp = $panic();
    } else {
      const _p$2 = _p;
      _tmp = _p$2;
    }
    const padding = _tmp.value;
    const arr = moonbitlang$core$array$$Array$make$34$(self.size, padding);
    const i = { val: 0 };
    const _env = { _0: i, _1: arr };
    moonbitlang$core$sorted_set$$to_array$46$dfs$47$5605(_env, self.root);
    return arr;
  }
}
function Yoorkin$trie$$Trie$lookup$245$(self, path) {
  let _tmp = moonbitlang$core$string$$String$view$46$inner(path, 0, undefined);
  let _tmp$2 = self;
  while (true) {
    const _param_0 = _tmp;
    const _param_1 = _tmp$2;
    if (moonbitlang$core$string$$String$char_length_eq$46$inner(_param_0.str, 0, _param_0.start, _param_0.end)) {
      return _param_1.value;
    } else {
      const _x = moonbitlang$core$string$$String$unsafe_char_at(_param_0.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 0, _param_0.start, _param_0.end));
      const _tmp$3 = _param_0.str;
      const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(_param_0.str, 1, _param_0.start, _param_0.end);
      let _tmp$4;
      if (_bind === undefined) {
        _tmp$4 = _param_0.end;
      } else {
        const _Some = _bind;
        _tmp$4 = _Some;
      }
      const _tmp$5 = _tmp$4;
      const _x$2 = { str: _tmp$3, start: _tmp$5, end: _param_0.end };
      const _bind$2 = moonbitlang$core$immut$sorted_map$$SortedMap$get$240$(_param_1.forks, _x);
      if (_bind$2 === undefined) {
        return undefined;
      } else {
        const _Some = _bind$2;
        const _subtree = _Some;
        _tmp = _x$2;
        _tmp$2 = _subtree;
        continue;
      }
    }
  }
}
function Yoorkin$trie$$add$46$aux$47$5630(value, xs, trie) {
  if (moonbitlang$core$string$$String$char_length_eq$46$inner(xs.str, 0, xs.start, xs.end)) {
    return { value: value, forks: trie.forks };
  } else {
    const _x = moonbitlang$core$string$$String$unsafe_char_at(xs.str, moonbitlang$core$string$$String$offset_of_nth_char$46$inner(xs.str, 0, xs.start, xs.end));
    const _tmp = xs.str;
    const _bind = moonbitlang$core$string$$String$offset_of_nth_char$46$inner(xs.str, 1, xs.start, xs.end);
    let _tmp$2;
    if (_bind === undefined) {
      _tmp$2 = xs.end;
    } else {
      const _Some = _bind;
      _tmp$2 = _Some;
    }
    const _tmp$3 = _tmp$2;
    const _x$2 = { str: _tmp, start: _tmp$3, end: xs.end };
    const subtree = moonbitlang$core$option$$Option$unwrap_or_else$210$(moonbitlang$core$immut$sorted_map$$SortedMap$get$240$(trie.forks, _x), () => ({ value: undefined, forks: $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$25$ }));
    return { value: trie.value, forks: moonbitlang$core$immut$sorted_map$$SortedMap$add$240$(trie.forks, _x, Yoorkin$trie$$add$46$aux$47$5630(value, _x$2, subtree)) };
  }
}
function Yoorkin$trie$$Trie$add$245$(self, path, value) {
  return Yoorkin$trie$$add$46$aux$47$5630(value, moonbitlang$core$string$$String$view$46$inner(path, 0, undefined), self);
}
function Yoorkin$trie$$Trie$empty$245$() {
  return { value: undefined, forks: $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$25$ };
}
function Yoorkin$ArgParser$$interpret(trie, xs, fallback) {
  const _bind = xs.length;
  let _tmp = 0;
  _L: while (true) {
    const _param_start = _tmp;
    if ((_bind - _param_start | 0) === 0) {
      break;
    } else {
      const _x = xs[_param_start];
      const _bind$2 = 1 + _param_start | 0;
      const _bind$3 = Yoorkin$trie$$Trie$lookup$245$(trie, _x);
      if (_bind$3 === undefined) {
        const _bind$4 = fallback(_x);
        if (_bind$4.$tag === 1) {
          const _ok = _bind$4;
          _ok._0;
        } else {
          return _bind$4;
        }
        _tmp = _bind$2;
        continue;
      } else {
        const _Some = _bind$3;
        const _spec = _Some;
        _L$2: {
          switch (_spec.$tag) {
            case 1: {
              const _String = _spec;
              const _f = _String._0;
              if ((_bind - _bind$2 | 0) >= 1) {
                const _y = xs[_bind$2];
                const _bind$4 = 1 + _bind$2 | 0;
                const _bind$5 = _f(_y);
                if (_bind$5.$tag === 1) {
                  const _ok = _bind$5;
                  _ok._0;
                } else {
                  return _bind$5;
                }
                _tmp = _bind$4;
                continue _L;
              } else {
                break _L$2;
              }
            }
            case 2: {
              const _Set_string = _spec;
              const _r = _Set_string._0;
              if ((_bind - _bind$2 | 0) >= 1) {
                const _y = xs[_bind$2];
                const _bind$4 = 1 + _bind$2 | 0;
                _r.val = _y;
                _tmp = _bind$4;
                continue _L;
              } else {
                break _L$2;
              }
            }
            case 3: {
              const _Set = _spec;
              const _r$2 = _Set._0;
              _r$2.val = true;
              _tmp = _bind$2;
              continue _L;
            }
            case 4: {
              const _Clear = _spec;
              const _r$3 = _Clear._0;
              _r$3.val = false;
              _tmp = _bind$2;
              continue _L;
            }
            default: {
              const _Unit = _spec;
              const _f$2 = _Unit._0;
              const _bind$4 = _f$2();
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _ok._0;
              } else {
                return _bind$4;
              }
              _tmp = _bind$2;
              continue _L;
            }
          }
        }
        return new Result$Err$34$(new Error$Yoorkin$47$ArgParser$46$ErrorMsg$46$ErrorMsg(`missing argument for ${_x}`));
      }
    }
  }
  return new Result$Ok$33$(undefined);
}
function Yoorkin$ArgParser$$parse$46$aux$124$15(acc, it) {
  const _trie = acc._0;
  const _help_msg = acc._1;
  const _a = it._0;
  const _b = it._1;
  const _spec = it._2;
  const _help = it._3;
  const trie = Yoorkin$trie$$Trie$add$245$(Yoorkin$trie$$Trie$add$245$(_trie, _a, _spec), _b, _spec);
  const help_msg = `${_help_msg}  ${_a}\t${_b}\t${_help}\n`;
  return { _0: trie, _1: help_msg };
}
function Yoorkin$ArgParser$$parse(speclist, rest, usage_msg, argv) {
  const _p = { _0: Yoorkin$trie$$Trie$empty$245$(), _1: `${usage_msg}\n options:\n` };
  let _bind;
  let _tmp = 0;
  let _tmp$2 = _p;
  while (true) {
    const _p$2 = _tmp;
    const _p$3 = _tmp$2;
    if (_p$2 < speclist.length) {
      _tmp = _p$2 + 1 | 0;
      _tmp$2 = Yoorkin$ArgParser$$parse$46$aux$124$15(_p$3, moonbitlang$core$array$$Array$at$66$(speclist, _p$2));
      continue;
    } else {
      _bind = _p$3;
      break;
    }
  }
  const _trie = _bind._0;
  const _help_msg = _bind._1;
  const help_spec = new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => new Result$Err$34$(new Error$Yoorkin$47$ArgParser$46$ErrorMsg$46$ErrorMsg(_help_msg)));
  const trie = Yoorkin$trie$$Trie$add$245$(Yoorkin$trie$$Trie$add$245$(_trie, "--help", help_spec), "-h", help_spec);
  return Yoorkin$ArgParser$$interpret(trie, argv, rest);
}
function moonbitlang$x$internal$ffi$$mbt_string_to_utf8_bytes(str, is_filename) {
  const res = [];
  const len = str.length;
  let i = 0;
  while (true) {
    if (i < len) {
      const _tmp = i;
      $bound_check(str, _tmp);
      let c = str.charCodeAt(_tmp);
      if (55296 <= c && c <= 56319) {
        c = c - 55296 | 0;
        i = i + 1 | 0;
        const _tmp$2 = i;
        $bound_check(str, _tmp$2);
        const l = str.charCodeAt(_tmp$2) - 56320 | 0;
        c = ((c << 10) + l | 0) + 65536 | 0;
      }
      if (c < 128) {
        moonbitlang$core$array$$Array$push$30$(res, c & 255);
      } else {
        if (c < 2048) {
          moonbitlang$core$array$$Array$push$30$(res, (192 + (c >> 6) | 0) & 255);
          moonbitlang$core$array$$Array$push$30$(res, (128 + (c & 63) | 0) & 255);
        } else {
          if (c < 65536) {
            moonbitlang$core$array$$Array$push$30$(res, (224 + (c >> 12) | 0) & 255);
            moonbitlang$core$array$$Array$push$30$(res, (128 + (c >> 6 & 63) | 0) & 255);
            moonbitlang$core$array$$Array$push$30$(res, (128 + (c & 63) | 0) & 255);
          } else {
            moonbitlang$core$array$$Array$push$30$(res, (240 + (c >> 18) | 0) & 255);
            moonbitlang$core$array$$Array$push$30$(res, (128 + (c >> 12 & 63) | 0) & 255);
            moonbitlang$core$array$$Array$push$30$(res, (128 + (c >> 6 & 63) | 0) & 255);
            moonbitlang$core$array$$Array$push$30$(res, (128 + (c & 63) | 0) & 255);
          }
        }
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (is_filename) {
    moonbitlang$core$array$$Array$push$30$(res, 0 & 255);
  }
  return moonbitlang$core$bytes$$Bytes$from_array({ buf: res, start: 0, end: res.length });
}
function moonbitlang$x$internal$ffi$$utf8_bytes_to_mbt_string(bytes) {
  const res = [];
  const len = bytes.length;
  let i = 0;
  while (true) {
    if (i < len) {
      const _tmp = i;
      $bound_check(bytes, _tmp);
      let c = bytes[_tmp];
      if (c < 128) {
        moonbitlang$core$array$$Array$push$59$(res, c);
        i = i + 1 | 0;
      } else {
        if (c < 224) {
          if ((i + 1 | 0) >= len) {
            break;
          }
          const _tmp$2 = (c & 31) << 6;
          const _tmp$3 = i + 1 | 0;
          $bound_check(bytes, _tmp$3);
          c = _tmp$2 | bytes[_tmp$3] & 63;
          moonbitlang$core$array$$Array$push$59$(res, c);
          i = i + 2 | 0;
        } else {
          if (c < 240) {
            if ((i + 2 | 0) >= len) {
              break;
            }
            const _tmp$2 = (c & 15) << 12;
            const _tmp$3 = i + 1 | 0;
            $bound_check(bytes, _tmp$3);
            const _tmp$4 = _tmp$2 | (bytes[_tmp$3] & 63) << 6;
            const _tmp$5 = i + 2 | 0;
            $bound_check(bytes, _tmp$5);
            c = _tmp$4 | bytes[_tmp$5] & 63;
            moonbitlang$core$array$$Array$push$59$(res, c);
            i = i + 3 | 0;
          } else {
            if ((i + 3 | 0) >= len) {
              break;
            }
            const _tmp$2 = (c & 7) << 18;
            const _tmp$3 = i + 1 | 0;
            $bound_check(bytes, _tmp$3);
            const _tmp$4 = _tmp$2 | (bytes[_tmp$3] & 63) << 12;
            const _tmp$5 = i + 2 | 0;
            $bound_check(bytes, _tmp$5);
            const _tmp$6 = _tmp$4 | (bytes[_tmp$5] & 63) << 6;
            const _tmp$7 = i + 3 | 0;
            $bound_check(bytes, _tmp$7);
            c = _tmp$6 | bytes[_tmp$7] & 63;
            c = c - 65536 | 0;
            moonbitlang$core$array$$Array$push$59$(res, (c >> 10) + 55296 | 0);
            moonbitlang$core$array$$Array$push$59$(res, (c & 1023) + 56320 | 0);
            i = i + 4 | 0;
          }
        }
      }
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$string$$String$from_array({ buf: res, start: 0, end: res.length });
}
function moonbitlang$core$builtin$$Show$output$116$(_x_51, _x_52) {
  const _IOError = _x_51;
  const _$42$err_payload_53 = _IOError._0;
  _x_52.method_table.method_0(_x_52.self, "IOError(");
  moonbitlang$core$builtin$$Logger$write_object$13$(_x_52, _$42$err_payload_53);
  _x_52.method_table.method_0(_x_52.self, ")");
}
function moonbitlang$x$fs$$read_file_to_bytes_internal(path) {
  const res = moonbitlang$x$fs$$read_file_ffi(path);
  if (res === -1) {
    return new Result$Err$35$(new Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(moonbitlang$x$fs$$get_error_message_ffi()));
  }
  return new Result$Ok$35$(moonbitlang$x$fs$$get_file_content_ffi());
}
function moonbitlang$x$fs$$read_file_to_string_internal$46$inner(path, encoding) {
  if (encoding === "utf8") {
    const _bind = moonbitlang$x$fs$$read_file_to_bytes_internal(path);
    let bytes;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      bytes = _ok._0;
    } else {
      return _bind;
    }
    return new Result$Ok$36$(moonbitlang$x$internal$ffi$$utf8_bytes_to_mbt_string(bytes));
  } else {
    return new Result$Err$36$(new Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(`Unsupported encoding: ${encoding}, only utf8 is supported for now`));
  }
}
function moonbitlang$x$fs$$write_bytes_to_file_internal(path, content) {
  const res = moonbitlang$x$fs$$write_file_ffi(path, content);
  if (res === -1) {
    return new Result$Err$37$(new Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(moonbitlang$x$fs$$get_error_message_ffi()));
  } else {
    return new Result$Ok$37$(undefined);
  }
}
function moonbitlang$x$fs$$write_string_to_file_internal$46$inner(path, content, encoding) {
  if (encoding === "utf8") {
    const bytes = moonbitlang$x$internal$ffi$$mbt_string_to_utf8_bytes(content, false);
    return moonbitlang$x$fs$$write_bytes_to_file_internal(path, bytes);
  } else {
    return new Result$Err$37$(new Error$moonbitlang$47$x$47$fs$46$IOError$46$IOError(`Unsupported encoding: ${encoding}, only utf8 is supported for now`));
  }
}
function moonbitlang$x$fs$$read_file_to_string$46$inner(path, encoding) {
  return moonbitlang$x$fs$$read_file_to_string_internal$46$inner(path, encoding);
}
function moonbitlang$x$fs$$write_string_to_file$46$inner(path, content, encoding) {
  return moonbitlang$x$fs$$write_string_to_file_internal$46$inner(path, content, encoding);
}
function moonbitlang$x$sys$internal$ffi$$get_cli_args() {
  return moonbitlang$x$sys$internal$ffi$$get_cli_args_internal();
}
function moonbitlang$x$sys$$get_cli_args() {
  return moonbitlang$x$sys$internal$ffi$$get_cli_args();
}
function moonbitlang$core$builtin$$Eq$equal$244$(_x_354, _x_355) {
  switch (_x_354.$tag) {
    case 0: {
      const _Dollar = _x_354;
      const _$42$x0_356 = _Dollar._0;
      if (_x_355.$tag === 0) {
        const _Dollar$2 = _x_355;
        const _$42$y0_357 = _Dollar$2._0;
        return _$42$x0_356 === _$42$y0_357;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_355.$tag === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_355.$tag === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      if (_x_355.$tag === 3) {
        return true;
      } else {
        return false;
      }
    }
    case 4: {
      const _StartPosOf = _x_354;
      const _$42$x0_358 = _StartPosOf._0;
      if (_x_355.$tag === 4) {
        const _StartPosOf$2 = _x_355;
        const _$42$y0_359 = _StartPosOf$2._0;
        return moonbitlang$core$builtin$$Eq$equal$246$(_$42$x0_358, _$42$y0_359);
      } else {
        return false;
      }
    }
    case 5: {
      const _EndPosOf = _x_354;
      const _$42$x0_360 = _EndPosOf._0;
      if (_x_355.$tag === 5) {
        const _EndPosOf$2 = _x_355;
        const _$42$y0_361 = _EndPosOf$2._0;
        return moonbitlang$core$builtin$$Eq$equal$246$(_$42$x0_360, _$42$y0_361);
      } else {
        return false;
      }
    }
    case 6: {
      const _LocOf = _x_354;
      const _$42$x0_362 = _LocOf._0;
      if (_x_355.$tag === 6) {
        const _LocOf$2 = _x_355;
        const _$42$y0_363 = _LocOf$2._0;
        return moonbitlang$core$builtin$$Eq$equal$246$(_$42$x0_362, _$42$y0_363);
      } else {
        return false;
      }
    }
    case 7: {
      if (_x_355.$tag === 7) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_355.$tag === 8) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$244$(_x_334, _x_335) {
  switch (_x_334.$tag) {
    case 0: {
      const _Dollar = _x_334;
      const _$42$x0_336 = _Dollar._0;
      if (_x_335.$tag === 0) {
        const _Dollar$2 = _x_335;
        const _$42$y0_337 = _Dollar$2._0;
        return $compare_int(_$42$x0_336, _$42$y0_337);
      } else {
        return -1;
      }
    }
    case 1: {
      switch (_x_335.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 0;
        }
        default: {
          return -1;
        }
      }
    }
    case 2: {
      switch (_x_335.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 0;
        }
        default: {
          return -1;
        }
      }
    }
    case 3: {
      switch (_x_335.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 0;
        }
        default: {
          return -1;
        }
      }
    }
    case 4: {
      const _StartPosOf = _x_334;
      const _$42$x0_338 = _StartPosOf._0;
      switch (_x_335.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          const _StartPosOf$2 = _x_335;
          const _$42$y0_339 = _StartPosOf$2._0;
          return moonbitlang$core$builtin$$Compare$compare$246$(_$42$x0_338, _$42$y0_339);
        }
        default: {
          return -1;
        }
      }
    }
    case 5: {
      const _EndPosOf = _x_334;
      const _$42$x0_340 = _EndPosOf._0;
      switch (_x_335.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          return 1;
        }
        case 5: {
          const _EndPosOf$2 = _x_335;
          const _$42$y0_341 = _EndPosOf$2._0;
          return moonbitlang$core$builtin$$Compare$compare$246$(_$42$x0_340, _$42$y0_341);
        }
        default: {
          return -1;
        }
      }
    }
    case 6: {
      const _LocOf = _x_334;
      const _$42$x0_342 = _LocOf._0;
      switch (_x_335.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          return 1;
        }
        case 5: {
          return 1;
        }
        case 6: {
          const _LocOf$2 = _x_335;
          const _$42$y0_343 = _LocOf$2._0;
          return moonbitlang$core$builtin$$Compare$compare$246$(_$42$x0_342, _$42$y0_343);
        }
        default: {
          return -1;
        }
      }
    }
    case 7: {
      switch (_x_335.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          return 1;
        }
        case 5: {
          return 1;
        }
        case 6: {
          return 1;
        }
        case 7: {
          return 0;
        }
        default: {
          return -1;
        }
      }
    }
    default: {
      switch (_x_335.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          return 1;
        }
        case 5: {
          return 1;
        }
        case 6: {
          return 1;
        }
        case 7: {
          return 1;
        }
        default: {
          return 0;
        }
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$246$(_x_288, _x_289) {
  if (_x_288.$tag === 0) {
    const _Dollar = _x_288;
    const _$42$x0_290 = _Dollar._0;
    if (_x_289.$tag === 0) {
      const _Dollar$2 = _x_289;
      const _$42$y0_291 = _Dollar$2._0;
      return _$42$x0_290 === _$42$y0_291;
    } else {
      return false;
    }
  } else {
    const _Name = _x_288;
    const _$42$x0_292 = _Name._0;
    if (_x_289.$tag === 1) {
      const _Name$2 = _x_289;
      const _$42$y0_293 = _Name$2._0;
      return _$42$x0_292 === _$42$y0_293;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$246$(_x_276, _x_277) {
  if (_x_276.$tag === 0) {
    const _Dollar = _x_276;
    const _$42$x0_278 = _Dollar._0;
    if (_x_277.$tag === 0) {
      const _Dollar$2 = _x_277;
      const _$42$y0_279 = _Dollar$2._0;
      return $compare_int(_$42$x0_278, _$42$y0_279);
    } else {
      return -1;
    }
  } else {
    const _Name = _x_276;
    const _$42$x0_280 = _Name._0;
    if (_x_277.$tag === 0) {
      return 1;
    } else {
      const _Name$2 = _x_277;
      const _$42$y0_281 = _Name$2._0;
      return moonbitlang$core$builtin$$Compare$compare$13$(_$42$x0_280, _$42$y0_281);
    }
  }
}
function moonbitlang$core$builtin$$Show$output$51$(_x_212, _x_213) {
  switch (_x_212.$tag) {
    case 0: {
      const _Constr = _x_212;
      const _$42$arg_214 = _Constr._0;
      const _$42$arg_215 = _Constr._1;
      const _$42$arg_216 = _Constr._2;
      _x_213.method_table.method_0(_x_213.self, "Constr(");
      _x_213.method_table.method_0(_x_213.self, "pkg=");
      moonbitlang$core$builtin$$Logger$write_object$47$(_x_213, _$42$arg_214);
      _x_213.method_table.method_0(_x_213.self, ", ");
      moonbitlang$core$builtin$$Logger$write_object$13$(_x_213, _$42$arg_215);
      _x_213.method_table.method_0(_x_213.self, ", ");
      moonbitlang$core$builtin$$Logger$write_object$49$(_x_213, _$42$arg_216);
      _x_213.method_table.method_0(_x_213.self, ")");
      return;
    }
    case 1: {
      const _Option = _x_212;
      const _$42$arg_217 = _Option._0;
      _x_213.method_table.method_0(_x_213.self, "Option(");
      moonbitlang$core$builtin$$Logger$write_object$51$(_x_213, _$42$arg_217);
      _x_213.method_table.method_0(_x_213.self, ")");
      return;
    }
    case 2: {
      const _Tuple = _x_212;
      const _$42$arg_218 = _Tuple._0;
      _x_213.method_table.method_0(_x_213.self, "Tuple(");
      moonbitlang$core$builtin$$Logger$write_object$49$(_x_213, _$42$arg_218);
      _x_213.method_table.method_0(_x_213.self, ")");
      return;
    }
    default: {
      const _Arrow = _x_212;
      const _$42$arg_219 = _Arrow._0;
      const _$42$arg_220 = _Arrow._1;
      _x_213.method_table.method_0(_x_213.self, "Arrow(");
      moonbitlang$core$builtin$$Logger$write_object$49$(_x_213, _$42$arg_219);
      _x_213.method_table.method_0(_x_213.self, ", ");
      moonbitlang$core$builtin$$Logger$write_object$51$(_x_213, _$42$arg_220);
      _x_213.method_table.method_0(_x_213.self, ")");
      return;
    }
  }
}
function moonbitlang$yacc$lib$ast$$print_spec$46$inner$46$term_to_string$124$82(term) {
  switch (term.$tag) {
    case 0: {
      const _Symbol = term;
      return _Symbol._0;
    }
    case 1: {
      const _Image = term;
      return _Image._0;
    }
    default: {
      const _RuleCall = term;
      const _symbol = _RuleCall._0;
      const _args = _RuleCall._2;
      const args = moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$177$(moonbitlang$core$array$$Array$iter$159$(_args), moonbitlang$yacc$lib$ast$$print_spec$46$inner$46$term_to_string$124$82), ", ");
      return `${_symbol}(${args})`;
    }
  }
}
function moonbitlang$yacc$lib$ast$$print_spec$46$inner(spec, out, actions) {
  let header = undefined;
  let trailer = undefined;
  const start_decls = [];
  const normal_decls = [];
  const prec_decls = [];
  const _arr = spec.decls;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const decl = _arr[_i];
      let decl$2;
      _L: {
        _L$2: {
          switch (decl.$tag) {
            case 2: {
              const _Start = decl;
              moonbitlang$core$array$$Array$push$131$(start_decls, _Start);
              break;
            }
            case 0: {
              const _Header = decl;
              const _code = _Header._0;
              header = _code;
              break;
            }
            case 1: {
              const _Trailer = decl;
              const _code$2 = _Trailer._0;
              trailer = _code$2;
              break;
            }
            case 8: {
              decl$2 = decl;
              break _L$2;
            }
            case 9: {
              decl$2 = decl;
              break _L$2;
            }
            case 10: {
              decl$2 = decl;
              break _L$2;
            }
            default: {
              moonbitlang$core$array$$Array$push$131$(normal_decls, decl);
            }
          }
          break _L;
        }
        moonbitlang$core$array$$Array$push$131$(prec_decls, decl$2);
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _len$2 = start_decls.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const decl = start_decls[_i];
      if (decl.$tag === 2) {
        const _Start = decl;
        const _symbols = _Start._0;
        const _type_ = _Start._1;
        moonbitlang$core$builtin$$Logger$write_string$3$(out, "%start");
        if (!actions) {
          moonbitlang$core$builtin$$Logger$write_string$3$(out, "<unit>");
        } else {
          moonbitlang$core$builtin$$Logger$write_string$3$(out, `<${moonbitlang$core$builtin$$Show$to_string$120$(_type_)}>`);
        }
        const _len$3 = _symbols.length;
        let _tmp$3 = 0;
        while (true) {
          const _i$2 = _tmp$3;
          if (_i$2 < _len$3) {
            const symbol = _symbols[_i$2];
            moonbitlang$core$builtin$$Logger$write_string$3$(out, " ");
            moonbitlang$core$builtin$$Logger$write_string$3$(out, symbol.symbol);
            _tmp$3 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n");
      } else {
        $panic();
      }
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (!(start_decls.length === 0)) {
    moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n");
  }
  const _len$3 = normal_decls.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$3) {
      const decl = normal_decls[_i];
      _L: {
        _L$2: {
          switch (decl.$tag) {
            case 2: {
              break _L$2;
            }
            case 0: {
              break _L$2;
            }
            case 1: {
              break _L$2;
            }
            case 8: {
              break _L$2;
            }
            case 9: {
              break _L$2;
            }
            case 10: {
              break _L$2;
            }
            case 3: {
              const _Token = decl;
              const _symbols = _Token._0;
              const _type_ = _Token._1;
              moonbitlang$core$builtin$$Logger$write_string$3$(out, "%token");
              if (actions) {
                if (_type_ === undefined) {
                } else {
                  const _Some = _type_;
                  const _type_$2 = _Some;
                  moonbitlang$core$builtin$$Logger$write_string$3$(out, `<${_type_$2}>`);
                }
              }
              const _len$4 = _symbols.length;
              let _tmp$4 = 0;
              while (true) {
                const _i$2 = _tmp$4;
                if (_i$2 < _len$4) {
                  const symbol = _symbols[_i$2];
                  moonbitlang$core$builtin$$Logger$write_string$3$(out, " ");
                  moonbitlang$core$builtin$$Logger$write_string$3$(out, symbol.symbol);
                  _tmp$4 = _i$2 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n");
              break;
            }
            case 4: {
              const _Token1 = decl;
              const _symbol = _Token1._0;
              const _type_$2 = _Token1._1;
              const _image = _Token1._2;
              moonbitlang$core$builtin$$Logger$write_string$3$(out, "%token");
              if (actions) {
                if (_type_$2 === undefined) {
                } else {
                  const _Some = _type_$2;
                  const _type_$3 = _Some;
                  moonbitlang$core$builtin$$Logger$write_string$3$(out, `<${_type_$3}>`);
                }
              }
              moonbitlang$core$builtin$$Logger$write_string$3$(out, " ");
              moonbitlang$core$builtin$$Logger$write_string$3$(out, _symbol.symbol);
              moonbitlang$core$builtin$$Logger$write_string$3$(out, " ");
              moonbitlang$core$builtin$$Logger$write_string$3$(out, _image);
              moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n");
              break;
            }
            case 5: {
              const _Type = decl;
              const _symbols$2 = _Type._0;
              const _type_$3 = _Type._1;
              if (actions) {
                moonbitlang$core$builtin$$Logger$write_string$3$(out, "%type");
                moonbitlang$core$builtin$$Logger$write_string$3$(out, `<${_type_$3}>`);
                const _len$5 = _symbols$2.length;
                let _tmp$5 = 0;
                while (true) {
                  const _i$2 = _tmp$5;
                  if (_i$2 < _len$5) {
                    const symbol = _symbols$2[_i$2];
                    moonbitlang$core$builtin$$Logger$write_string$3$(out, " ");
                    moonbitlang$core$builtin$$Logger$write_string$3$(out, symbol.symbol);
                    _tmp$5 = _i$2 + 1 | 0;
                    continue;
                  } else {
                    break;
                  }
                }
                moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n");
              }
              break;
            }
            case 6: {
              const _Derive = decl;
              const _traits = _Derive._0;
              const _type_$4 = _Derive._1;
              if (actions) {
                moonbitlang$core$builtin$$Logger$write_string$3$(out, "%derive");
                moonbitlang$core$builtin$$Logger$write_string$3$(out, `<${_type_$4}>`);
                moonbitlang$core$builtin$$Logger$write_string$3$(out, " ");
                moonbitlang$core$builtin$$Logger$write_string$3$(out, _traits);
                moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n");
              }
              break;
            }
            default: {
              const _Position = decl;
              const _type_$5 = _Position._0;
              if (actions) {
                moonbitlang$core$builtin$$Logger$write_string$3$(out, "%position");
                moonbitlang$core$builtin$$Logger$write_string$3$(out, `<${_type_$5}>`);
                moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n");
              }
            }
          }
          break _L;
        }
        $panic();
      }
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (!(prec_decls.length === 0)) {
    moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n");
  }
  const _len$4 = prec_decls.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$4) {
      const decl = prec_decls[_i];
      let symbols;
      _L: {
        _L$2: {
          switch (decl.$tag) {
            case 8: {
              const _Left = decl;
              const _symbols = _Left._0;
              symbols = _symbols;
              break _L$2;
            }
            case 9: {
              const _Right = decl;
              const _symbols$2 = _Right._0;
              symbols = _symbols$2;
              break _L$2;
            }
            case 10: {
              const _Nonassoc = decl;
              const _symbols$3 = _Nonassoc._0;
              symbols = _symbols$3;
              break _L$2;
            }
            default: {
              $panic();
            }
          }
          break _L;
        }
        let _tmp$5;
        switch (decl.$tag) {
          case 8: {
            _tmp$5 = "%left";
            break;
          }
          case 9: {
            _tmp$5 = "%right";
            break;
          }
          case 10: {
            _tmp$5 = "%nonassoc";
            break;
          }
          default: {
            _tmp$5 = $panic();
          }
        }
        moonbitlang$core$builtin$$Logger$write_string$3$(out, _tmp$5);
        const _len$5 = symbols.length;
        let _tmp$6 = 0;
        while (true) {
          const _i$2 = _tmp$6;
          if (_i$2 < _len$5) {
            const symbol = symbols[_i$2];
            moonbitlang$core$builtin$$Logger$write_string$3$(out, " ");
            if (symbol.$tag === 0) {
              const _Symbol = symbol;
              const _symbol = _Symbol._0;
              moonbitlang$core$builtin$$Logger$write_string$3$(out, _symbol);
            } else {
              const _Image = symbol;
              const _image = _Image._0;
              moonbitlang$core$builtin$$Logger$write_string$3$(out, _image);
            }
            _tmp$6 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n");
      }
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (actions) {
    const _bind = header;
    if (_bind === undefined) {
    } else {
      const _Some = _bind;
      const _code = _Some;
      moonbitlang$core$builtin$$Logger$write_string$3$(out, `\n\n%{${_code}%}\n`);
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n%%\n\n");
  const _arr$2 = spec.rules;
  const _len$5 = _arr$2.length;
  let _tmp$5 = 0;
  while (true) {
    const _i = _tmp$5;
    if (_i < _len$5) {
      const rule = _arr$2[_i];
      if (rule.inline) {
        moonbitlang$core$builtin$$Logger$write_string$3$(out, "%inline ");
      }
      moonbitlang$core$builtin$$Logger$write_string$3$(out, rule.nonterminal);
      let _tmp$6;
      if (actions) {
        const _p = rule.generic_params;
        _tmp$6 = !(_p.length === 0);
      } else {
        _tmp$6 = false;
      }
      if (_tmp$6) {
        moonbitlang$core$builtin$$Logger$write_string$3$(out, "[");
        const _arr$3 = rule.generic_params;
        const _len$6 = _arr$3.length;
        let _tmp$7 = 0;
        while (true) {
          const _i$2 = _tmp$7;
          if (_i$2 < _len$6) {
            const param = _arr$3[_i$2];
            if (_i$2 > 0) {
              moonbitlang$core$builtin$$Logger$write_string$3$(out, ", ");
            }
            moonbitlang$core$builtin$$Logger$write_string$3$(out, param);
            _tmp$7 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        moonbitlang$core$builtin$$Logger$write_string$3$(out, "]");
      }
      const _p = rule.params;
      if (!(_p.length === 0)) {
        moonbitlang$core$builtin$$Logger$write_string$3$(out, "(");
        const _arr$3 = rule.params;
        const _len$6 = _arr$3.length;
        let _tmp$7 = 0;
        while (true) {
          const _i$2 = _tmp$7;
          if (_i$2 < _len$6) {
            const param = _arr$3[_i$2];
            if (_i$2 > 0) {
              moonbitlang$core$builtin$$Logger$write_string$3$(out, ", ");
            }
            moonbitlang$core$builtin$$Logger$write_string$3$(out, param._0);
            if (actions) {
              const _bind = param._1;
              if (_bind === undefined) {
              } else {
                const _Some = _bind;
                const _type_ = _Some;
                moonbitlang$core$builtin$$Logger$write_string$3$(out, ` : ${moonbitlang$core$builtin$$Show$to_string$121$(_type_)}`);
              }
            }
            _tmp$7 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        moonbitlang$core$builtin$$Logger$write_string$3$(out, ")");
      }
      if (actions) {
        const _bind = rule.type_;
        if (_bind === undefined) {
        } else {
          const _Some = _bind;
          const _type_ = _Some;
          moonbitlang$core$builtin$$Logger$write_string$3$(out, ` -> ${moonbitlang$core$builtin$$Show$to_string$121$(_type_)}`);
        }
      }
      const _arr$3 = rule.clauses;
      const _len$6 = _arr$3.length;
      let _tmp$7 = 0;
      while (true) {
        const _i$2 = _tmp$7;
        if (_i$2 < _len$6) {
          const clause = _arr$3[_i$2];
          if (_i$2 === 0) {
            moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n  : ");
          } else {
            moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n  | ");
          }
          const _it = moonbitlang$core$list$$List$iter2$171$(clause._0);
          while (true) {
            const _bind = moonbitlang$core$builtin$$Iter2$next$127$(_it);
            if (_bind === undefined) {
              break;
            } else {
              const _Some = _bind;
              const _x = _Some;
              const _index = _x._0;
              const _clause_no_action = _x._1;
              if (_index > 0) {
                moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n | ");
              }
              const _arr$4 = _clause_no_action.items;
              const _len$7 = _arr$4.length;
              let _tmp$8 = 0;
              while (true) {
                const _i$3 = _tmp$8;
                if (_i$3 < _len$7) {
                  const item = _arr$4[_i$3];
                  if (_i$3 > 0) {
                    moonbitlang$core$builtin$$Logger$write_string$3$(out, " ");
                  }
                  _L: {
                    _L$2: {
                      if (actions) {
                        const _bind$2 = item.binder;
                        if (_bind$2 === undefined) {
                          break _L$2;
                        } else {
                          const _Some$2 = _bind$2;
                          const _binder = _Some$2;
                          moonbitlang$core$builtin$$Logger$write_string$3$(out, `${_binder}=${moonbitlang$yacc$lib$ast$$print_spec$46$inner$46$term_to_string$124$82(item.term)}`);
                        }
                      } else {
                        break _L$2;
                      }
                      break _L;
                    }
                    moonbitlang$core$builtin$$Logger$write_string$3$(out, moonbitlang$yacc$lib$ast$$print_spec$46$inner$46$term_to_string$124$82(item.term));
                  }
                  _tmp$8 = _i$3 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              const _bind$2 = _clause_no_action.prec;
              if (_bind$2 === undefined) {
              } else {
                const _Some$2 = _bind$2;
                const _prec = _Some$2;
                if (_prec.$tag === 0) {
                  const _Symbol = _prec;
                  const _symbol = _Symbol._0;
                  moonbitlang$core$builtin$$Logger$write_string$3$(out, ` %prec ${_symbol}`);
                } else {
                  const _Image = _prec;
                  const _image = _Image._0;
                  moonbitlang$core$builtin$$Logger$write_string$3$(out, ` %prec ${_image}`);
                }
              }
              if (!actions) {
                moonbitlang$core$builtin$$Logger$write_string$3$(out, " {}");
              }
              continue;
            }
          }
          if (actions) {
            const _bind = clause._1.code;
            if (_bind === undefined) {
              moonbitlang$core$builtin$$Logger$write_string$3$(out, " {}");
            } else {
              const _Some = _bind;
              const _code = _Some;
              moonbitlang$core$builtin$$Logger$write_string$3$(out, ` {${_code.code}}`);
            }
          }
          _tmp$7 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$3$(out, "\n  ;\n\n");
      _tmp$5 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (actions) {
    const _bind = trailer;
    if (_bind === undefined) {
      return;
    } else {
      const _Some = _bind;
      const _code = _Some;
      moonbitlang$core$builtin$$Logger$write_string$3$(out, `%{${_code}%}\n`);
      return;
    }
  } else {
    return;
  }
}
function moonbitlang$ulex$45$runtime$lexbuf$$StringLexbuf$from_string(string) {
  return { data: string, end: string.length, pos: 0 };
}
function moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(self) {
  const pos = self.pos;
  const end = self.end;
  if (self.pos < end) {
    const _tmp = self.data;
    const c = _tmp.charCodeAt(pos);
    if (c >= 55296 && c <= 56319) {
      const pos2 = pos + 1 | 0;
      if (pos2 < end) {
        const _tmp$2 = self.data;
        const c2 = _tmp$2.charCodeAt(pos2);
        if (c2 >= 56320 && c2 <= 57343) {
          self.pos = pos2 + 1 | 0;
          return (((Math.imul(c - 55296 | 0, 1024) | 0) + c2 | 0) - 56320 | 0) + 65536 | 0;
        }
      }
    }
    self.pos = pos + 1 | 0;
    return c;
  }
  return -1;
}
function moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$reset$247$(self, pos) {
  self.pos = pos;
}
function moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_char$247$(self, start, _end) {
  return moonbitlang$core$string$$String$unsafe_char_at(self.data, start);
}
function moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(self, start, end) {
  return moonbitlang$core$string$$String$substring$46$inner(self.data, start, end);
}
function moonbitlang$yacc$lib$parser$$Token$kind(self) {
  switch (self.$tag) {
    case 0: {
      return 0;
    }
    case 1: {
      return 1;
    }
    case 2: {
      return 2;
    }
    case 3: {
      return 3;
    }
    case 4: {
      return 4;
    }
    case 5: {
      return 5;
    }
    case 6: {
      return 6;
    }
    case 7: {
      return 7;
    }
    case 8: {
      return 8;
    }
    case 9: {
      return 9;
    }
    case 10: {
      return 10;
    }
    case 11: {
      return 11;
    }
    case 12: {
      return 12;
    }
    case 13: {
      return 13;
    }
    case 14: {
      return 14;
    }
    case 15: {
      return 15;
    }
    case 16: {
      return 16;
    }
    case 17: {
      return 17;
    }
    case 18: {
      return 18;
    }
    case 19: {
      return 19;
    }
    case 20: {
      return 20;
    }
    case 21: {
      return 21;
    }
    case 22: {
      return 22;
    }
    case 23: {
      return 23;
    }
    case 24: {
      return 24;
    }
    case 25: {
      return 25;
    }
    case 26: {
      return 26;
    }
    case 27: {
      return 27;
    }
    case 28: {
      return 28;
    }
    default: {
      return 29;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$119$(self, logger) {
  let _tmp;
  switch (self) {
    case 0: {
      _tmp = "EOF";
      break;
    }
    case 1: {
      _tmp = "IDENT";
      break;
    }
    case 2: {
      _tmp = "STRING";
      break;
    }
    case 3: {
      _tmp = "LANGLE_CODE_RANGLE";
      break;
    }
    case 4: {
      _tmp = "LBRACE_CODE_RBRACE";
      break;
    }
    case 5: {
      _tmp = "PERCENT_LBRACE_CODE_PERCENT_RBRACE";
      break;
    }
    case 6: {
      _tmp = "PERCENT_PERCENT_CODE_EOF";
      break;
    }
    case 7: {
      _tmp = "PKG_AND_IDENT";
      break;
    }
    case 8: {
      _tmp = "\"%%\"";
      break;
    }
    case 9: {
      _tmp = "\"%start\"";
      break;
    }
    case 10: {
      _tmp = "\"%token\"";
      break;
    }
    case 11: {
      _tmp = "\"%type\"";
      break;
    }
    case 12: {
      _tmp = "\"%position\"";
      break;
    }
    case 13: {
      _tmp = "\"%left\"";
      break;
    }
    case 14: {
      _tmp = "\"%right\"";
      break;
    }
    case 15: {
      _tmp = "\"%nonassoc\"";
      break;
    }
    case 16: {
      _tmp = "\"%prec\"";
      break;
    }
    case 17: {
      _tmp = "\"%derive\"";
      break;
    }
    case 18: {
      _tmp = "\"%inline\"";
      break;
    }
    case 19: {
      _tmp = "\"[\"";
      break;
    }
    case 20: {
      _tmp = "\"]\"";
      break;
    }
    case 21: {
      _tmp = "\"(\"";
      break;
    }
    case 22: {
      _tmp = "\")\"";
      break;
    }
    case 23: {
      _tmp = "\",\"";
      break;
    }
    case 24: {
      _tmp = "\"->\"";
      break;
    }
    case 25: {
      _tmp = "\"?\"";
      break;
    }
    case 26: {
      _tmp = "\":\"";
      break;
    }
    case 27: {
      _tmp = "\"|\"";
      break;
    }
    case 28: {
      _tmp = "\"=\"";
      break;
    }
    default: {
      _tmp = "\";\"";
    }
  }
  logger.method_table.method_0(logger.self, _tmp);
}
function moonbitlang$yacc$lib$parser$$yy_action_0(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 10) {
    const _YYObj__list_List__ast_Declaration_ = _bind;
    const _decl_list = _YYObj__list_List__ast_Declaration_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 11) {
      const _YYObj__list_List__ast_Rule_ = _bind$2;
      const _rule_list = _YYObj__list_List__ast_Rule_._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
      if (_bind$3.$tag === 12) {
        const _YYObj___ast_Code__Int__Int__ = _bind$3;
        const _trailer = _YYObj___ast_Code__Int__Int__._0;
        const decls = moonbitlang$core$list$$List$to_array$131$(_decl_list);
        if (_trailer === undefined) {
        } else {
          const _Some = _trailer;
          const _x = _Some;
          const _code = _x._0;
          const _utf8_pos = _x._1;
          const _subst = _x._2;
          moonbitlang$core$array$$Array$push$131$(decls, new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Trailer(_code, _utf8_pos, _subst));
        }
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ParserSpec$46$YYObj__ast_ParserSpec({ decls: decls, rules: moonbitlang$core$list$$List$to_array$156$(_rule_list) });
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_1(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 14) {
    const _YYObj__String__Int__Int_ = _bind;
    const _code = _YYObj__String__Int__Int_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj___ast_Code__Int__Int__$46$YYObj___ast_Code__Int__Int__(_code);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_2(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 14) {
    const _YYObj__String__Int__Int_ = _bind;
    const _code = _YYObj__String__Int__Int_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj___ast_Code__Int__Int__$46$YYObj___ast_Code__Int__Int__(_code);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_3(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj___ast_Code__Int__Int__$46$YYObj___ast_Code__Int__Int__(undefined);
}
function moonbitlang$yacc$lib$parser$$yy_action_4(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 15) {
    const _YYObj__ast_Rule = _bind;
    const _rule = _YYObj__ast_Rule._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind$2.$tag === 11) {
      const _YYObj__list_List__ast_Rule_ = _bind$2;
      const _rule_list = _YYObj__list_List__ast_Rule_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Rule_$46$YYObj__list_List__ast_Rule_(new $64$moonbitlang$47$core$47$list$46$List$More$16$(_rule, _rule_list));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_5(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 15) {
    const _YYObj__ast_Rule = _bind;
    const _rule = _YYObj__ast_Rule._0;
    const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$16$;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Rule_$46$YYObj__list_List__ast_Rule_(new $64$moonbitlang$47$core$47$list$46$List$More$16$(_rule, _p));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_6(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 15) {
    const _YYObj__ast_Rule = _bind;
    const __dollar1 = _YYObj__ast_Rule._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Rule$46$YYObj__ast_Rule(__dollar1);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_7(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 15) {
    const _YYObj__ast_Rule = _bind;
    const __dollar2 = _YYObj__ast_Rule._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Rule$46$YYObj__ast_Rule({ inline: true, nonterminal: __dollar2.nonterminal, generic_params: __dollar2.generic_params, params: __dollar2.params, type_: __dollar2.type_, clauses: __dollar2.clauses });
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_8(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 16) {
    const _YYObj__ast_Symbol = _bind;
    const _nonterminal = _YYObj__ast_Symbol._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind$2.$tag === 17) {
      const _YYObj__ast_TypeExpr_ = _bind$2;
      const _type_ = _YYObj__ast_TypeExpr_._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
      if (_bind$3.$tag === 18) {
        const _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__ = _bind$3;
        const _clause_list = _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__._0;
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Rule$46$YYObj__ast_Rule({ inline: false, nonterminal: _nonterminal, generic_params: [], params: [], type_: _type_, clauses: moonbitlang$core$list$$List$to_array$158$(_clause_list) });
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_9(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 16) {
    const _YYObj__ast_Symbol = _bind;
    const _nonterminal = _YYObj__ast_Symbol._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind$2.$tag === 19) {
      const _YYObj_Array_String_ = _bind$2;
      const _generic_params = _YYObj_Array_String_._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
      if (_bind$3.$tag === 20) {
        const _YYObj__list_List__String___ast_TypeExpr___ = _bind$3;
        const _param_list = _YYObj__list_List__String___ast_TypeExpr___._0;
        const _bind$4 = moonbitlang$core$array$$ArrayView$at$21$(_args, 5)._0;
        if (_bind$4.$tag === 17) {
          const _YYObj__ast_TypeExpr_ = _bind$4;
          const _type_ = _YYObj__ast_TypeExpr_._0;
          const _bind$5 = moonbitlang$core$array$$ArrayView$at$21$(_args, 7)._0;
          if (_bind$5.$tag === 18) {
            const _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__ = _bind$5;
            const _clause_list = _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__._0;
            return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Rule$46$YYObj__ast_Rule({ inline: false, nonterminal: _nonterminal, generic_params: _generic_params, params: moonbitlang$core$list$$List$to_array$160$(_param_list), type_: _type_, clauses: moonbitlang$core$list$$List$to_array$158$(_clause_list) });
          } else {
            return $panic();
          }
        } else {
          return $panic();
        }
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_10(_last_pos, _args) {
  const _dollar1 = undefined;
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Option_Unit_$46$YYObj_Option_Unit_(_dollar1);
}
function moonbitlang$yacc$lib$parser$$yy_action_11(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Option_Unit_$46$YYObj_Option_Unit_(-1);
}
function moonbitlang$yacc$lib$parser$$yy_action_12(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 18) {
    const _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__ = _bind;
    const __dollar2 = _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__(__dollar2);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_13(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 18) {
    const _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__ = _bind;
    const __dollar1 = _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__(__dollar1);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_15(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 22) {
    const _YYObj__ast_ClauseWithoutAction = _bind;
    const __dollar1 = _YYObj__ast_ClauseWithoutAction._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseWithoutAction$46$YYObj__ast_ClauseWithoutAction(__dollar1);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_14(_last_pos, _args) {
  const _sub_action_0_result = moonbitlang$yacc$lib$parser$$yy_action_15(_last_pos, moonbitlang$core$array$$ArrayView$sub$46$inner$21$(_args, 0, moonbitlang$yacc$lib$parser$$yy_action_14$46$constr$47$6057));
  if (_sub_action_0_result.$tag === 22) {
    const _YYObj__ast_ClauseWithoutAction = _sub_action_0_result;
    const _clause_woa = _YYObj__ast_ClauseWithoutAction._0;
    const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind.$tag === 23) {
      const _YYObj__ast_ClauseAction = _bind;
      const _action = _YYObj__ast_ClauseAction._0;
      const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
      if (_bind$2.$tag === 18) {
        const _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__ = _bind$2;
        const _clause_list = _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__._0;
        const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$22$;
        const _p$2 = { _0: new $64$moonbitlang$47$core$47$list$46$List$More$22$(_clause_woa, _p), _1: _action };
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__(new $64$moonbitlang$47$core$47$list$46$List$More$23$(_p$2, _clause_list));
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_16(_last_pos, _args) {
  const _sub_action_0_result = moonbitlang$yacc$lib$parser$$yy_action_15(_last_pos, moonbitlang$core$array$$ArrayView$sub$46$inner$21$(_args, 0, moonbitlang$yacc$lib$parser$$yy_action_16$46$constr$47$6069));
  if (_sub_action_0_result.$tag === 22) {
    const _YYObj__ast_ClauseWithoutAction = _sub_action_0_result;
    const _clause_woa = _YYObj__ast_ClauseWithoutAction._0;
    const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind.$tag === 23) {
      const _YYObj__ast_ClauseAction = _bind;
      const _action = _YYObj__ast_ClauseAction._0;
      const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$22$;
      const _p$2 = { _0: new $64$moonbitlang$47$core$47$list$46$List$More$22$(_clause_woa, _p), _1: _action };
      const _p$3 = $64$moonbitlang$47$core$47$list$46$List$Empty$23$;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__(new $64$moonbitlang$47$core$47$list$46$List$More$23$(_p$2, _p$3));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_18(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 22) {
    const _YYObj__ast_ClauseWithoutAction = _bind;
    const __dollar1 = _YYObj__ast_ClauseWithoutAction._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseWithoutAction$46$YYObj__ast_ClauseWithoutAction(__dollar1);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_17(_last_pos, _args) {
  const _sub_action_0_result = moonbitlang$yacc$lib$parser$$yy_action_18(_last_pos, moonbitlang$core$array$$ArrayView$sub$46$inner$21$(_args, 0, moonbitlang$yacc$lib$parser$$yy_action_17$46$constr$47$6083));
  if (_sub_action_0_result.$tag === 22) {
    const _YYObj__ast_ClauseWithoutAction = _sub_action_0_result;
    const _clause_woa = _YYObj__ast_ClauseWithoutAction._0;
    const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind.$tag === 23) {
      const _YYObj__ast_ClauseAction = _bind;
      const _action = _YYObj__ast_ClauseAction._0;
      const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
      if (_bind$2.$tag === 18) {
        const _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__ = _bind$2;
        const _clause_list = _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__._0;
        const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$22$;
        const _p$2 = { _0: new $64$moonbitlang$47$core$47$list$46$List$More$22$(_clause_woa, _p), _1: _action };
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__(new $64$moonbitlang$47$core$47$list$46$List$More$23$(_p$2, _clause_list));
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_19(_last_pos, _args) {
  const _sub_action_0_result = moonbitlang$yacc$lib$parser$$yy_action_18(_last_pos, moonbitlang$core$array$$ArrayView$sub$46$inner$21$(_args, 0, moonbitlang$yacc$lib$parser$$yy_action_19$46$constr$47$6095));
  if (_sub_action_0_result.$tag === 22) {
    const _YYObj__ast_ClauseWithoutAction = _sub_action_0_result;
    const _clause_woa = _YYObj__ast_ClauseWithoutAction._0;
    const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind.$tag === 23) {
      const _YYObj__ast_ClauseAction = _bind;
      const _action = _YYObj__ast_ClauseAction._0;
      const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$22$;
      const _p$2 = { _0: new $64$moonbitlang$47$core$47$list$46$List$More$22$(_clause_woa, _p), _1: _action };
      const _p$3 = $64$moonbitlang$47$core$47$list$46$List$Empty$23$;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__(new $64$moonbitlang$47$core$47$list$46$List$More$23$(_p$2, _p$3));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_20(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 22) {
    const _YYObj__ast_ClauseWithoutAction = _bind;
    const _clause_woa = _YYObj__ast_ClauseWithoutAction._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 18) {
      const _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__ = _bind$2;
      const _clause_list = _YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__._0;
      let _tmp;
      if (_clause_list.$tag === 1) {
        const _More = _clause_list;
        const _x = _More._0;
        const _clause_woa_list = _x._0;
        const _action = _x._1;
        const _tail_clause_list = _More._1;
        const _p = { _0: new $64$moonbitlang$47$core$47$list$46$List$More$22$(_clause_woa, _clause_woa_list), _1: _action };
        _tmp = new $64$moonbitlang$47$core$47$list$46$List$More$23$(_p, _tail_clause_list);
      } else {
        _tmp = $panic();
      }
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__$46$YYObj__list_List___list_List__ast_ClauseWithoutAction____ast_ClauseAction__(_tmp);
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_21(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 24) {
    const _YYObj__String__Int__Array__ast_SubstItem__ = _bind;
    const _code = _YYObj__String__Int__Array__ast_SubstItem__._0;
    const _start_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._1;
    const _end_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, (_args.end - _args.start | 0) - 1 | 0)._2;
    const _code$2 = _code._0;
    const _utf8_pos = _code._1;
    const _subst = _code._2;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseAction$46$YYObj__ast_ClauseAction({ code: { code: _code$2, utf8_pos: _utf8_pos, subst: _subst }, loc: { _0: _start_pos, _1: _end_pos - _start_pos | 0 } });
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_22(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 25) {
    const _YYObj__ast_PrecSymbol_ = _bind;
    const _prec = _YYObj__ast_PrecSymbol_._0;
    const _start_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._1;
    const _end_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, (_args.end - _args.start | 0) - 1 | 0)._2;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseWithoutAction$46$YYObj__ast_ClauseWithoutAction({ items: [], prec: _prec, loc: { _0: _start_pos, _1: _end_pos - _start_pos | 0 } });
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_23(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 26) {
    const _YYObj__list_List__ast_ClauseItem_ = _bind;
    const _item_list = _YYObj__list_List__ast_ClauseItem_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind$2.$tag === 25) {
      const _YYObj__ast_PrecSymbol_ = _bind$2;
      const _prec = _YYObj__ast_PrecSymbol_._0;
      const _start_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._1;
      const _end_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, (_args.end - _args.start | 0) - 1 | 0)._2;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseWithoutAction$46$YYObj__ast_ClauseWithoutAction({ items: moonbitlang$core$list$$List$to_array$157$(_item_list), prec: _prec, loc: { _0: _start_pos, _1: _end_pos - _start_pos | 0 } });
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_24(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 27) {
    const _YYObj__ast_PrecSymbol = _bind;
    const _symbol = _YYObj__ast_PrecSymbol._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_PrecSymbol_$46$YYObj__ast_PrecSymbol_(_symbol);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_25(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 28) {
    const _YYObj__ast_ClauseItem = _bind;
    const _item = _YYObj__ast_ClauseItem._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind$2.$tag === 26) {
      const _YYObj__list_List__ast_ClauseItem_ = _bind$2;
      const _item_list = _YYObj__list_List__ast_ClauseItem_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_ClauseItem_$46$YYObj__list_List__ast_ClauseItem_(new $64$moonbitlang$47$core$47$list$46$List$More$20$(_item, _item_list));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_26(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 28) {
    const _YYObj__ast_ClauseItem = _bind;
    const _item = _YYObj__ast_ClauseItem._0;
    const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$20$;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_ClauseItem_$46$YYObj__list_List__ast_ClauseItem_(new $64$moonbitlang$47$core$47$list$46$List$More$20$(_item, _p));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_27(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 29) {
    const _YYObj__ast_Term = _bind;
    const _term = _YYObj__ast_Term._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseItem$46$YYObj__ast_ClauseItem({ binder: undefined, term: _term });
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_28(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _binder = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 29) {
      const _YYObj__ast_Term = _bind$2;
      const _term = _YYObj__ast_Term._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_ClauseItem$46$YYObj__ast_ClauseItem({ binder: _binder, term: _term });
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_29(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 16) {
    const _YYObj__ast_Symbol = _bind;
    const _symbol = _YYObj__ast_Symbol._0;
    const _start_pos_of_item0 = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._1;
    const _end_pos_of_item0 = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._2;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 31) {
      const _YYObj__list_List__ast_Term_ = _bind$2;
      const __dollar3 = _YYObj__list_List__ast_Term_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Term$46$YYObj__ast_Term(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Term$RuleCall(_symbol, { _0: _start_pos_of_item0, _1: _end_pos_of_item0 }, moonbitlang$core$list$$List$to_array$159$(__dollar3)));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_30(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 29) {
    const _YYObj__ast_Term = _bind;
    const _term = _YYObj__ast_Term._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 31) {
      const _YYObj__list_List__ast_Term_ = _bind$2;
      const _term_list = _YYObj__list_List__ast_Term_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Term_$46$YYObj__list_List__ast_Term_(new $64$moonbitlang$47$core$47$list$46$List$More$24$(_term, _term_list));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_31(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 29) {
    const _YYObj__ast_Term = _bind;
    const _term = _YYObj__ast_Term._0;
    const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$24$;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Term_$46$YYObj__list_List__ast_Term_(new $64$moonbitlang$47$core$47$list$46$List$More$24$(_term, _p));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_32(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 16) {
    const _YYObj__ast_Symbol = _bind;
    const _symbol = _YYObj__ast_Symbol._0;
    const _start_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._1;
    const _end_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, (_args.end - _args.start | 0) - 1 | 0)._2;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Term$46$YYObj__ast_Term(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Term$Symbol(_symbol, { _0: _start_pos, _1: _end_pos }));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_33(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _image = _YYObj_String._0;
    const _start_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._1;
    const _end_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, (_args.end - _args.start | 0) - 1 | 0)._2;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Term$46$YYObj__ast_Term(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Term$Image(_image, { _0: _start_pos, _1: _end_pos }));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_34(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_PrecSymbol_$46$YYObj__ast_PrecSymbol_(undefined);
}
function moonbitlang$yacc$lib$parser$$yy_action_35(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 32) {
      const _YYObj__ast_TypeExpr = _bind$2;
      const __dollar3 = _YYObj__ast_TypeExpr._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$at$21$(_args, 4)._0;
      if (_bind$3.$tag === 20) {
        const _YYObj__list_List__String___ast_TypeExpr___ = _bind$3;
        const __dollar5 = _YYObj__list_List__String___ast_TypeExpr___._0;
        const _p = { _0: __dollar1, _1: __dollar3 };
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__String___ast_TypeExpr___$46$YYObj__list_List__String___ast_TypeExpr___(new $64$moonbitlang$47$core$47$list$46$List$More$19$(_p, __dollar5));
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_36(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 32) {
      const _YYObj__ast_TypeExpr = _bind$2;
      const __dollar3 = _YYObj__ast_TypeExpr._0;
      const _p = { _0: __dollar1, _1: __dollar3 };
      const _p$2 = $64$moonbitlang$47$core$47$list$46$List$Empty$19$;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__String___ast_TypeExpr___$46$YYObj__list_List__String___ast_TypeExpr___(new $64$moonbitlang$47$core$47$list$46$List$More$19$(_p, _p$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_37(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 20) {
      const _YYObj__list_List__String___ast_TypeExpr___ = _bind$2;
      const __dollar3 = _YYObj__list_List__String___ast_TypeExpr___._0;
      const _p = { _0: __dollar1, _1: undefined };
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__String___ast_TypeExpr___$46$YYObj__list_List__String___ast_TypeExpr___(new $64$moonbitlang$47$core$47$list$46$List$More$19$(_p, __dollar3));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_38(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    const _p = { _0: __dollar1, _1: undefined };
    const _p$2 = $64$moonbitlang$47$core$47$list$46$List$Empty$19$;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__String___ast_TypeExpr___$46$YYObj__list_List__String___ast_TypeExpr___(new $64$moonbitlang$47$core$47$list$46$List$More$19$(_p, _p$2));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_39(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const _type_ = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr_$46$YYObj__ast_TypeExpr_(_type_);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_40(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 33) {
    const _YYObj__String__String_ = _bind;
    const __dollar1 = _YYObj__String__String_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 34) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const __dollar3 = _YYObj__list_List__ast_TypeExpr_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr(__dollar1._0, __dollar1._1, moonbitlang$core$list$$List$to_array$51$(__dollar3)));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_41(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar4 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow([], __dollar4));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_42(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 4)._0;
    if (_bind$2.$tag === 32) {
      const _YYObj__ast_TypeExpr$2 = _bind$2;
      const __dollar5 = _YYObj__ast_TypeExpr$2._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow([__dollar2], __dollar5));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_43(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(__dollar2);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_44(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 5)._0;
    if (_bind$2.$tag === 32) {
      const _YYObj__ast_TypeExpr$2 = _bind$2;
      const __dollar6 = _YYObj__ast_TypeExpr$2._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow([__dollar2], __dollar6));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_45(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar1 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Option(__dollar1));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_46(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar1 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(__dollar1);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_47(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
    if (_bind$2.$tag === 34) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const __dollar4 = _YYObj__list_List__ast_TypeExpr_._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$at$21$(_args, 6)._0;
      if (_bind$3.$tag === 32) {
        const _YYObj__ast_TypeExpr$2 = _bind$3;
        const __dollar7 = _YYObj__ast_TypeExpr$2._0;
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow(moonbitlang$core$list$$List$to_array$51$(new $64$moonbitlang$47$core$47$list$46$List$More$21$(__dollar2, __dollar4)), __dollar7));
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_48(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
    if (_bind$2.$tag === 34) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const __dollar4 = _YYObj__list_List__ast_TypeExpr_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Tuple(moonbitlang$core$list$$List$to_array$51$(new $64$moonbitlang$47$core$47$list$46$List$More$21$(__dollar2, __dollar4))));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_49(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar1 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(__dollar1);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_50(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 34) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const __dollar3 = _YYObj__list_List__ast_TypeExpr_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr(undefined, __dollar1, moonbitlang$core$list$$List$to_array$51$(__dollar3)));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_51(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr(undefined, __dollar1, []));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_52(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const _type_expr = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 34) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const _type_expr_list = _YYObj__list_List__ast_TypeExpr_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_TypeExpr_$46$YYObj__list_List__ast_TypeExpr_(new $64$moonbitlang$47$core$47$list$46$List$More$21$(_type_expr, _type_expr_list));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_53(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 32) {
    const _YYObj__ast_TypeExpr = _bind;
    const _type_expr = _YYObj__ast_TypeExpr._0;
    const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$21$;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_TypeExpr_$46$YYObj__list_List__ast_TypeExpr_(new $64$moonbitlang$47$core$47$list$46$List$More$21$(_type_expr, _p));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_54(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 33) {
    const _YYObj__String__String_ = _bind;
    const __dollar1 = _YYObj__String__String_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr(__dollar1._0, __dollar1._1, []));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_55(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 35) {
    const _YYObj__list_List_String_ = _bind;
    const __dollar2 = _YYObj__list_List_String_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Array_String_$46$YYObj_Array_String_(moonbitlang$core$list$$List$to_array$13$(__dollar2));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_56(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 35) {
      const _YYObj__list_List_String_ = _bind$2;
      const __dollar3 = _YYObj__list_List_String_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List_String_$46$YYObj__list_List_String_(new $64$moonbitlang$47$core$47$list$46$List$More$18$(__dollar1, __dollar3));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_57(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$18$;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List_String_$46$YYObj__list_List_String_(new $64$moonbitlang$47$core$47$list$46$List$More$18$(__dollar1, _p));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_58(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_TypeExpr_$46$YYObj__ast_TypeExpr_(undefined);
}
function moonbitlang$yacc$lib$parser$$yy_action_59(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Array_String_$46$YYObj_Array_String_([]);
}
function moonbitlang$yacc$lib$parser$$yy_action_60(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 36) {
    const _YYObj__ast_Declaration = _bind;
    const _decl = _YYObj__ast_Declaration._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind$2.$tag === 10) {
      const _YYObj__list_List__ast_Declaration_ = _bind$2;
      const _decl_list = _YYObj__list_List__ast_Declaration_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Declaration_$46$YYObj__list_List__ast_Declaration_(new $64$moonbitlang$47$core$47$list$46$List$More$13$(_decl, _decl_list));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_61(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 14) {
    const _YYObj__String__Int__Int_ = _bind;
    const __dollar1 = _YYObj__String__Int__Int_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Header(__dollar1._0, __dollar1._1, __dollar1._2));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_62(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 37) {
    const _YYObj__list_List__ast_SymbolWithLoc_ = _bind;
    const _symbol_list = _YYObj__list_List__ast_SymbolWithLoc_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Start(moonbitlang$core$list$$List$to_array$155$(_symbol_list), undefined));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_63(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _type_ = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 37) {
      const _YYObj__list_List__ast_SymbolWithLoc_ = _bind$2;
      const _symbol_list = _YYObj__list_List__ast_SymbolWithLoc_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Start(moonbitlang$core$list$$List$to_array$155$(_symbol_list), _type_));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_64(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 37) {
    const _YYObj__list_List__ast_SymbolWithLoc_ = _bind;
    const _symbol_list = _YYObj__list_List__ast_SymbolWithLoc_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Token(moonbitlang$core$list$$List$to_array$155$(_symbol_list), undefined));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_65(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _type_ = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 37) {
      const _YYObj__list_List__ast_SymbolWithLoc_ = _bind$2;
      const _symbol_list = _YYObj__list_List__ast_SymbolWithLoc_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Token(moonbitlang$core$list$$List$to_array$155$(_symbol_list), _type_));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_66(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _type_ = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 38) {
      const _YYObj__ast_SymbolWithLoc = _bind$2;
      const _symbol = _YYObj__ast_SymbolWithLoc._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
      if (_bind$3.$tag === 30) {
        const _YYObj_String$2 = _bind$3;
        const _image = _YYObj_String$2._0;
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Token1(_symbol, _type_, _image));
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_67(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 38) {
    const _YYObj__ast_SymbolWithLoc = _bind;
    const _symbol = _YYObj__ast_SymbolWithLoc._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 30) {
      const _YYObj_String = _bind$2;
      const _image = _YYObj_String._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Token1(_symbol, undefined, _image));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_68(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _type_ = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 37) {
      const _YYObj__list_List__ast_SymbolWithLoc_ = _bind$2;
      const _symbol_list = _YYObj__list_List__ast_SymbolWithLoc_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Type(moonbitlang$core$list$$List$to_array$155$(_symbol_list), _type_));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_69(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 38) {
    const _YYObj__ast_SymbolWithLoc = _bind;
    const _symbol = _YYObj__ast_SymbolWithLoc._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind$2.$tag === 37) {
      const _YYObj__list_List__ast_SymbolWithLoc_ = _bind$2;
      const _symbol_list = _YYObj__list_List__ast_SymbolWithLoc_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_SymbolWithLoc_$46$YYObj__list_List__ast_SymbolWithLoc_(new $64$moonbitlang$47$core$47$list$46$List$More$15$(_symbol, _symbol_list));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_70(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 38) {
    const _YYObj__ast_SymbolWithLoc = _bind;
    const _symbol = _YYObj__ast_SymbolWithLoc._0;
    const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$15$;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_SymbolWithLoc_$46$YYObj__list_List__ast_SymbolWithLoc_(new $64$moonbitlang$47$core$47$list$46$List$More$15$(_symbol, _p));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_71(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 16) {
    const _YYObj__ast_Symbol = _bind;
    const _symbol = _YYObj__ast_Symbol._0;
    const _start_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._1;
    const _end_pos = (_args.end - _args.start | 0) === 0 ? _last_pos : moonbitlang$core$array$$ArrayView$at$21$(_args, (_args.end - _args.start | 0) - 1 | 0)._2;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_SymbolWithLoc$46$YYObj__ast_SymbolWithLoc({ symbol: _symbol, loc: { _0: _start_pos, _1: _end_pos } });
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_72(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _type_ = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Position(_type_));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_73(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 39) {
    const _YYObj__list_List__ast_PrecSymbol_ = _bind;
    const _symbol_list = _YYObj__list_List__ast_PrecSymbol_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Left(moonbitlang$core$list$$List$to_array$154$(_symbol_list)));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_74(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 39) {
    const _YYObj__list_List__ast_PrecSymbol_ = _bind;
    const _symbol_list = _YYObj__list_List__ast_PrecSymbol_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Right(moonbitlang$core$list$$List$to_array$154$(_symbol_list)));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_75(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 39) {
    const _YYObj__list_List__ast_PrecSymbol_ = _bind;
    const _symbol_list = _YYObj__list_List__ast_PrecSymbol_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Nonassoc(moonbitlang$core$list$$List$to_array$154$(_symbol_list)));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_76(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 27) {
    const _YYObj__ast_PrecSymbol = _bind;
    const _symbol = _YYObj__ast_PrecSymbol._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
    if (_bind$2.$tag === 39) {
      const _YYObj__list_List__ast_PrecSymbol_ = _bind$2;
      const _symbol_list = _YYObj__list_List__ast_PrecSymbol_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_PrecSymbol_$46$YYObj__list_List__ast_PrecSymbol_(new $64$moonbitlang$47$core$47$list$46$List$More$14$(_symbol, _symbol_list));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_77(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 27) {
    const _YYObj__ast_PrecSymbol = _bind;
    const _symbol = _YYObj__ast_PrecSymbol._0;
    const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$14$;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_PrecSymbol_$46$YYObj__list_List__ast_PrecSymbol_(new $64$moonbitlang$47$core$47$list$46$List$More$14$(_symbol, _p));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_78(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 16) {
    const _YYObj__ast_Symbol = _bind;
    const _symbol = _YYObj__ast_Symbol._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_PrecSymbol$46$YYObj__ast_PrecSymbol(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$PrecSymbol$Symbol(_symbol));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_79(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _image = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_PrecSymbol$46$YYObj__ast_PrecSymbol(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$PrecSymbol$Image(_image));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_80(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _ident = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Symbol$46$YYObj__ast_Symbol(_ident);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_81(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 30) {
    const _YYObj_String = _bind;
    const _traits = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 30) {
      const _YYObj_String$2 = _bind$2;
      const _type_ = _YYObj_String$2._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__ast_Declaration$46$YYObj__ast_Declaration(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$Declaration$Derive(_traits, _type_));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_82(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__list_List__ast_Declaration_$46$YYObj__list_List__ast_Declaration_($64$moonbitlang$47$core$47$list$46$List$Empty$13$);
}
function moonbitlang$yacc$lib$parser$$yy_input(token, _start_pos, _end_pos) {
  switch (token.$tag) {
    case 0: {
      return { _0: 0, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 1: {
      const _IDENT = token;
      const _data = _IDENT._0;
      return { _0: 1, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_data) };
    }
    case 2: {
      const _STRING = token;
      const _data$2 = _STRING._0;
      return { _0: 2, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_data$2) };
    }
    case 3: {
      const _LANGLE_CODE_RANGLE = token;
      const _data$3 = _LANGLE_CODE_RANGLE._0;
      return { _0: 3, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_data$3) };
    }
    case 4: {
      const _LBRACE_CODE_RBRACE = token;
      const _data$4 = _LBRACE_CODE_RBRACE._0;
      return { _0: 4, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Array__ast_SubstItem__$46$YYObj__String__Int__Array__ast_SubstItem__(_data$4) };
    }
    case 5: {
      const _PERCENT_LBRACE_CODE_PERCENT_RBRACE = token;
      const _data$5 = _PERCENT_LBRACE_CODE_PERCENT_RBRACE._0;
      return { _0: 5, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Int_$46$YYObj__String__Int__Int_(_data$5) };
    }
    case 6: {
      const _PERCENT_PERCENT_CODE_EOF = token;
      const _data$6 = _PERCENT_PERCENT_CODE_EOF._0;
      return { _0: 6, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Int_$46$YYObj__String__Int__Int_(_data$6) };
    }
    case 7: {
      const _PKG_AND_IDENT = token;
      const _data$7 = _PKG_AND_IDENT._0;
      return { _0: 7, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__String_$46$YYObj__String__String_(_data$7) };
    }
    case 8: {
      return { _0: 8, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 9: {
      return { _0: 9, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 10: {
      return { _0: 10, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 11: {
      return { _0: 11, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 12: {
      return { _0: 12, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 13: {
      return { _0: 13, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 14: {
      return { _0: 14, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 15: {
      return { _0: 15, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 16: {
      return { _0: 16, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 17: {
      return { _0: 17, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 18: {
      return { _0: 18, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 19: {
      return { _0: 19, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 20: {
      return { _0: 20, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 21: {
      return { _0: 21, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 22: {
      return { _0: 22, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 23: {
      return { _0: 23, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 24: {
      return { _0: 24, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 25: {
      return { _0: 25, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 26: {
      return { _0: 26, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 27: {
      return { _0: 27, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 28: {
      return { _0: 28, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    default: {
      return { _0: 29, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_1(_lookahead) {
  return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Accept;
}
function moonbitlang$yacc$lib$parser$$yy_state_13(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 32, moonbitlang$yacc$lib$parser$$yy_action_74);
}
function moonbitlang$yacc$lib$parser$$yy_state_6(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 59, moonbitlang$yacc$lib$parser$$yy_action_80);
}
function moonbitlang$yacc$lib$parser$$yy_state_7(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 57, moonbitlang$yacc$lib$parser$$yy_action_79);
}
function moonbitlang$yacc$lib$parser$$yy_state_8(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 57, moonbitlang$yacc$lib$parser$$yy_action_78);
}
function moonbitlang$yacc$lib$parser$$yy_state_10(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 56, moonbitlang$yacc$lib$parser$$yy_action_76);
}
function moonbitlang$yacc$lib$parser$$yy_state_9(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
      }
      case 2: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_7);
      }
      case 59: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
      }
      case 57: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
      }
      case 56: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_10);
      }
      case 5: {
        break _L;
      }
      case 8: {
        break _L;
      }
      case 9: {
        break _L;
      }
      case 10: {
        break _L;
      }
      case 11: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      case 14: {
        break _L;
      }
      case 15: {
        break _L;
      }
      case 17: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 56, moonbitlang$yacc$lib$parser$$yy_action_77);
}
function moonbitlang$yacc$lib$parser$$yy_state_12(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_7);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 57: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
    }
    case 56: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_13);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_15(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 32, moonbitlang$yacc$lib$parser$$yy_action_73);
}
function moonbitlang$yacc$lib$parser$$yy_state_14(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_7);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 57: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
    }
    case 56: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_15);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_17(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 32, moonbitlang$yacc$lib$parser$$yy_action_72);
}
function moonbitlang$yacc$lib$parser$$yy_state_16(_lookahead) {
  if (_lookahead === 3) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_17);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_20(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 58, moonbitlang$yacc$lib$parser$$yy_action_71);
}
function moonbitlang$yacc$lib$parser$$yy_state_22(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 55, moonbitlang$yacc$lib$parser$$yy_action_69);
}
function moonbitlang$yacc$lib$parser$$yy_state_21(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
      }
      case 59: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_20);
      }
      case 58: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_21);
      }
      case 55: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_22);
      }
      case 5: {
        break _L;
      }
      case 8: {
        break _L;
      }
      case 9: {
        break _L;
      }
      case 10: {
        break _L;
      }
      case 11: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      case 14: {
        break _L;
      }
      case 15: {
        break _L;
      }
      case 17: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 55, moonbitlang$yacc$lib$parser$$yy_action_70);
}
function moonbitlang$yacc$lib$parser$$yy_state_23(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 32, moonbitlang$yacc$lib$parser$$yy_action_68);
}
function moonbitlang$yacc$lib$parser$$yy_state_19(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_20);
    }
    case 58: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_21);
    }
    case 55: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_23);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_18(_lookahead) {
  if (_lookahead === 3) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_19);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_4(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 32, moonbitlang$yacc$lib$parser$$yy_action_81);
}
function moonbitlang$yacc$lib$parser$$yy_state_3(_lookahead) {
  if (_lookahead === 1) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_4);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_2(_lookahead) {
  if (_lookahead === 3) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_3);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_26(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 32, moonbitlang$yacc$lib$parser$$yy_action_67);
}
function moonbitlang$yacc$lib$parser$$yy_state_25(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
      }
      case 59: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_20);
      }
      case 58: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_21);
      }
      case 55: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_22);
      }
      case 2: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_26);
      }
      case 5: {
        break _L;
      }
      case 8: {
        break _L;
      }
      case 9: {
        break _L;
      }
      case 10: {
        break _L;
      }
      case 11: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      case 14: {
        break _L;
      }
      case 15: {
        break _L;
      }
      case 17: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 55, moonbitlang$yacc$lib$parser$$yy_action_70);
}
function moonbitlang$yacc$lib$parser$$yy_state_29(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 32, moonbitlang$yacc$lib$parser$$yy_action_66);
}
function moonbitlang$yacc$lib$parser$$yy_state_28(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
      }
      case 59: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_20);
      }
      case 58: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_21);
      }
      case 55: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_22);
      }
      case 2: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_29);
      }
      case 5: {
        break _L;
      }
      case 8: {
        break _L;
      }
      case 9: {
        break _L;
      }
      case 10: {
        break _L;
      }
      case 11: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      case 14: {
        break _L;
      }
      case 15: {
        break _L;
      }
      case 17: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 55, moonbitlang$yacc$lib$parser$$yy_action_70);
}
function moonbitlang$yacc$lib$parser$$yy_state_30(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 32, moonbitlang$yacc$lib$parser$$yy_action_65);
}
function moonbitlang$yacc$lib$parser$$yy_state_27(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_20);
    }
    case 58: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_28);
    }
    case 55: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_30);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_31(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 32, moonbitlang$yacc$lib$parser$$yy_action_64);
}
function moonbitlang$yacc$lib$parser$$yy_state_24(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_20);
    }
    case 58: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_25);
    }
    case 3: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_27);
    }
    case 55: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_31);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_34(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 32, moonbitlang$yacc$lib$parser$$yy_action_63);
}
function moonbitlang$yacc$lib$parser$$yy_state_33(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_20);
    }
    case 58: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_21);
    }
    case 55: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_34);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_35(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 32, moonbitlang$yacc$lib$parser$$yy_action_62);
}
function moonbitlang$yacc$lib$parser$$yy_state_32(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_20);
    }
    case 58: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_21);
    }
    case 3: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_33);
    }
    case 55: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_35);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_36(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 32, moonbitlang$yacc$lib$parser$$yy_action_61);
}
function moonbitlang$yacc$lib$parser$$yy_state_38(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 31, moonbitlang$yacc$lib$parser$$yy_action_60);
}
function moonbitlang$yacc$lib$parser$$yy_state_11(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 32, moonbitlang$yacc$lib$parser$$yy_action_75);
}
function moonbitlang$yacc$lib$parser$$yy_state_5(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_7);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 57: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
    }
    case 56: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_11);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_37(_lookahead) {
  switch (_lookahead) {
    case 17: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_2);
    }
    case 15: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_5);
    }
    case 14: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_12);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_14);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_16);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_18);
    }
    case 10: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_24);
    }
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_32);
    }
    case 5: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_36);
    }
    case 32: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_37);
    }
    case 31: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_38);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 31, moonbitlang$yacc$lib$parser$$yy_action_82);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_134(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 35, moonbitlang$yacc$lib$parser$$yy_action_7);
}
function moonbitlang$yacc$lib$parser$$yy_state_103(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 52, moonbitlang$yacc$lib$parser$$yy_action_28);
}
function moonbitlang$yacc$lib$parser$$yy_state_93(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 53, moonbitlang$yacc$lib$parser$$yy_action_33);
}
function moonbitlang$yacc$lib$parser$$yy_state_98(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 54, moonbitlang$yacc$lib$parser$$yy_action_30);
}
function moonbitlang$yacc$lib$parser$$yy_state_100(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 53, moonbitlang$yacc$lib$parser$$yy_action_29);
}
function moonbitlang$yacc$lib$parser$$yy_state_99(_lookahead) {
  if (_lookahead === 22) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_100);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_94(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 21: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_95);
      }
      case 1: {
        break _L;
      }
      case 2: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 16: {
        break _L;
      }
      case 22: {
        break _L;
      }
      case 23: {
        break _L;
      }
      case 27: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 53, moonbitlang$yacc$lib$parser$$yy_action_32);
}
function moonbitlang$yacc$lib$parser$$yy_state_95(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
    }
    case 53: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_96);
    }
    case 54: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_99);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_96(_lookahead) {
  switch (_lookahead) {
    case 23: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_97);
    }
    case 22: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 54, moonbitlang$yacc$lib$parser$$yy_action_31);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_97(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
    }
    case 53: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_96);
    }
    case 54: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_98);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_102(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
    }
    case 53: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_103);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_101(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 28: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_102);
      }
      case 1: {
        break _L;
      }
      case 2: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 16: {
        break _L;
      }
      case 21: {
        break _L;
      }
      case 27: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 59, moonbitlang$yacc$lib$parser$$yy_action_80);
}
function moonbitlang$yacc$lib$parser$$yy_state_104(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 52, moonbitlang$yacc$lib$parser$$yy_action_27);
}
function moonbitlang$yacc$lib$parser$$yy_state_106(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 51, moonbitlang$yacc$lib$parser$$yy_action_25);
}
function moonbitlang$yacc$lib$parser$$yy_state_105(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 2: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
      }
      case 59: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
      }
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_101);
      }
      case 53: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_104);
      }
      case 52: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_105);
      }
      case 51: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_106);
      }
      case 4: {
        break _L;
      }
      case 16: {
        break _L;
      }
      case 27: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 51, moonbitlang$yacc$lib$parser$$yy_action_26);
}
function moonbitlang$yacc$lib$parser$$yy_state_108(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 50, moonbitlang$yacc$lib$parser$$yy_action_24);
}
function moonbitlang$yacc$lib$parser$$yy_state_107(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_7);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 57: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_108);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_110(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 48, moonbitlang$yacc$lib$parser$$yy_action_23);
}
function moonbitlang$yacc$lib$parser$$yy_state_109(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 16: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_107);
      }
      case 50: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_110);
      }
      case 4: {
        break _L;
      }
      case 27: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 50, moonbitlang$yacc$lib$parser$$yy_action_34);
}
function moonbitlang$yacc$lib$parser$$yy_state_111(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 47, moonbitlang$yacc$lib$parser$$yy_action_22);
}
function moonbitlang$yacc$lib$parser$$yy_state_113(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 49, moonbitlang$yacc$lib$parser$$yy_action_21);
}
function moonbitlang$yacc$lib$parser$$yy_state_115(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 46, moonbitlang$yacc$lib$parser$$yy_action_20);
}
function moonbitlang$yacc$lib$parser$$yy_state_119(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 46, moonbitlang$yacc$lib$parser$$yy_action_17);
}
function moonbitlang$yacc$lib$parser$$yy_state_122(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 46, moonbitlang$yacc$lib$parser$$yy_action_14);
}
function moonbitlang$yacc$lib$parser$$yy_state_112(_lookahead) {
  switch (_lookahead) {
    case 4: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_113);
    }
    case 27: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_114);
    }
    case 49: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_120);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_114(_lookahead) {
  switch (_lookahead) {
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_101);
    }
    case 53: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_104);
    }
    case 52: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_105);
    }
    case 16: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_107);
    }
    case 51: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_109);
    }
    case 50: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_111);
    }
    case 48: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_112);
    }
    case 46: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_115);
    }
    case 47: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_116);
    }
    case 4: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 50, moonbitlang$yacc$lib$parser$$yy_action_34);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_116(_lookahead) {
  switch (_lookahead) {
    case 4: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_113);
    }
    case 49: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_117);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_117(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 27: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_118);
      }
      case 0: {
        break _L;
      }
      case 1: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 6: {
        break _L;
      }
      case 18: {
        break _L;
      }
      case 29: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(2, 46, moonbitlang$yacc$lib$parser$$yy_action_19);
}
function moonbitlang$yacc$lib$parser$$yy_state_118(_lookahead) {
  switch (_lookahead) {
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_101);
    }
    case 53: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_104);
    }
    case 52: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_105);
    }
    case 16: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_107);
    }
    case 51: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_109);
    }
    case 50: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_111);
    }
    case 48: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_112);
    }
    case 47: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_116);
    }
    case 46: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_119);
    }
    case 4: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 50, moonbitlang$yacc$lib$parser$$yy_action_34);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_120(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 27: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_121);
      }
      case 0: {
        break _L;
      }
      case 1: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 6: {
        break _L;
      }
      case 18: {
        break _L;
      }
      case 29: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(2, 46, moonbitlang$yacc$lib$parser$$yy_action_16);
}
function moonbitlang$yacc$lib$parser$$yy_state_121(_lookahead) {
  switch (_lookahead) {
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_101);
    }
    case 53: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_104);
    }
    case 52: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_105);
    }
    case 16: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_107);
    }
    case 51: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_109);
    }
    case 50: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_111);
    }
    case 48: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_112);
    }
    case 47: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_116);
    }
    case 46: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_122);
    }
    case 4: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 50, moonbitlang$yacc$lib$parser$$yy_action_34);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_123(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 45, moonbitlang$yacc$lib$parser$$yy_action_13);
}
function moonbitlang$yacc$lib$parser$$yy_state_125(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 45, moonbitlang$yacc$lib$parser$$yy_action_12);
}
function moonbitlang$yacc$lib$parser$$yy_state_124(_lookahead) {
  switch (_lookahead) {
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_101);
    }
    case 53: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_104);
    }
    case 52: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_105);
    }
    case 16: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_107);
    }
    case 51: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_109);
    }
    case 50: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_111);
    }
    case 48: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_112);
    }
    case 47: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_116);
    }
    case 46: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_125);
    }
    case 4: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 50, moonbitlang$yacc$lib$parser$$yy_action_34);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_127(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 60, moonbitlang$yacc$lib$parser$$yy_action_10);
}
function moonbitlang$yacc$lib$parser$$yy_state_132(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(5, 36, moonbitlang$yacc$lib$parser$$yy_action_8);
}
function moonbitlang$yacc$lib$parser$$yy_state_131(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 29: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_127);
      }
      case 60: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_132);
      }
      case 0: {
        break _L;
      }
      case 1: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 6: {
        break _L;
      }
      case 18: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 60, moonbitlang$yacc$lib$parser$$yy_action_11);
}
function moonbitlang$yacc$lib$parser$$yy_state_130(_lookahead) {
  switch (_lookahead) {
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_101);
    }
    case 53: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_104);
    }
    case 52: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_105);
    }
    case 16: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_107);
    }
    case 51: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_109);
    }
    case 50: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_111);
    }
    case 48: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_112);
    }
    case 47: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_116);
    }
    case 46: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_123);
    }
    case 27: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_124);
    }
    case 45: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_131);
    }
    case 4: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 50, moonbitlang$yacc$lib$parser$$yy_action_34);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_129(_lookahead) {
  if (_lookahead === 26) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_130);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_45(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 40, moonbitlang$yacc$lib$parser$$yy_action_56);
}
function moonbitlang$yacc$lib$parser$$yy_state_43(_lookahead) {
  switch (_lookahead) {
    case 23: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_44);
    }
    case 20: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 40, moonbitlang$yacc$lib$parser$$yy_action_57);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_44(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_43);
    }
    case 40: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_45);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_47(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 39, moonbitlang$yacc$lib$parser$$yy_action_55);
}
function moonbitlang$yacc$lib$parser$$yy_state_46(_lookahead) {
  if (_lookahead === 20) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_47);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_42(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_43);
    }
    case 40: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_46);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_53(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 44, moonbitlang$yacc$lib$parser$$yy_action_52);
}
function moonbitlang$yacc$lib$parser$$yy_state_57(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 43, moonbitlang$yacc$lib$parser$$yy_action_50);
}
function moonbitlang$yacc$lib$parser$$yy_state_56(_lookahead) {
  if (_lookahead === 20) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_57);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_58(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 42, moonbitlang$yacc$lib$parser$$yy_action_49);
}
function moonbitlang$yacc$lib$parser$$yy_state_65(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(7, 41, moonbitlang$yacc$lib$parser$$yy_action_47);
}
function moonbitlang$yacc$lib$parser$$yy_state_67(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 42, moonbitlang$yacc$lib$parser$$yy_action_45);
}
function moonbitlang$yacc$lib$parser$$yy_state_66(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 25: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_67);
      }
      case 20: {
        break _L;
      }
      case 22: {
        break _L;
      }
      case 23: {
        break _L;
      }
      case 26: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 41, moonbitlang$yacc$lib$parser$$yy_action_46);
}
function moonbitlang$yacc$lib$parser$$yy_state_70(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(6, 41, moonbitlang$yacc$lib$parser$$yy_action_44);
}
function moonbitlang$yacc$lib$parser$$yy_state_73(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(5, 41, moonbitlang$yacc$lib$parser$$yy_action_42);
}
function moonbitlang$yacc$lib$parser$$yy_state_76(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 41, moonbitlang$yacc$lib$parser$$yy_action_41);
}
function moonbitlang$yacc$lib$parser$$yy_state_78(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 43, moonbitlang$yacc$lib$parser$$yy_action_40);
}
function moonbitlang$yacc$lib$parser$$yy_state_77(_lookahead) {
  if (_lookahead === 20) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_78);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_49(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 19: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_50);
      }
      case 20: {
        break _L;
      }
      case 22: {
        break _L;
      }
      case 23: {
        break _L;
      }
      case 25: {
        break _L;
      }
      case 26: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 43, moonbitlang$yacc$lib$parser$$yy_action_54);
}
function moonbitlang$yacc$lib$parser$$yy_state_50(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_51);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    case 44: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_77);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_51(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 23: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_52);
      }
      case 20: {
        break _L;
      }
      case 22: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 44, moonbitlang$yacc$lib$parser$$yy_action_53);
}
function moonbitlang$yacc$lib$parser$$yy_state_52(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_51);
    }
    case 44: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_53);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_54(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 19: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_55);
      }
      case 20: {
        break _L;
      }
      case 22: {
        break _L;
      }
      case 23: {
        break _L;
      }
      case 25: {
        break _L;
      }
      case 26: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 43, moonbitlang$yacc$lib$parser$$yy_action_51);
}
function moonbitlang$yacc$lib$parser$$yy_state_55(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_51);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 44: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_56);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_59(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_60);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    case 22: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_74);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_60(_lookahead) {
  switch (_lookahead) {
    case 23: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_61);
    }
    case 22: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_71);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_61(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_51);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 44: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_62);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    case 22: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_68);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_62(_lookahead) {
  if (_lookahead === 22) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_63);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_63(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 24: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_64);
      }
      case 20: {
        break _L;
      }
      case 22: {
        break _L;
      }
      case 23: {
        break _L;
      }
      case 25: {
        break _L;
      }
      case 26: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(5, 43, moonbitlang$yacc$lib$parser$$yy_action_48);
}
function moonbitlang$yacc$lib$parser$$yy_state_64(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_65);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_68(_lookahead) {
  if (_lookahead === 24) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_69);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_69(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_70);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_71(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 24: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_72);
      }
      case 20: {
        break _L;
      }
      case 22: {
        break _L;
      }
      case 23: {
        break _L;
      }
      case 25: {
        break _L;
      }
      case 26: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(3, 43, moonbitlang$yacc$lib$parser$$yy_action_43);
}
function moonbitlang$yacc$lib$parser$$yy_state_72(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_73);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_74(_lookahead) {
  if (_lookahead === 24) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_75);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_75(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_76);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_79(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 37, moonbitlang$yacc$lib$parser$$yy_action_39);
}
function moonbitlang$yacc$lib$parser$$yy_state_48(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_79);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_84(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 38, moonbitlang$yacc$lib$parser$$yy_action_37);
}
function moonbitlang$yacc$lib$parser$$yy_state_88(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(5, 38, moonbitlang$yacc$lib$parser$$yy_action_35);
}
function moonbitlang$yacc$lib$parser$$yy_state_82(_lookahead) {
  switch (_lookahead) {
    case 23: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_83);
    }
    case 26: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_85);
    }
    case 22: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 38, moonbitlang$yacc$lib$parser$$yy_action_38);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_83(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_82);
    }
    case 38: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_84);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_85(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
    }
    case 43: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 42: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_66);
    }
    case 41: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_86);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_86(_lookahead) {
  switch (_lookahead) {
    case 23: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_87);
    }
    case 22: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(3, 38, moonbitlang$yacc$lib$parser$$yy_action_36);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_87(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_82);
    }
    case 38: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_88);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_128(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(9, 36, moonbitlang$yacc$lib$parser$$yy_action_9);
}
function moonbitlang$yacc$lib$parser$$yy_state_126(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 29: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_127);
      }
      case 60: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_128);
      }
      case 0: {
        break _L;
      }
      case 1: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 6: {
        break _L;
      }
      case 18: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 60, moonbitlang$yacc$lib$parser$$yy_action_11);
}
function moonbitlang$yacc$lib$parser$$yy_state_92(_lookahead) {
  switch (_lookahead) {
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_93);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_94);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_101);
    }
    case 53: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_104);
    }
    case 52: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_105);
    }
    case 16: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_107);
    }
    case 51: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_109);
    }
    case 50: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_111);
    }
    case 48: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_112);
    }
    case 47: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_116);
    }
    case 46: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_123);
    }
    case 27: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_124);
    }
    case 45: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_126);
    }
    case 4: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 50, moonbitlang$yacc$lib$parser$$yy_action_34);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_91(_lookahead) {
  if (_lookahead === 26) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_92);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_90(_lookahead) {
  switch (_lookahead) {
    case 24: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_48);
    }
    case 37: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_91);
    }
    case 26: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 37, moonbitlang$yacc$lib$parser$$yy_action_58);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_89(_lookahead) {
  if (_lookahead === 22) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_90);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_81(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_82);
    }
    case 38: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_89);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_80(_lookahead) {
  if (_lookahead === 21) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_81);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_41(_lookahead) {
  switch (_lookahead) {
    case 19: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_42);
    }
    case 24: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_48);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_80);
    }
    case 37: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_129);
    }
    case 26: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 37, moonbitlang$yacc$lib$parser$$yy_action_58);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 39, moonbitlang$yacc$lib$parser$$yy_action_59);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_133(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_41);
    }
    case 36: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_134);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_135(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 35, moonbitlang$yacc$lib$parser$$yy_action_6);
}
function moonbitlang$yacc$lib$parser$$yy_state_137(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 33, moonbitlang$yacc$lib$parser$$yy_action_4);
}
function moonbitlang$yacc$lib$parser$$yy_state_136(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
      }
      case 59: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_41);
      }
      case 18: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_133);
      }
      case 36: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_135);
      }
      case 35: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_136);
      }
      case 33: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_137);
      }
      case 0: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 6: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 33, moonbitlang$yacc$lib$parser$$yy_action_5);
}
function moonbitlang$yacc$lib$parser$$yy_state_139(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 34, moonbitlang$yacc$lib$parser$$yy_action_2);
}
function moonbitlang$yacc$lib$parser$$yy_state_140(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 34, moonbitlang$yacc$lib$parser$$yy_action_1);
}
function moonbitlang$yacc$lib$parser$$yy_state_142(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(5, 30, moonbitlang$yacc$lib$parser$$yy_action_0);
}
function moonbitlang$yacc$lib$parser$$yy_state_141(_lookahead) {
  if (_lookahead === 0) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_142);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_138(_lookahead) {
  switch (_lookahead) {
    case 6: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_139);
    }
    case 5: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_140);
    }
    case 34: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_141);
    }
    case 0: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 34, moonbitlang$yacc$lib$parser$$yy_action_3);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_40(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
    }
    case 59: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_41);
    }
    case 18: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_133);
    }
    case 36: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_135);
    }
    case 35: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_136);
    }
    case 33: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_138);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_39(_lookahead) {
  if (_lookahead === 8) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_40);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_0(_lookahead) {
  switch (_lookahead) {
    case 30: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_1);
    }
    case 17: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_2);
    }
    case 15: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_5);
    }
    case 14: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_12);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_14);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_16);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_18);
    }
    case 10: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_24);
    }
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_32);
    }
    case 5: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_36);
    }
    case 32: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_37);
    }
    case 31: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_39);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 31, moonbitlang$yacc$lib$parser$$yy_action_82);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$error(stack, token, loc) {
  const expected = [];
  const _arr = [moonbitlang$yacc$lib$parser$$error$46$tuple$47$6695, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6696, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6697, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6698, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6699, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6700, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6701, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6702, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6703, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6704, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6705, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6706, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6707, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6708, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6709, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6710, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6711, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6712, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6713, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6714, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6715, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6716, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6717, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6718, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6719, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6720, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6721, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6722, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6723, moonbitlang$yacc$lib$parser$$error$46$tuple$47$6724];
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const term = _arr[_i];
      const kind = term._1;
      const symbol = term._0;
      let stack$2;
      _L: {
        stack$2 = stack;
        break _L;
      }
      let _tmp$2 = stack$2;
      _L$2: while (true) {
        const stack$3 = _tmp$2;
        if (stack$3.$tag === 0) {
          break;
        } else {
          const _More = stack$3;
          const _state = _More._0;
          let count;
          let symbol$2;
          _L$3: {
            _L$4: {
              const _bind = _state(symbol);
              switch (_bind.$tag) {
                case 0: {
                  break _L$4;
                }
                case 1: {
                  break _L$4;
                }
                case 2: {
                  const _Reduce = _bind;
                  const _count = _Reduce._0;
                  const _symbol = _Reduce._1;
                  count = _count;
                  symbol$2 = _symbol;
                  break _L$3;
                }
                case 3: {
                  const _ReduceNoLookahead = _bind;
                  const _count$2 = _ReduceNoLookahead._0;
                  const _symbol$2 = _ReduceNoLookahead._1;
                  count = _count$2;
                  symbol$2 = _symbol$2;
                  break _L$3;
                }
                default: {
                  break _L$2;
                }
              }
            }
            moonbitlang$core$array$$Array$push$119$(expected, kind);
            break;
          }
          let stack$4;
          let count$2;
          let symbol$3;
          _L$4: {
            stack$4 = stack$3;
            count$2 = count;
            symbol$3 = symbol$2;
            break _L$4;
          }
          let _tmp$3 = stack$4;
          let _tmp$4 = count$2;
          let _tmp$5 = symbol$3;
          _L$5: while (true) {
            const stack$5 = _tmp$3;
            const count$3 = _tmp$4;
            const symbol$4 = _tmp$5;
            const stack$6 = moonbitlang$core$list$$List$drop$20$(stack$5, count$3);
            if (stack$6.$tag === 1) {
              const _More$2 = stack$6;
              const _state$2 = _More$2._0;
              let count$4;
              let symbol$5;
              _L$6: {
                const _bind = _state$2(symbol$4);
                switch (_bind.$tag) {
                  case 1: {
                    const _Shift = _bind;
                    const _state$3 = _Shift._0;
                    _tmp$2 = new $64$moonbitlang$47$core$47$list$46$List$More$10$(_state$3, stack$6);
                    continue _L$2;
                  }
                  case 2: {
                    const _Reduce = _bind;
                    const _count = _Reduce._0;
                    const _symbol = _Reduce._1;
                    count$4 = _count;
                    symbol$5 = _symbol;
                    break _L$6;
                  }
                  case 3: {
                    const _ReduceNoLookahead = _bind;
                    const _count$2 = _ReduceNoLookahead._0;
                    const _symbol$2 = _ReduceNoLookahead._1;
                    count$4 = _count$2;
                    symbol$5 = _symbol$2;
                    break _L$6;
                  }
                  default: {
                    $panic();
                    break _L$2;
                  }
                }
              }
              _tmp$3 = stack$6;
              _tmp$4 = count$4;
              _tmp$5 = symbol$5;
              continue;
            } else {
              $panic();
              break _L$2;
            }
          }
        }
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Err$38$(new Error$moonbitlang$47$yacc$47$lib$47$parser$46$ParseError$46$UnexpectedToken(token, loc, expected));
}
function moonbitlang$yacc$lib$parser$$yy_parse$248$(read_token, start_pos, start, return_) {
  const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$10$;
  let state_stack = new $64$moonbitlang$47$core$47$list$46$List$More$10$(start, _p);
  const data_stack = [];
  let last_pos = start_pos;
  let state = start;
  let lookahead = undefined;
  let last_shifted_state_stack = state_stack;
  while (true) {
    let decision;
    const _func = state;
    const _bind = _func(61);
    switch (_bind.$tag) {
      case 3: {
        decision = _bind;
        break;
      }
      case 0: {
        decision = _bind;
        break;
      }
      default: {
        const _bind$2 = lookahead;
        if (_bind$2 === undefined) {
          const _bind$3 = read_token();
          const _token = _bind$3._0;
          const _start_pos = _bind$3._1;
          const _end_pos = _bind$3._2;
          const _bind$4 = moonbitlang$yacc$lib$parser$$yy_input(_token, _start_pos, _end_pos);
          const _symbol = _bind$4._0;
          const _data = _bind$4._1;
          lookahead = { _0: _symbol, _1: { _0: _data, _1: _start_pos, _2: _end_pos }, _2: _token };
          const _func$2 = state;
          decision = _func$2(_symbol);
        } else {
          const _Some = _bind$2;
          const _la = _Some;
          const _func$2 = state;
          decision = _func$2(_la._0);
        }
      }
    }
    let action;
    let count;
    let symbol;
    _L: {
      _L$2: {
        switch (decision.$tag) {
          case 0: {
            return new Result$Ok$39$(return_(moonbitlang$core$array$$Array$unsafe_pop$21$(data_stack)._0));
          }
          case 1: {
            const _Shift = decision;
            const _next_state = _Shift._0;
            const _bind$3 = lookahead;
            if (_bind$3 === undefined) {
              $panic();
            } else {
              const _Some = _bind$3;
              const _la = _Some;
              moonbitlang$core$array$$Array$push$21$(data_stack, _la._1);
              const _p$2 = state_stack;
              state_stack = new $64$moonbitlang$47$core$47$list$46$List$More$10$(_next_state, _p$2);
              last_shifted_state_stack = state_stack;
              state = _next_state;
              last_pos = _la._1._2;
              lookahead = undefined;
            }
            break;
          }
          case 2: {
            const _Reduce = decision;
            const _count = _Reduce._0;
            const _symbol = _Reduce._1;
            const _action = _Reduce._2;
            action = _action;
            count = _count;
            symbol = _symbol;
            break _L$2;
          }
          case 3: {
            const _ReduceNoLookahead = decision;
            const _count$2 = _ReduceNoLookahead._0;
            const _symbol$2 = _ReduceNoLookahead._1;
            const _action$2 = _ReduceNoLookahead._2;
            action = _action$2;
            count = _count$2;
            symbol = _symbol$2;
            break _L$2;
          }
          default: {
            const _p$2 = lookahead;
            let _bind$4;
            if (_p$2 === undefined) {
              _bind$4 = $panic();
            } else {
              const _p$3 = _p$2;
              _bind$4 = _p$3;
            }
            const _x = _bind$4._1;
            const _start_pos = _x._1;
            const _end_pos = _x._2;
            const _token = _bind$4._2;
            const _bind$5 = moonbitlang$yacc$lib$parser$$error(last_shifted_state_stack, _token, { _0: _start_pos, _1: _end_pos });
            if (_bind$5.$tag === 1) {
              const _ok = _bind$5;
              _ok._0;
            } else {
              return _bind$5;
            }
          }
        }
        break _L;
      }
      let _tmp = count;
      let _tmp$2 = symbol;
      let _tmp$3 = action;
      _L$3: while (true) {
        const args = moonbitlang$core$array$$Array$sub$46$inner$21$(data_stack, data_stack.length - count | 0, undefined);
        const data = action(last_pos, args);
        let start_pos$2;
        let end_pos;
        _L$4: {
          if ((args.end - args.start | 0) === 0) {
            const _tmp$4 = last_pos;
            const _tmp$5 = last_pos;
            start_pos$2 = _tmp$4;
            end_pos = _tmp$5;
            break _L$4;
          } else {
            const _tmp$4 = moonbitlang$core$array$$ArrayView$at$21$(args, 0)._1;
            const _tmp$5 = moonbitlang$core$array$$ArrayView$at$21$(args, (args.end - args.start | 0) - 1 | 0)._2;
            start_pos$2 = _tmp$4;
            end_pos = _tmp$5;
            break _L$4;
          }
        }
        let _tmp$4 = 0;
        while (true) {
          const i = _tmp$4;
          if (i < count) {
            moonbitlang$core$array$$Array$unsafe_pop$21$(data_stack);
            state_stack = moonbitlang$core$list$$List$unsafe_tail$20$(state_stack);
            _tmp$4 = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        state = moonbitlang$core$list$$List$unsafe_head$20$(state_stack);
        moonbitlang$core$array$$Array$push$21$(data_stack, { _0: data, _1: start_pos$2, _2: end_pos });
        let action$2;
        let count$2;
        let symbol$2;
        _L$5: {
          const _func$2 = state;
          const _bind$3 = _func$2(symbol);
          switch (_bind$3.$tag) {
            case 0: {
              return new Result$Ok$39$(return_(moonbitlang$core$array$$Array$unsafe_pop$21$(data_stack)._0));
            }
            case 1: {
              const _Shift = _bind$3;
              const _next_state = _Shift._0;
              const _p$2 = state_stack;
              state_stack = new $64$moonbitlang$47$core$47$list$46$List$More$10$(_next_state, _p$2);
              state = _next_state;
              break _L$3;
            }
            case 2: {
              const _Reduce = _bind$3;
              const _count = _Reduce._0;
              const _symbol = _Reduce._1;
              const _action = _Reduce._2;
              action$2 = _action;
              count$2 = _count;
              symbol$2 = _symbol;
              break _L$5;
            }
            case 3: {
              const _ReduceNoLookahead = _bind$3;
              const _count$2 = _ReduceNoLookahead._0;
              const _symbol$2 = _ReduceNoLookahead._1;
              const _action$2 = _ReduceNoLookahead._2;
              action$2 = _action$2;
              count$2 = _count$2;
              symbol$2 = _symbol$2;
              break _L$5;
            }
            default: {
              $panic();
              break _L$3;
            }
          }
        }
        _tmp = count$2;
        _tmp$2 = symbol$2;
        _tmp$3 = action$2;
        continue;
      }
    }
    continue;
  }
}
function moonbitlang$yacc$lib$parser$$spec(read_token, start_pos) {
  return moonbitlang$yacc$lib$parser$$yy_parse$248$(read_token, start_pos, moonbitlang$yacc$lib$parser$$yy_state_0, (it) => {
    if (it.$tag === 13) {
      const _YYObj__ast_ParserSpec = it;
      return _YYObj__ast_ParserSpec._0;
    } else {
      return $panic();
    }
  });
}
function moonbitlang$yacc$lib$parser$$code_eof(sb, lexbuf) {
  _L: while (true) {
    let _match_pattern = moonbitlang$core$int$$max_value;
    let _match_start = lexbuf.pos;
    let _match_end = -1;
    let _capture_0_start = -1;
    let _capture_0_end = -1;
    let _tmp = 0;
    _L$2: while (true) {
      const _param = _tmp;
      switch (_param) {
        case 0: {
          const _bind = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind === -1) {
            _tmp = 1;
          } else {
            if (_bind >= 0 && _bind <= 1114111) {
              _tmp = 2;
            } else {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 1: {
          _match_pattern = 1;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 2: {
          _match_pattern = 0;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        default: {
          $panic();
          break _L$2;
        }
      }
    }
    if (_match_pattern <= 1) {
      moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$reset$247$(lexbuf, _match_end);
      const _bind = _match_pattern;
      switch (_bind) {
        case 0: {
          const t = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_char$247$(lexbuf, _capture_0_start, _capture_0_end);
          moonbitlang$core$builtin$$Logger$write_char$3$(sb, t);
          continue _L;
        }
        case 1: {
          return;
        }
        default: {
          $panic();
          return;
        }
      }
    } else {
      $panic();
      return;
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_percent_rbrace(sb, lexbuf) {
  _L: while (true) {
    let _match_pattern = moonbitlang$core$int$$max_value;
    let _match_start = lexbuf.pos;
    let _match_end = -1;
    let _capture_0_start = -1;
    let _capture_0_end = -1;
    let _tmp = 0;
    _L$2: while (true) {
      const _param = _tmp;
      switch (_param) {
        case 0: {
          const _bind = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind === -1) {
            _tmp = 1;
          } else {
            if (_bind >= 0 && _bind <= 36) {
              _tmp = 2;
            } else {
              if (_bind === 37) {
                _tmp = 3;
              } else {
                if (_bind >= 38 && _bind <= 1114111) {
                  _tmp = 2;
                } else {
                  break _L$2;
                }
              }
            }
          }
          continue _L$2;
        }
        case 1: {
          _match_pattern = 2;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 2: {
          _match_pattern = 1;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 3: {
          _match_pattern = 1;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$2 === 125) {
            _tmp = 4;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 4: {
          _match_pattern = 0;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        default: {
          $panic();
          break _L$2;
        }
      }
    }
    if (_match_pattern <= 2) {
      moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$reset$247$(lexbuf, _match_end);
      const _bind = _match_pattern;
      switch (_bind) {
        case 0: {
          return new Result$Ok$40$(undefined);
        }
        case 1: {
          const t = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_char$247$(lexbuf, _capture_0_start, _capture_0_end);
          moonbitlang$core$builtin$$Logger$write_char$3$(sb, t);
          continue _L;
        }
        case 2: {
          return new Result$Err$40$(Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile);
        }
        default: {
          return new Result$Ok$40$($panic());
        }
      }
    } else {
      return new Result$Ok$40$($panic());
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rangle(sb, lexbuf) {
  _L: while (true) {
    let _match_pattern = moonbitlang$core$int$$max_value;
    let _match_start = lexbuf.pos;
    let _match_end = -1;
    let _capture_0_start = -1;
    let _capture_0_end = -1;
    let _tmp = 0;
    _L$2: while (true) {
      const _param = _tmp;
      switch (_param) {
        case 0: {
          const _bind = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind === -1) {
            _tmp = 1;
          } else {
            if (_bind >= 0 && _bind <= 61) {
              _tmp = 2;
            } else {
              if (_bind === 62) {
                _tmp = 3;
              } else {
                if (_bind >= 63 && _bind <= 1114111) {
                  _tmp = 2;
                } else {
                  break _L$2;
                }
              }
            }
          }
          continue _L$2;
        }
        case 1: {
          _match_pattern = 2;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 2: {
          _match_pattern = 1;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 3: {
          _match_pattern = 0;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        default: {
          $panic();
          break _L$2;
        }
      }
    }
    if (_match_pattern <= 2) {
      moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$reset$247$(lexbuf, _match_end);
      const _bind = _match_pattern;
      switch (_bind) {
        case 0: {
          return new Result$Ok$40$(undefined);
        }
        case 1: {
          const t = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_char$247$(lexbuf, _capture_0_start, _capture_0_end);
          moonbitlang$core$builtin$$Logger$write_char$3$(sb, t);
          continue _L;
        }
        case 2: {
          return new Result$Err$40$(Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile);
        }
        default: {
          return new Result$Ok$40$($panic());
        }
      }
    } else {
      return new Result$Ok$40$($panic());
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace(sb, subst, base, lexbuf) {
  _L: while (true) {
    let _match_pattern = moonbitlang$core$int$$max_value;
    let _match_start = lexbuf.pos;
    let _match_end = -1;
    let _capture_0_start = -1;
    let _capture_0_end = -1;
    let _capture_1_start = -1;
    let _capture_1_end = -1;
    let _capture_2_start = -1;
    let _capture_2_end = -1;
    let _tag_0 = -1;
    let _tag_1 = -1;
    let _tag_2 = -1;
    let _tmp = 0;
    _L$2: while (true) {
      const _param = _tmp;
      switch (_param) {
        case 0: {
          const _bind = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind === -1) {
            _tmp = 1;
          } else {
            if (_bind >= 0 && _bind <= 35) {
              _tmp = 2;
            } else {
              if (_bind === 36) {
                _tmp = 3;
              } else {
                if (_bind >= 37 && _bind <= 122) {
                  _tmp = 2;
                } else {
                  if (_bind === 123) {
                    _tmp = 4;
                  } else {
                    if (_bind === 124) {
                      _tmp = 2;
                    } else {
                      if (_bind === 125) {
                        _tmp = 5;
                      } else {
                        if (_bind >= 126 && _bind <= 1114111) {
                          _tmp = 2;
                        } else {
                          break _L$2;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 1: {
          _match_pattern = 7;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 2: {
          _match_pattern = 6;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 3: {
          _match_pattern = 6;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$2 >= 48 && _bind$2 <= 57) {
            _tmp = 6;
          } else {
            if (_bind$2 >= 65 && _bind$2 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$2 === 95) {
                _tmp = 7;
              } else {
                if (_bind$2 >= 97 && _bind$2 <= 100) {
                  _tmp = 7;
                } else {
                  if (_bind$2 === 101) {
                    _tmp = 8;
                  } else {
                    if (_bind$2 >= 102 && _bind$2 <= 107) {
                      _tmp = 7;
                    } else {
                      if (_bind$2 === 108) {
                        _tmp = 9;
                      } else {
                        if (_bind$2 >= 109 && _bind$2 <= 114) {
                          _tmp = 7;
                        } else {
                          if (_bind$2 === 115) {
                            _tmp = 10;
                          } else {
                            if (_bind$2 >= 116 && _bind$2 <= 122) {
                              _tmp = 7;
                            } else {
                              break _L$2;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 4: {
          _match_pattern = 0;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 5: {
          _match_pattern = 1;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 6: {
          _match_pattern = 2;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          _capture_1_start = _match_start + 1 | 0;
          _capture_1_end = _match_end;
          const _bind$3 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$3 >= 48 && _bind$3 <= 57) {
            _tmp = 6;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 7: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$4 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$4 >= 48 && _bind$4 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$4 >= 65 && _bind$4 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$4 === 95) {
                _tmp = 7;
              } else {
                if (_bind$4 >= 97 && _bind$4 <= 122) {
                  _tmp = 7;
                } else {
                  break _L$2;
                }
              }
            }
          }
          continue _L$2;
        }
        case 8: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$5 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$5 >= 48 && _bind$5 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$5 >= 65 && _bind$5 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$5 === 95) {
                _tmp = 7;
              } else {
                if (_bind$5 >= 97 && _bind$5 <= 109) {
                  _tmp = 7;
                } else {
                  if (_bind$5 === 110) {
                    _tmp = 12;
                  } else {
                    if (_bind$5 >= 111 && _bind$5 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 9: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$6 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$6 >= 48 && _bind$6 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$6 >= 65 && _bind$6 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$6 === 95) {
                _tmp = 7;
              } else {
                if (_bind$6 >= 97 && _bind$6 <= 110) {
                  _tmp = 7;
                } else {
                  if (_bind$6 === 111) {
                    _tmp = 11;
                  } else {
                    if (_bind$6 >= 112 && _bind$6 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 10: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$7 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$7 >= 48 && _bind$7 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$7 >= 65 && _bind$7 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$7 === 95) {
                _tmp = 7;
              } else {
                if (_bind$7 >= 97 && _bind$7 <= 107) {
                  _tmp = 7;
                } else {
                  if (_bind$7 === 108) {
                    _tmp = 13;
                  } else {
                    if (_bind$7 >= 109 && _bind$7 <= 115) {
                      _tmp = 7;
                    } else {
                      if (_bind$7 === 116) {
                        _tmp = 14;
                      } else {
                        if (_bind$7 >= 117 && _bind$7 <= 120) {
                          _tmp = 7;
                        } else {
                          if (_bind$7 === 121) {
                            _tmp = 15;
                          } else {
                            if (_bind$7 === 122) {
                              _tmp = 7;
                            } else {
                              break _L$2;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 11: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$8 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$8 >= 48 && _bind$8 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$8 >= 65 && _bind$8 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$8 === 95) {
                _tmp = 7;
              } else {
                if (_bind$8 >= 97 && _bind$8 <= 98) {
                  _tmp = 7;
                } else {
                  if (_bind$8 === 99) {
                    _tmp = 16;
                  } else {
                    if (_bind$8 >= 100 && _bind$8 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 12: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$9 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$9 >= 48 && _bind$9 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$9 >= 65 && _bind$9 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$9 === 95) {
                _tmp = 7;
              } else {
                if (_bind$9 >= 97 && _bind$9 <= 99) {
                  _tmp = 7;
                } else {
                  if (_bind$9 === 100) {
                    _tmp = 17;
                  } else {
                    if (_bind$9 >= 101 && _bind$9 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 13: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$10 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$10 >= 48 && _bind$10 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$10 >= 65 && _bind$10 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$10 === 95) {
                _tmp = 7;
              } else {
                if (_bind$10 >= 97 && _bind$10 <= 110) {
                  _tmp = 7;
                } else {
                  if (_bind$10 === 111) {
                    _tmp = 18;
                  } else {
                    if (_bind$10 >= 112 && _bind$10 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 14: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$11 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$11 >= 48 && _bind$11 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$11 >= 65 && _bind$11 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$11 === 95) {
                _tmp = 7;
              } else {
                if (_bind$11 === 97) {
                  _tmp = 20;
                } else {
                  if (_bind$11 >= 98 && _bind$11 <= 122) {
                    _tmp = 7;
                  } else {
                    break _L$2;
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 15: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$12 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$12 >= 48 && _bind$12 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$12 >= 65 && _bind$12 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$12 === 95) {
                _tmp = 7;
              } else {
                if (_bind$12 >= 97 && _bind$12 <= 108) {
                  _tmp = 7;
                } else {
                  if (_bind$12 === 109) {
                    _tmp = 19;
                  } else {
                    if (_bind$12 >= 110 && _bind$12 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 16: {
          _tag_0 = lexbuf.pos;
          _match_pattern = 4;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          _capture_1_start = _match_start + 1 | 0;
          _capture_1_end = _match_end;
          const _bind$13 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$13 === 40) {
            _tmp = 38;
          } else {
            if (_bind$13 >= 48 && _bind$13 <= 57) {
              _tmp = 7;
            } else {
              if (_bind$13 >= 65 && _bind$13 <= 90) {
                _tmp = 7;
              } else {
                if (_bind$13 === 95) {
                  _tmp = 7;
                } else {
                  if (_bind$13 >= 97 && _bind$13 <= 122) {
                    _tmp = 7;
                  } else {
                    break _L$2;
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 17: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$14 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$14 >= 48 && _bind$14 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$14 >= 65 && _bind$14 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$14 === 95) {
                _tmp = 7;
              } else {
                if (_bind$14 >= 97 && _bind$14 <= 111) {
                  _tmp = 7;
                } else {
                  if (_bind$14 === 112) {
                    _tmp = 37;
                  } else {
                    if (_bind$14 >= 113 && _bind$14 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 18: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$15 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$15 >= 48 && _bind$15 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$15 >= 65 && _bind$15 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$15 === 95) {
                _tmp = 7;
              } else {
                if (_bind$15 >= 97 && _bind$15 <= 98) {
                  _tmp = 7;
                } else {
                  if (_bind$15 === 99) {
                    _tmp = 21;
                  } else {
                    if (_bind$15 >= 100 && _bind$15 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 19: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$16 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$16 >= 48 && _bind$16 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$16 >= 65 && _bind$16 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$16 === 95) {
                _tmp = 7;
              } else {
                if (_bind$16 === 97) {
                  _tmp = 7;
                } else {
                  if (_bind$16 === 98) {
                    _tmp = 22;
                  } else {
                    if (_bind$16 >= 99 && _bind$16 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 20: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$17 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$17 >= 48 && _bind$17 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$17 >= 65 && _bind$17 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$17 === 95) {
                _tmp = 7;
              } else {
                if (_bind$17 >= 97 && _bind$17 <= 113) {
                  _tmp = 7;
                } else {
                  if (_bind$17 === 114) {
                    _tmp = 23;
                  } else {
                    if (_bind$17 >= 115 && _bind$17 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 21: {
          _match_pattern = 4;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          _capture_1_start = _match_start + 1 | 0;
          _capture_1_end = _match_end;
          const _bind$18 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$18 >= 48 && _bind$18 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$18 >= 65 && _bind$18 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$18 === 95) {
                _tmp = 7;
              } else {
                if (_bind$18 >= 97 && _bind$18 <= 122) {
                  _tmp = 7;
                } else {
                  break _L$2;
                }
              }
            }
          }
          continue _L$2;
        }
        case 22: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$19 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$19 >= 48 && _bind$19 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$19 >= 65 && _bind$19 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$19 === 95) {
                _tmp = 7;
              } else {
                if (_bind$19 >= 97 && _bind$19 <= 110) {
                  _tmp = 7;
                } else {
                  if (_bind$19 === 111) {
                    _tmp = 24;
                  } else {
                    if (_bind$19 >= 112 && _bind$19 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 23: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$20 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$20 >= 48 && _bind$20 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$20 >= 65 && _bind$20 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$20 === 95) {
                _tmp = 7;
              } else {
                if (_bind$20 >= 97 && _bind$20 <= 115) {
                  _tmp = 7;
                } else {
                  if (_bind$20 === 116) {
                    _tmp = 17;
                  } else {
                    if (_bind$20 >= 117 && _bind$20 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 24: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$21 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$21 >= 48 && _bind$21 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$21 >= 65 && _bind$21 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$21 === 95) {
                _tmp = 7;
              } else {
                if (_bind$21 >= 97 && _bind$21 <= 107) {
                  _tmp = 7;
                } else {
                  if (_bind$21 === 108) {
                    _tmp = 27;
                  } else {
                    if (_bind$21 >= 109 && _bind$21 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 25: {
          const _bind$22 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$22 >= 48 && _bind$22 <= 57) {
            _tmp = 26;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 26: {
          _tag_2 = lexbuf.pos;
          const _bind$23 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$23 === 9) {
            _tmp = 29;
          } else {
            if (_bind$23 === 32) {
              _tmp = 29;
            } else {
              if (_bind$23 === 41) {
                _tmp = 28;
              } else {
                if (_bind$23 >= 48 && _bind$23 <= 57) {
                  _tmp = 26;
                } else {
                  break _L$2;
                }
              }
            }
          }
          continue _L$2;
        }
        case 27: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$24 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$24 >= 48 && _bind$24 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$24 >= 65 && _bind$24 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$24 === 95) {
                _tmp = 7;
              } else {
                if (_bind$24 >= 97 && _bind$24 <= 114) {
                  _tmp = 7;
                } else {
                  if (_bind$24 === 115) {
                    _tmp = 30;
                  } else {
                    if (_bind$24 >= 116 && _bind$24 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 28: {
          _match_pattern = 3;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          _capture_1_start = _match_start + 1 | 0;
          _capture_1_end = _tag_0;
          _capture_2_start = _tag_1;
          _capture_2_end = _tag_2;
          break _L$2;
        }
        case 29: {
          const _bind$25 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          switch (_bind$25) {
            case 9: {
              _tmp = 29;
              break;
            }
            case 32: {
              _tmp = 29;
              break;
            }
            case 41: {
              _tmp = 28;
              break;
            }
            default: {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 30: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$26 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$26 >= 48 && _bind$26 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$26 >= 65 && _bind$26 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$26 === 95) {
                _tmp = 7;
              } else {
                if (_bind$26 >= 97 && _bind$26 <= 115) {
                  _tmp = 7;
                } else {
                  if (_bind$26 === 116) {
                    _tmp = 31;
                  } else {
                    if (_bind$26 >= 117 && _bind$26 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 31: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$27 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$27 >= 48 && _bind$27 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$27 >= 65 && _bind$27 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$27 === 95) {
                _tmp = 7;
              } else {
                if (_bind$27 === 97) {
                  _tmp = 32;
                } else {
                  if (_bind$27 >= 98 && _bind$27 <= 122) {
                    _tmp = 7;
                  } else {
                    break _L$2;
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 32: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$28 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$28 >= 48 && _bind$28 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$28 >= 65 && _bind$28 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$28 === 95) {
                _tmp = 7;
              } else {
                if (_bind$28 >= 97 && _bind$28 <= 113) {
                  _tmp = 7;
                } else {
                  if (_bind$28 === 114) {
                    _tmp = 33;
                  } else {
                    if (_bind$28 >= 115 && _bind$28 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 33: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$29 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$29 >= 48 && _bind$29 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$29 >= 65 && _bind$29 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$29 === 95) {
                _tmp = 7;
              } else {
                if (_bind$29 >= 97 && _bind$29 <= 115) {
                  _tmp = 7;
                } else {
                  if (_bind$29 === 116) {
                    _tmp = 34;
                  } else {
                    if (_bind$29 >= 117 && _bind$29 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 34: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$30 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$30 >= 48 && _bind$30 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$30 >= 65 && _bind$30 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$30 === 95) {
                _tmp = 7;
              } else {
                if (_bind$30 >= 97 && _bind$30 <= 111) {
                  _tmp = 7;
                } else {
                  if (_bind$30 === 112) {
                    _tmp = 35;
                  } else {
                    if (_bind$30 >= 113 && _bind$30 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 35: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$31 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$31 >= 48 && _bind$31 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$31 >= 65 && _bind$31 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$31 === 95) {
                _tmp = 7;
              } else {
                if (_bind$31 >= 97 && _bind$31 <= 110) {
                  _tmp = 7;
                } else {
                  if (_bind$31 === 111) {
                    _tmp = 36;
                  } else {
                    if (_bind$31 >= 112 && _bind$31 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 36: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$32 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$32 >= 48 && _bind$32 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$32 >= 65 && _bind$32 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$32 === 95) {
                _tmp = 7;
              } else {
                if (_bind$32 >= 97 && _bind$32 <= 114) {
                  _tmp = 7;
                } else {
                  if (_bind$32 === 115) {
                    _tmp = 21;
                  } else {
                    if (_bind$32 >= 116 && _bind$32 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 37: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$33 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$33 >= 48 && _bind$33 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$33 >= 65 && _bind$33 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$33 === 95) {
                _tmp = 7;
              } else {
                if (_bind$33 >= 97 && _bind$33 <= 110) {
                  _tmp = 7;
                } else {
                  if (_bind$33 === 111) {
                    _tmp = 40;
                  } else {
                    if (_bind$33 >= 112 && _bind$33 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 38: {
          _tag_1 = lexbuf.pos;
          const _bind$34 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$34 === 9) {
            _tmp = 38;
          } else {
            if (_bind$34 === 32) {
              _tmp = 38;
            } else {
              if (_bind$34 === 36) {
                _tmp = 25;
              } else {
                if (_bind$34 >= 65 && _bind$34 <= 90) {
                  _tmp = 39;
                } else {
                  if (_bind$34 === 95) {
                    _tmp = 39;
                  } else {
                    if (_bind$34 >= 97 && _bind$34 <= 122) {
                      _tmp = 39;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 39: {
          _tag_2 = lexbuf.pos;
          const _bind$35 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$35 === 9) {
            _tmp = 29;
          } else {
            if (_bind$35 === 32) {
              _tmp = 29;
            } else {
              if (_bind$35 === 41) {
                _tmp = 28;
              } else {
                if (_bind$35 >= 48 && _bind$35 <= 57) {
                  _tmp = 39;
                } else {
                  if (_bind$35 >= 65 && _bind$35 <= 90) {
                    _tmp = 39;
                  } else {
                    if (_bind$35 === 95) {
                      _tmp = 39;
                    } else {
                      if (_bind$35 >= 97 && _bind$35 <= 122) {
                        _tmp = 39;
                      } else {
                        break _L$2;
                      }
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 40: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$36 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$36 >= 48 && _bind$36 <= 57) {
            _tmp = 7;
          } else {
            if (_bind$36 >= 65 && _bind$36 <= 90) {
              _tmp = 7;
            } else {
              if (_bind$36 === 95) {
                _tmp = 7;
              } else {
                if (_bind$36 >= 97 && _bind$36 <= 114) {
                  _tmp = 7;
                } else {
                  if (_bind$36 === 115) {
                    _tmp = 16;
                  } else {
                    if (_bind$36 >= 116 && _bind$36 <= 122) {
                      _tmp = 7;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        default: {
          $panic();
          break _L$2;
        }
      }
    }
    if (_match_pattern <= 7) {
      moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$reset$247$(lexbuf, _match_end);
      const _bind = _match_pattern;
      switch (_bind) {
        case 0: {
          moonbitlang$core$builtin$$Logger$write_string$3$(sb, "{");
          const _bind$2 = moonbitlang$yacc$lib$parser$$code_rbrace(sb, subst, base, lexbuf);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _ok._0;
          } else {
            return _bind$2;
          }
          moonbitlang$core$builtin$$Logger$write_string$3$(sb, "}");
          continue _L;
        }
        case 1: {
          return new Result$Ok$40$(undefined);
        }
        case 2: {
          const t = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          const t1 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_1_start, _capture_1_end);
          moonbitlang$core$builtin$$Logger$write_string$3$(sb, t);
          let index;
          let _try_err;
          _L$3: {
            _L$4: {
              const _bind$3 = moonbitlang$core$strconv$$parse_int$46$inner({ str: t1, start: 0, end: t1.length }, 10);
              if (_bind$3.$tag === 1) {
                const _ok = _bind$3;
                index = _ok._0;
              } else {
                const _err = _bind$3;
                const _tmp$2 = _err._0;
                _try_err = _tmp$2;
                break _L$4;
              }
              break _L$3;
            }
            index = moonbitlang$core$builtin$$abort$17$(moonbitlang$core$builtin$$Show$to_string$12$(_try_err), "@moonbitlang/yacc/lib/parser:lexer.mbt:1806:16-1806:43");
          }
          moonbitlang$core$array$$Array$push$143$(subst, { start: _capture_0_start - base | 0, end: _capture_0_end - base | 0, desc: new $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$Dollar(index) });
          continue _L;
        }
        case 3: {
          const t$2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          const t1$2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_1_start, _capture_1_end);
          const t2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_2_start, _capture_2_end);
          moonbitlang$core$builtin$$Logger$write_string$3$(sb, t$2);
          let arg;
          if (moonbitlang$core$string$$String$has_prefix(t2, { str: moonbitlang$yacc$lib$parser$$code_rbrace$46$42$bind$124$2449, start: 0, end: moonbitlang$yacc$lib$parser$$code_rbrace$46$42$bind$124$2449.length })) {
            let index$2;
            let _try_err$2;
            _L$4: {
              _L$5: {
                let _bind$3;
                let _try_err$3;
                _L$6: {
                  _L$7: {
                    const _bind$4 = moonbitlang$core$string$$String$sub$46$inner(t2, 1, undefined);
                    let _tmp$2;
                    if (_bind$4.$tag === 1) {
                      const _ok = _bind$4;
                      _tmp$2 = _ok._0;
                    } else {
                      const _err = _bind$4;
                      const _tmp$3 = _err._0;
                      _try_err$3 = _tmp$3;
                      break _L$7;
                    }
                    _bind$3 = moonbitlang$core$builtin$$Show$to_string$14$(_tmp$2);
                    break _L$6;
                  }
                  _bind$3 = $panic();
                }
                const _bind$4 = moonbitlang$core$strconv$$parse_int$46$inner({ str: _bind$3, start: 0, end: _bind$3.length }, 10);
                if (_bind$4.$tag === 1) {
                  const _ok = _bind$4;
                  index$2 = _ok._0;
                } else {
                  const _err = _bind$4;
                  const _tmp$2 = _err._0;
                  _try_err$2 = _tmp$2;
                  break _L$5;
                }
                break _L$4;
              }
              index$2 = moonbitlang$core$builtin$$abort$17$(moonbitlang$core$builtin$$Show$to_string$12$(_try_err$2), "@moonbitlang/yacc/lib/parser:lexer.mbt:1824:18-1824:45");
            }
            arg = new $64$moonbitlang$47$yacc$47$lib$47$ast$46$ClauseItemIdent$Dollar(index$2);
          } else {
            arg = new $64$moonbitlang$47$yacc$47$lib$47$ast$46$ClauseItemIdent$Name(t2);
          }
          const _tmp$2 = _capture_0_start - base | 0;
          const _tmp$3 = _capture_0_end - base | 0;
          let _tmp$4;
          switch (t1$2) {
            case "startpos": {
              _tmp$4 = new $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$StartPosOf(arg);
              break;
            }
            case "endpos": {
              _tmp$4 = new $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$EndPosOf(arg);
              break;
            }
            case "loc": {
              _tmp$4 = new $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$LocOf(arg);
              break;
            }
            default: {
              _tmp$4 = $panic();
            }
          }
          moonbitlang$core$array$$Array$push$143$(subst, { start: _tmp$2, end: _tmp$3, desc: _tmp$4 });
          continue _L;
        }
        case 4: {
          const t$3 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          const t1$3 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_1_start, _capture_1_end);
          moonbitlang$core$builtin$$Logger$write_string$3$(sb, t$3);
          const _tmp$5 = _capture_0_start - base | 0;
          const _tmp$6 = _capture_0_end - base | 0;
          let _tmp$7;
          switch (t1$3) {
            case "startpos": {
              _tmp$7 = $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$StartPos;
              break;
            }
            case "endpos": {
              _tmp$7 = $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$EndPos;
              break;
            }
            case "loc": {
              _tmp$7 = $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$Loc;
              break;
            }
            case "symbolstartpos": {
              _tmp$7 = $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$SymbolStartPos;
              break;
            }
            case "sloc": {
              _tmp$7 = $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$Sloc;
              break;
            }
            default: {
              _tmp$7 = $panic();
            }
          }
          moonbitlang$core$array$$Array$push$143$(subst, { start: _tmp$5, end: _tmp$6, desc: _tmp$7 });
          continue _L;
        }
        case 5: {
          const t$4 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          moonbitlang$core$builtin$$Logger$write_string$3$(sb, t$4);
          continue _L;
        }
        case 6: {
          const t$5 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_char$247$(lexbuf, _capture_0_start, _capture_0_end);
          moonbitlang$core$builtin$$Logger$write_char$3$(sb, t$5);
          continue _L;
        }
        case 7: {
          return new Result$Err$40$(Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile);
        }
        default: {
          return new Result$Ok$40$($panic());
        }
      }
    } else {
      return new Result$Ok$40$($panic());
    }
  }
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen(lexbuf) {
  _L: while (true) {
    let _match_pattern = moonbitlang$core$int$$max_value;
    lexbuf.pos;
    let _match_end = -1;
    let _tmp = 0;
    _L$2: while (true) {
      const _param = _tmp;
      switch (_param) {
        case 0: {
          const _bind = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind === -1) {
            _tmp = 1;
          } else {
            if (_bind >= 0 && _bind <= 39) {
              _tmp = 2;
            } else {
              if (_bind === 40) {
                _tmp = 3;
              } else {
                if (_bind === 41) {
                  _tmp = 2;
                } else {
                  if (_bind === 42) {
                    _tmp = 4;
                  } else {
                    if (_bind >= 43 && _bind <= 1114111) {
                      _tmp = 2;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 1: {
          _match_pattern = 3;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 2: {
          _match_pattern = 2;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 3: {
          _match_pattern = 2;
          _match_end = lexbuf.pos;
          const _bind$2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$2 === 42) {
            _tmp = 6;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 4: {
          _match_pattern = 2;
          _match_end = lexbuf.pos;
          const _bind$3 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$3 === 41) {
            _tmp = 5;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 5: {
          _match_pattern = 1;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 6: {
          _match_pattern = 0;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        default: {
          $panic();
          break _L$2;
        }
      }
    }
    if (_match_pattern <= 3) {
      moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$reset$247$(lexbuf, _match_end);
      const _bind = _match_pattern;
      switch (_bind) {
        case 0: {
          const _bind$2 = moonbitlang$yacc$lib$parser$$comment_star_rparen(lexbuf);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _ok._0;
          } else {
            return _bind$2;
          }
          continue _L;
        }
        case 1: {
          return new Result$Ok$40$(undefined);
        }
        case 2: {
          continue _L;
        }
        case 3: {
          return new Result$Err$40$(Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile);
        }
        default: {
          return new Result$Ok$40$($panic());
        }
      }
    } else {
      return new Result$Ok$40$($panic());
    }
  }
}
function moonbitlang$yacc$lib$parser$$token(phase, lexbuf) {
  _L: while (true) {
    let _match_pattern = moonbitlang$core$int$$max_value;
    let _match_start = lexbuf.pos;
    let _match_end = -1;
    let _capture_0_start = -1;
    let _capture_0_end = -1;
    let _capture_1_start = -1;
    let _capture_1_end = -1;
    let _capture_2_start = -1;
    let _capture_2_end = -1;
    let _tag_0 = -1;
    let _tag_1 = -1;
    let _tmp = 0;
    _L$2: while (true) {
      const _param = _tmp;
      switch (_param) {
        case 0: {
          const _bind = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind === -1) {
            _tmp = 1;
          } else {
            if (_bind >= 0 && _bind <= 8) {
              _tmp = 2;
            } else {
              if (_bind >= 9 && _bind <= 10) {
                _tmp = 3;
              } else {
                if (_bind >= 11 && _bind <= 31) {
                  _tmp = 2;
                } else {
                  if (_bind === 32) {
                    _tmp = 3;
                  } else {
                    if (_bind === 33) {
                      _tmp = 2;
                    } else {
                      if (_bind === 34) {
                        _tmp = 4;
                      } else {
                        if (_bind >= 35 && _bind <= 36) {
                          _tmp = 2;
                        } else {
                          if (_bind === 37) {
                            _tmp = 5;
                          } else {
                            if (_bind >= 38 && _bind <= 39) {
                              _tmp = 2;
                            } else {
                              if (_bind === 40) {
                                _tmp = 6;
                              } else {
                                if (_bind === 41) {
                                  _tmp = 7;
                                } else {
                                  if (_bind >= 42 && _bind <= 43) {
                                    _tmp = 2;
                                  } else {
                                    if (_bind === 44) {
                                      _tmp = 8;
                                    } else {
                                      if (_bind === 45) {
                                        _tmp = 9;
                                      } else {
                                        if (_bind === 46) {
                                          _tmp = 2;
                                        } else {
                                          if (_bind === 47) {
                                            _tmp = 10;
                                          } else {
                                            if (_bind >= 48 && _bind <= 57) {
                                              _tmp = 2;
                                            } else {
                                              if (_bind === 58) {
                                                _tmp = 11;
                                              } else {
                                                if (_bind === 59) {
                                                  _tmp = 12;
                                                } else {
                                                  if (_bind === 60) {
                                                    _tmp = 13;
                                                  } else {
                                                    if (_bind === 61) {
                                                      _tmp = 14;
                                                    } else {
                                                      if (_bind === 62) {
                                                        _tmp = 2;
                                                      } else {
                                                        if (_bind === 63) {
                                                          _tmp = 15;
                                                        } else {
                                                          if (_bind === 64) {
                                                            _tmp = 16;
                                                          } else {
                                                            if (_bind >= 65 && _bind <= 90) {
                                                              _tmp = 17;
                                                            } else {
                                                              if (_bind === 91) {
                                                                _tmp = 18;
                                                              } else {
                                                                if (_bind === 92) {
                                                                  _tmp = 2;
                                                                } else {
                                                                  if (_bind === 93) {
                                                                    _tmp = 19;
                                                                  } else {
                                                                    if (_bind === 94) {
                                                                      _tmp = 2;
                                                                    } else {
                                                                      if (_bind === 95) {
                                                                        _tmp = 17;
                                                                      } else {
                                                                        if (_bind === 96) {
                                                                          _tmp = 2;
                                                                        } else {
                                                                          if (_bind >= 97 && _bind <= 122) {
                                                                            _tmp = 17;
                                                                          } else {
                                                                            if (_bind === 123) {
                                                                              _tmp = 20;
                                                                            } else {
                                                                              if (_bind === 124) {
                                                                                _tmp = 21;
                                                                              } else {
                                                                                if (_bind >= 125 && _bind <= 1114111) {
                                                                                  _tmp = 2;
                                                                                } else {
                                                                                  break _L$2;
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 1: {
          _match_pattern = 34;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          break _L$2;
        }
        case 2: {
          _match_pattern = 33;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 3: {
          _match_pattern = 0;
          _match_end = lexbuf.pos;
          const _bind$2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$2 >= 9 && _bind$2 <= 10) {
            _tmp = 3;
          } else {
            if (_bind$2 === 32) {
              _tmp = 3;
            } else {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 4: {
          _match_pattern = 33;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$3 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$3 >= 0 && _bind$3 <= 33) {
            _tmp = 22;
          } else {
            if (_bind$3 >= 35 && _bind$3 <= 1114111) {
              _tmp = 22;
            } else {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 5: {
          _match_pattern = 33;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$4 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          switch (_bind$4) {
            case 37: {
              _tmp = 24;
              break;
            }
            case 100: {
              _tmp = 25;
              break;
            }
            case 105: {
              _tmp = 26;
              break;
            }
            case 108: {
              _tmp = 27;
              break;
            }
            case 110: {
              _tmp = 28;
              break;
            }
            case 112: {
              _tmp = 29;
              break;
            }
            case 114: {
              _tmp = 30;
              break;
            }
            case 115: {
              _tmp = 31;
              break;
            }
            case 116: {
              _tmp = 32;
              break;
            }
            case 123: {
              _tmp = 33;
              break;
            }
            default: {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 6: {
          _match_pattern = 27;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$5 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$5 === 42) {
            _tmp = 37;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 7: {
          _match_pattern = 28;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 8: {
          _match_pattern = 29;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 9: {
          _match_pattern = 33;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$6 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$6 === 62) {
            _tmp = 23;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 10: {
          _match_pattern = 33;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$7 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          switch (_bind$7) {
            case 42: {
              _tmp = 35;
              break;
            }
            case 47: {
              _tmp = 36;
              break;
            }
            default: {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 11: {
          _match_pattern = 19;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 12: {
          _match_pattern = 22;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 13: {
          _match_pattern = 24;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 14: {
          _match_pattern = 21;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 15: {
          _match_pattern = 30;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 16: {
          _match_pattern = 33;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$8 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$8 >= 65 && _bind$8 <= 90) {
            _tmp = 34;
          } else {
            if (_bind$8 === 95) {
              _tmp = 34;
            } else {
              if (_bind$8 >= 97 && _bind$8 <= 122) {
                _tmp = 34;
              } else {
                break _L$2;
              }
            }
          }
          continue _L$2;
        }
        case 17: {
          _match_pattern = 6;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$9 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$9 >= 48 && _bind$9 <= 57) {
            _tmp = 17;
          } else {
            if (_bind$9 >= 65 && _bind$9 <= 90) {
              _tmp = 17;
            } else {
              if (_bind$9 === 95) {
                _tmp = 17;
              } else {
                if (_bind$9 >= 97 && _bind$9 <= 122) {
                  _tmp = 17;
                } else {
                  break _L$2;
                }
              }
            }
          }
          continue _L$2;
        }
        case 18: {
          _match_pattern = 25;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 19: {
          _match_pattern = 26;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 20: {
          _match_pattern = 31;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 21: {
          _match_pattern = 20;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 22: {
          const _bind$10 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$10 >= 0 && _bind$10 <= 33) {
            _tmp = 22;
          } else {
            if (_bind$10 === 34) {
              _tmp = 38;
            } else {
              if (_bind$10 >= 35 && _bind$10 <= 1114111) {
                _tmp = 22;
              } else {
                break _L$2;
              }
            }
          }
          continue _L$2;
        }
        case 23: {
          _match_pattern = 18;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 2 | 0;
          break _L$2;
        }
        case 24: {
          _match_pattern = 17;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 2 | 0;
          break _L$2;
        }
        case 25: {
          const _bind$11 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$11 === 101) {
            _tmp = 40;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 26: {
          const _bind$12 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$12 === 110) {
            _tmp = 39;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 27: {
          const _bind$13 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$13 === 101) {
            _tmp = 43;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 28: {
          const _bind$14 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$14 === 111) {
            _tmp = 41;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 29: {
          const _bind$15 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          switch (_bind$15) {
            case 111: {
              _tmp = 44;
              break;
            }
            case 114: {
              _tmp = 45;
              break;
            }
            default: {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 30: {
          const _bind$16 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$16 === 105) {
            _tmp = 42;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 31: {
          const _bind$17 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$17 === 116) {
            _tmp = 48;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 32: {
          const _bind$18 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          switch (_bind$18) {
            case 111: {
              _tmp = 46;
              break;
            }
            case 121: {
              _tmp = 47;
              break;
            }
            default: {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 33: {
          _match_pattern = 23;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 2 | 0;
          break _L$2;
        }
        case 34: {
          _tag_0 = lexbuf.pos;
          const _bind$19 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$19 === 46) {
            _tmp = 60;
          } else {
            if (_bind$19 === 47) {
              _tmp = 62;
            } else {
              if (_bind$19 >= 48 && _bind$19 <= 57) {
                _tmp = 34;
              } else {
                if (_bind$19 >= 65 && _bind$19 <= 90) {
                  _tmp = 34;
                } else {
                  if (_bind$19 === 95) {
                    _tmp = 34;
                  } else {
                    if (_bind$19 >= 97 && _bind$19 <= 122) {
                      _tmp = 34;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 35: {
          const _bind$20 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$20 >= 0 && _bind$20 <= 41) {
            _tmp = 35;
          } else {
            if (_bind$20 === 42) {
              _tmp = 65;
            } else {
              if (_bind$20 >= 43 && _bind$20 <= 46) {
                _tmp = 35;
              } else {
                if (_bind$20 === 47) {
                  _tmp = 64;
                } else {
                  if (_bind$20 >= 48 && _bind$20 <= 1114111) {
                    _tmp = 35;
                  } else {
                    break _L$2;
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 36: {
          _match_pattern = 4;
          _match_end = lexbuf.pos;
          const _bind$21 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$21 >= 0 && _bind$21 <= 9) {
            _tmp = 36;
          } else {
            if (_bind$21 === 10) {
              _tmp = 63;
            } else {
              if (_bind$21 >= 11 && _bind$21 <= 1114111) {
                _tmp = 36;
              } else {
                break _L$2;
              }
            }
          }
          continue _L$2;
        }
        case 37: {
          _match_pattern = 2;
          _match_end = lexbuf.pos;
          const _bind$22 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$22 === 41) {
            _tmp = 49;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 38: {
          _match_pattern = 32;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          break _L$2;
        }
        case 39: {
          const _bind$23 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$23 === 108) {
            _tmp = 50;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 40: {
          const _bind$24 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$24 === 114) {
            _tmp = 51;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 41: {
          const _bind$25 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$25 === 110) {
            _tmp = 52;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 42: {
          const _bind$26 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$26 === 103) {
            _tmp = 53;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 43: {
          const _bind$27 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$27 === 102) {
            _tmp = 54;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 44: {
          const _bind$28 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$28 === 115) {
            _tmp = 56;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 45: {
          const _bind$29 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$29 === 101) {
            _tmp = 55;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 46: {
          const _bind$30 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$30 === 107) {
            _tmp = 58;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 47: {
          const _bind$31 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$31 === 112) {
            _tmp = 57;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 48: {
          const _bind$32 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$32 === 97) {
            _tmp = 59;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 49: {
          _match_pattern = 1;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 50: {
          const _bind$33 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$33 === 105) {
            _tmp = 67;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 51: {
          const _bind$34 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$34 === 105) {
            _tmp = 68;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 52: {
          const _bind$35 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$35 === 97) {
            _tmp = 69;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 53: {
          const _bind$36 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$36 === 104) {
            _tmp = 70;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 54: {
          const _bind$37 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$37 === 116) {
            _tmp = 71;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 55: {
          const _bind$38 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$38 === 99) {
            _tmp = 72;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 56: {
          const _bind$39 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$39 === 105) {
            _tmp = 73;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 57: {
          const _bind$40 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$40 === 101) {
            _tmp = 74;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 58: {
          const _bind$41 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$41 === 101) {
            _tmp = 75;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 59: {
          const _bind$42 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$42 === 114) {
            _tmp = 76;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 60: {
          _tag_1 = lexbuf.pos;
          const _bind$43 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$43 >= 65 && _bind$43 <= 90) {
            _tmp = 61;
          } else {
            if (_bind$43 === 95) {
              _tmp = 61;
            } else {
              if (_bind$43 >= 97 && _bind$43 <= 122) {
                _tmp = 61;
              } else {
                break _L$2;
              }
            }
          }
          continue _L$2;
        }
        case 61: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          _capture_1_start = _tag_1;
          _capture_1_end = _match_end;
          _capture_2_start = _match_start + 1 | 0;
          _capture_2_end = _tag_0;
          const _bind$44 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$44 >= 48 && _bind$44 <= 57) {
            _tmp = 61;
          } else {
            if (_bind$44 >= 65 && _bind$44 <= 90) {
              _tmp = 61;
            } else {
              if (_bind$44 === 95) {
                _tmp = 61;
              } else {
                if (_bind$44 >= 97 && _bind$44 <= 122) {
                  _tmp = 61;
                } else {
                  break _L$2;
                }
              }
            }
          }
          continue _L$2;
        }
        case 62: {
          const _bind$45 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$45 >= 65 && _bind$45 <= 90) {
            _tmp = 34;
          } else {
            if (_bind$45 === 95) {
              _tmp = 34;
            } else {
              if (_bind$45 >= 97 && _bind$45 <= 122) {
                _tmp = 34;
              } else {
                break _L$2;
              }
            }
          }
          continue _L$2;
        }
        case 63: {
          _match_pattern = 4;
          _match_end = lexbuf.pos;
          break _L$2;
        }
        case 64: {
          const _bind$46 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$46 >= 0 && _bind$46 <= 41) {
            _tmp = 35;
          } else {
            if (_bind$46 >= 43 && _bind$46 <= 1114111) {
              _tmp = 35;
            } else {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 65: {
          const _bind$47 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$47 >= 0 && _bind$47 <= 41) {
            _tmp = 35;
          } else {
            if (_bind$47 === 42) {
              _tmp = 65;
            } else {
              if (_bind$47 >= 43 && _bind$47 <= 46) {
                _tmp = 35;
              } else {
                if (_bind$47 === 47) {
                  _tmp = 66;
                } else {
                  if (_bind$47 >= 48 && _bind$47 <= 1114111) {
                    _tmp = 35;
                  } else {
                    break _L$2;
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 66: {
          _match_pattern = 3;
          _match_end = lexbuf.pos;
          const _bind$48 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$48 >= 0 && _bind$48 <= 41) {
            _tmp = 35;
          } else {
            if (_bind$48 >= 43 && _bind$48 <= 1114111) {
              _tmp = 35;
            } else {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 67: {
          const _bind$49 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$49 === 110) {
            _tmp = 77;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 68: {
          const _bind$50 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$50 === 118) {
            _tmp = 78;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 69: {
          const _bind$51 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$51 === 115) {
            _tmp = 79;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 70: {
          const _bind$52 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$52 === 116) {
            _tmp = 80;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 71: {
          _match_pattern = 11;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 5 | 0;
          break _L$2;
        }
        case 72: {
          _match_pattern = 14;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 5 | 0;
          break _L$2;
        }
        case 73: {
          const _bind$53 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$53 === 116) {
            _tmp = 81;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 74: {
          _match_pattern = 9;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 5 | 0;
          break _L$2;
        }
        case 75: {
          const _bind$54 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$54 === 110) {
            _tmp = 82;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 76: {
          const _bind$55 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$55 === 116) {
            _tmp = 83;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 77: {
          const _bind$56 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$56 === 101) {
            _tmp = 84;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 78: {
          const _bind$57 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$57 === 101) {
            _tmp = 85;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 79: {
          const _bind$58 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$58 === 115) {
            _tmp = 86;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 80: {
          _match_pattern = 12;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 6 | 0;
          break _L$2;
        }
        case 81: {
          const _bind$59 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$59 === 105) {
            _tmp = 87;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 82: {
          _match_pattern = 8;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 6 | 0;
          break _L$2;
        }
        case 83: {
          _match_pattern = 7;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 6 | 0;
          break _L$2;
        }
        case 84: {
          _match_pattern = 16;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 7 | 0;
          break _L$2;
        }
        case 85: {
          _match_pattern = 15;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 7 | 0;
          break _L$2;
        }
        case 86: {
          const _bind$60 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$60 === 111) {
            _tmp = 88;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 87: {
          const _bind$61 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$61 === 111) {
            _tmp = 89;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 88: {
          const _bind$62 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$62 === 99) {
            _tmp = 90;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 89: {
          const _bind$63 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$63 === 110) {
            _tmp = 91;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 90: {
          _match_pattern = 13;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 9 | 0;
          break _L$2;
        }
        case 91: {
          _match_pattern = 10;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 9 | 0;
          break _L$2;
        }
        default: {
          $panic();
          break _L$2;
        }
      }
    }
    if (_match_pattern <= 34) {
      moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$reset$247$(lexbuf, _match_end);
      const _bind = _match_pattern;
      switch (_bind) {
        case 0: {
          continue _L;
        }
        case 1: {
          continue _L;
        }
        case 2: {
          const _bind$2 = moonbitlang$yacc$lib$parser$$comment_star_rparen(lexbuf);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _ok._0;
          } else {
            return _bind$2;
          }
          continue _L;
        }
        case 3: {
          continue _L;
        }
        case 4: {
          continue _L;
        }
        case 5: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          const id = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_1_start, _capture_1_end);
          const pkg = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_2_start, _capture_2_end);
          return new Result$Ok$41$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PKG_AND_IDENT({ _0: pkg, _1: id }), _1: _capture_0_start, _2: _capture_0_end });
        }
        case 6: {
          const t = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$IDENT(t), _1: _capture_0_start, _2: _capture_0_end });
        }
        case 7: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_START, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 8: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_TOKEN, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 9: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_TYPE, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 10: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_POSITION, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 11: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LEFT, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 12: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_RIGHT, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 13: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_NONASSOC, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 14: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PREC, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 15: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_DERIVE, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 16: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_INLINE, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 17: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          if (phase.val <= 0) {
            phase.val = phase.val + 1 | 0;
            return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT, _1: _capture_0_start, _2: _capture_0_end });
          } else {
            phase.val = phase.val + 1 | 0;
            const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
            moonbitlang$yacc$lib$parser$$code_eof(sb, lexbuf);
            return new Result$Ok$41$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT_CODE_EOF({ _0: sb.val, _1: _capture_0_end, _2: lexbuf.pos - _capture_0_end | 0 }), _1: _capture_0_start, _2: lexbuf.pos });
          }
        }
        case 18: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$ARROW, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 19: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$COLON, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 20: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$BAR, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 21: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$EQ, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 22: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$SEMI, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 23: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          const sb = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
          const _bind$3 = moonbitlang$yacc$lib$parser$$code_percent_rbrace(sb, lexbuf);
          if (_bind$3.$tag === 1) {
            const _ok = _bind$3;
            _ok._0;
          } else {
            return _bind$3;
          }
          return new Result$Ok$41$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LBRACE_CODE_PERCENT_RBRACE({ _0: sb.val, _1: _capture_0_end, _2: lexbuf.pos - _capture_0_end | 0 }), _1: _capture_0_start, _2: lexbuf.pos });
        }
        case 24: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          const sb$2 = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
          const _bind$4 = moonbitlang$yacc$lib$parser$$code_rangle(sb$2, lexbuf);
          if (_bind$4.$tag === 1) {
            const _ok = _bind$4;
            _ok._0;
          } else {
            return _bind$4;
          }
          return new Result$Ok$41$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LANGLE_CODE_RANGLE(sb$2.val), _1: _capture_0_start, _2: lexbuf.pos });
        }
        case 25: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LBRACKET, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 26: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$RBRACKET, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 27: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LPAREN, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 28: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$RPAREN, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 29: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$COMMA, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 30: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$QUESTION, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 31: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          const sb$3 = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
          const subst = [];
          const base = lexbuf.pos;
          const _bind$5 = moonbitlang$yacc$lib$parser$$code_rbrace(sb$3, subst, base, lexbuf);
          if (_bind$5.$tag === 1) {
            const _ok = _bind$5;
            _ok._0;
          } else {
            return _bind$5;
          }
          return new Result$Ok$41$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LBRACE_CODE_RBRACE({ _0: sb$3.val, _1: base, _2: subst }), _1: _capture_0_start, _2: lexbuf.pos });
        }
        case 32: {
          const t$2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$STRING(t$2), _1: _capture_0_start, _2: _capture_0_end });
        }
        case 33: {
          const t$3 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_char$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Err$41$(new Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$Unrecognized(t$3, _capture_0_start));
        }
        case 34: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$41$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$EOF, _1: _capture_0_start, _2: _capture_0_end });
        }
        default: {
          return new Result$Ok$41$($panic());
        }
      }
    } else {
      return new Result$Ok$41$($panic());
    }
  }
}
function moonbitlang$yacc$lib$parser$$new_lexer(input) {
  return { buf: moonbitlang$ulex$45$runtime$lexbuf$$StringLexbuf$from_string(input), phase: { val: 0 } };
}
function moonbitlang$yacc$lib$parser$$Lexer$next_token(self) {
  return moonbitlang$yacc$lib$parser$$token(self.phase, self.buf);
}
function moonbitlang$core$builtin$$Show$output$61$(_x_253, _x_254) {
  const _Unrecognized = _x_253;
  const _$42$arg_255 = _Unrecognized._0;
  const _$42$arg_256 = _Unrecognized._1;
  _x_254.method_table.method_0(_x_254.self, "Unrecognized(");
  moonbitlang$core$builtin$$Logger$write_object$59$(_x_254, _$42$arg_255);
  _x_254.method_table.method_0(_x_254.self, ", ");
  moonbitlang$core$builtin$$Logger$write_object$17$(_x_254, _$42$arg_256);
  _x_254.method_table.method_0(_x_254.self, ")");
}
function moonbitlang$core$builtin$$Show$output$126$(_x_245, _x_246) {
  if (_x_245.$tag === 8) {
    const _ParseError = _x_245;
    const _$42$arg_247 = _ParseError._0;
    _x_246.method_table.method_0(_x_246.self, "ParseError(");
    moonbitlang$core$builtin$$Logger$write_object$60$(_x_246, _$42$arg_247);
    _x_246.method_table.method_0(_x_246.self, ")");
    return;
  } else {
    const _LexError = _x_245;
    const _$42$arg_248 = _LexError._0;
    _x_246.method_table.method_0(_x_246.self, "LexError(");
    moonbitlang$core$builtin$$Logger$write_object$61$(_x_246, _$42$arg_248);
    _x_246.method_table.method_0(_x_246.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$60$(_x_227, _x_228) {
  if (_x_227.$tag === 1) {
    const _UnexpectedToken = _x_227;
    const _$42$arg_229 = _UnexpectedToken._0;
    const _$42$arg_230 = _UnexpectedToken._1;
    const _$42$arg_231 = _UnexpectedToken._2;
    _x_228.method_table.method_0(_x_228.self, "UnexpectedToken(");
    moonbitlang$core$builtin$$Logger$write_object$56$(_x_228, _$42$arg_229);
    _x_228.method_table.method_0(_x_228.self, ", ");
    const _$42$x0_232 = _$42$arg_230._0;
    const _$42$x1_233 = _$42$arg_230._1;
    _x_228.method_table.method_0(_x_228.self, "(");
    moonbitlang$core$builtin$$Logger$write_object$17$(_x_228, _$42$x0_232);
    _x_228.method_table.method_0(_x_228.self, ", ");
    moonbitlang$core$builtin$$Logger$write_object$17$(_x_228, _$42$x1_233);
    _x_228.method_table.method_0(_x_228.self, ")");
    const _self = _x_228;
    _self.method_table.method_0(_self.self, ", ");
    moonbitlang$core$builtin$$Logger$write_object$57$(_self, _$42$arg_231);
    _self.method_table.method_0(_self.self, ")");
    return;
  } else {
    const _UnexpectedEndOfInput = _x_227;
    const _$42$arg_234 = _UnexpectedEndOfInput._0;
    const _$42$arg_235 = _UnexpectedEndOfInput._1;
    _x_228.method_table.method_0(_x_228.self, "UnexpectedEndOfInput(");
    moonbitlang$core$builtin$$Logger$write_object$17$(_x_228, _$42$arg_234);
    _x_228.method_table.method_0(_x_228.self, ", ");
    moonbitlang$core$builtin$$Logger$write_object$57$(_x_228, _$42$arg_235);
    _x_228.method_table.method_0(_x_228.self, ")");
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$56$(_x_215, _x_216) {
  switch (_x_215.$tag) {
    case 0: {
      _x_216.method_table.method_0(_x_216.self, "EOF");
      return;
    }
    case 1: {
      _x_216.method_table.method_0(_x_216.self, "LPAREN");
      return;
    }
    case 2: {
      _x_216.method_table.method_0(_x_216.self, "RPAREN");
      return;
    }
    case 3: {
      _x_216.method_table.method_0(_x_216.self, "LBRACKET");
      return;
    }
    case 4: {
      _x_216.method_table.method_0(_x_216.self, "RBRACKET");
      return;
    }
    case 5: {
      _x_216.method_table.method_0(_x_216.self, "COMMA");
      return;
    }
    case 6: {
      _x_216.method_table.method_0(_x_216.self, "ARROW");
      return;
    }
    case 7: {
      _x_216.method_table.method_0(_x_216.self, "QUESTION");
      return;
    }
    case 8: {
      const _IDENT = _x_215;
      const _$42$arg_217 = _IDENT._0;
      _x_216.method_table.method_0(_x_216.self, "IDENT(");
      moonbitlang$core$builtin$$Logger$write_object$13$(_x_216, _$42$arg_217);
      _x_216.method_table.method_0(_x_216.self, ")");
      return;
    }
    default: {
      const _PKG_AND_IDENT = _x_215;
      const _$42$arg_218 = _PKG_AND_IDENT._0;
      _x_216.method_table.method_0(_x_216.self, "PKG_AND_IDENT(");
      const _$42$x0_219 = _$42$arg_218._0;
      const _$42$x1_220 = _$42$arg_218._1;
      _x_216.method_table.method_0(_x_216.self, "(");
      moonbitlang$core$builtin$$Logger$write_object$13$(_x_216, _$42$x0_219);
      _x_216.method_table.method_0(_x_216.self, ", ");
      moonbitlang$core$builtin$$Logger$write_object$13$(_x_216, _$42$x1_220);
      _x_216.method_table.method_0(_x_216.self, ")");
      _x_216.method_table.method_0(_x_216.self, ")");
      return;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$62$(self, logger) {
  let _tmp;
  switch (self) {
    case 0: {
      _tmp = "EOF";
      break;
    }
    case 1: {
      _tmp = "\"(\"";
      break;
    }
    case 2: {
      _tmp = "\")\"";
      break;
    }
    case 3: {
      _tmp = "\"[\"";
      break;
    }
    case 4: {
      _tmp = "\"]\"";
      break;
    }
    case 5: {
      _tmp = "\",\"";
      break;
    }
    case 6: {
      _tmp = "\"->\"";
      break;
    }
    case 7: {
      _tmp = "\"?\"";
      break;
    }
    case 8: {
      _tmp = "IDENT";
      break;
    }
    default: {
      _tmp = "PKG_AND_IDENT";
    }
  }
  logger.method_table.method_0(logger.self, _tmp);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_0(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar1 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(__dollar1);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_1(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 45) {
    const _YYObj__String__String_ = _bind;
    const __dollar1 = _YYObj__String__String_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 46) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const __dollar3 = _YYObj__list_List__ast_TypeExpr_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr(__dollar1._0, __dollar1._1, moonbitlang$core$list$$List$to_array$51$(__dollar3)));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_2(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar4 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow([], __dollar4));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_3(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 4)._0;
    if (_bind$2.$tag === 44) {
      const _YYObj__ast_TypeExpr$2 = _bind$2;
      const __dollar5 = _YYObj__ast_TypeExpr$2._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow([__dollar2], __dollar5));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_4(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(__dollar2);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_5(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 5)._0;
    if (_bind$2.$tag === 44) {
      const _YYObj__ast_TypeExpr$2 = _bind$2;
      const __dollar6 = _YYObj__ast_TypeExpr$2._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow([__dollar2], __dollar6));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_6(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar1 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Option(__dollar1));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_7(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar1 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(__dollar1);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_8(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
    if (_bind$2.$tag === 46) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const __dollar4 = _YYObj__list_List__ast_TypeExpr_._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$at$21$(_args, 6)._0;
      if (_bind$3.$tag === 44) {
        const _YYObj__ast_TypeExpr$2 = _bind$3;
        const __dollar7 = _YYObj__ast_TypeExpr$2._0;
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Arrow(moonbitlang$core$list$$List$to_array$51$(new $64$moonbitlang$47$core$47$list$46$List$More$21$(__dollar2, __dollar4)), __dollar7));
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_9(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 1)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar2 = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 3)._0;
    if (_bind$2.$tag === 46) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const __dollar4 = _YYObj__list_List__ast_TypeExpr_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Tuple(moonbitlang$core$list$$List$to_array$51$(new $64$moonbitlang$47$core$47$list$46$List$More$21$(__dollar2, __dollar4))));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_10(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const __dollar1 = _YYObj__ast_TypeExpr._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(__dollar1);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_11(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 47) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 46) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const __dollar3 = _YYObj__list_List__ast_TypeExpr_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr(undefined, __dollar1, moonbitlang$core$list$$List$to_array$51$(__dollar3)));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_12(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 47) {
    const _YYObj_String = _bind;
    const __dollar1 = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr(undefined, __dollar1, []));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_13(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const _type_expr = _YYObj__ast_TypeExpr._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$at$21$(_args, 2)._0;
    if (_bind$2.$tag === 46) {
      const _YYObj__list_List__ast_TypeExpr_ = _bind$2;
      const _type_expr_list = _YYObj__list_List__ast_TypeExpr_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__list_List__ast_TypeExpr_$46$YYObj__list_List__ast_TypeExpr_(new $64$moonbitlang$47$core$47$list$46$List$More$21$(_type_expr, _type_expr_list));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_14(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 44) {
    const _YYObj__ast_TypeExpr = _bind;
    const _type_expr = _YYObj__ast_TypeExpr._0;
    const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$21$;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__list_List__ast_TypeExpr_$46$YYObj__list_List__ast_TypeExpr_(new $64$moonbitlang$47$core$47$list$46$List$More$21$(_type_expr, _p));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_15(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$at$21$(_args, 0)._0;
  if (_bind.$tag === 45) {
    const _YYObj__String__String_ = _bind;
    const __dollar1 = _YYObj__String__String_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__ast_TypeExpr$46$YYObj__ast_TypeExpr(new $64$moonbitlang$47$yacc$47$lib$47$ast$46$TypeExpr$Constr(__dollar1._0, __dollar1._1, []));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_input(token, _start_pos, _end_pos) {
  switch (token.$tag) {
    case 0: {
      return { _0: 0, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 1: {
      return { _0: 1, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 2: {
      return { _0: 2, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 3: {
      return { _0: 3, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 4: {
      return { _0: 4, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 5: {
      return { _0: 5, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 6: {
      return { _0: 6, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 7: {
      return { _0: 7, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 8: {
      const _IDENT = token;
      const _data = _IDENT._0;
      return { _0: 8, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_String$46$YYObj_String(_data) };
    }
    default: {
      const _PKG_AND_IDENT = token;
      const _data$2 = _PKG_AND_IDENT._0;
      return { _0: 9, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj__String__String_$46$YYObj__String__String_(_data$2) };
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_1(_lookahead) {
  return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Accept;
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(1, 12, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_10);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_18(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(7, 11, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_8);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_20(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(2, 12, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_6);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 7: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_20);
      }
      case 0: {
        break _L;
      }
      case 2: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 5: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Reduce(1, 11, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_7);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_31(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(4, 13, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_1);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_30(_lookahead) {
  if (_lookahead === 4) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_31);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_6(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(3, 14, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_13);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_10(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(4, 13, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_11);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_9(_lookahead) {
  if (_lookahead === 4) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_10);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_23(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(6, 11, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_5);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_26(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(5, 11, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_3);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_29(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(4, 11, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_2);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_13);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_27);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_13(_lookahead) {
  switch (_lookahead) {
    case 5: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_14);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_24);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_14(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_4);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 14: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_15);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_21);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_15(_lookahead) {
  if (_lookahead === 2) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_16);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_16(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 6: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_17);
      }
      case 0: {
        break _L;
      }
      case 2: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 7: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Reduce(5, 13, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_9);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_17(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_18);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 3: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_3);
      }
      case 0: {
        break _L;
      }
      case 2: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 7: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Reduce(1, 13, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_15);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_3(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_4);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    case 14: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_30);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_4(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 5: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_5);
      }
      case 2: {
        break _L;
      }
      case 4: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Reduce(1, 14, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_14);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_5(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_4);
    }
    case 14: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_6);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 3: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_8);
      }
      case 0: {
        break _L;
      }
      case 2: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 7: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Reduce(1, 13, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_12);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_8(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_4);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 14: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_9);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_21(_lookahead) {
  if (_lookahead === 6) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_22);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_22(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_23);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_24(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 6: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_25);
      }
      case 0: {
        break _L;
      }
      case 2: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 7: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Reduce(3, 13, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_4);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_25(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_26);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_27(_lookahead) {
  if (_lookahead === 6) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_28);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_28(_lookahead) {
  switch (_lookahead) {
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_29);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_33(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$ReduceNoLookahead(2, 10, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_action_0);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_32(_lookahead) {
  if (_lookahead === 0) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_33);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_0(_lookahead) {
  switch (_lookahead) {
    case 10: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_1);
    }
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_2);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_7);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_11);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_12);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_19);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_32);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$error(stack, token, loc) {
  const expected = [];
  const _arr = [moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7287, moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7288, moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7289, moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7290, moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7291, moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7292, moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7293, moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7294, moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7295, moonbitlang$yacc$lib$parser$type_expr_parser$$error$46$tuple$47$7296];
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const term = _arr[_i];
      const kind = term._1;
      const symbol = term._0;
      let stack$2;
      _L: {
        stack$2 = stack;
        break _L;
      }
      let _tmp$2 = stack$2;
      _L$2: while (true) {
        const stack$3 = _tmp$2;
        if (stack$3.$tag === 0) {
          break;
        } else {
          const _More = stack$3;
          const _state = _More._0;
          let count;
          let symbol$2;
          _L$3: {
            _L$4: {
              const _bind = _state(symbol);
              switch (_bind.$tag) {
                case 0: {
                  break _L$4;
                }
                case 1: {
                  break _L$4;
                }
                case 2: {
                  const _Reduce = _bind;
                  const _count = _Reduce._0;
                  const _symbol = _Reduce._1;
                  count = _count;
                  symbol$2 = _symbol;
                  break _L$3;
                }
                case 3: {
                  const _ReduceNoLookahead = _bind;
                  const _count$2 = _ReduceNoLookahead._0;
                  const _symbol$2 = _ReduceNoLookahead._1;
                  count = _count$2;
                  symbol$2 = _symbol$2;
                  break _L$3;
                }
                default: {
                  break _L$2;
                }
              }
            }
            moonbitlang$core$array$$Array$push$62$(expected, kind);
            break;
          }
          let stack$4;
          let count$2;
          let symbol$3;
          _L$4: {
            stack$4 = stack$3;
            count$2 = count;
            symbol$3 = symbol$2;
            break _L$4;
          }
          let _tmp$3 = stack$4;
          let _tmp$4 = count$2;
          let _tmp$5 = symbol$3;
          _L$5: while (true) {
            const stack$5 = _tmp$3;
            const count$3 = _tmp$4;
            const symbol$4 = _tmp$5;
            const stack$6 = moonbitlang$core$list$$List$drop$43$(stack$5, count$3);
            if (stack$6.$tag === 1) {
              const _More$2 = stack$6;
              const _state$2 = _More$2._0;
              let count$4;
              let symbol$5;
              _L$6: {
                const _bind = _state$2(symbol$4);
                switch (_bind.$tag) {
                  case 1: {
                    const _Shift = _bind;
                    const _state$3 = _Shift._0;
                    _tmp$2 = new $64$moonbitlang$47$core$47$list$46$List$More$17$(_state$3, stack$6);
                    continue _L$2;
                  }
                  case 2: {
                    const _Reduce = _bind;
                    const _count = _Reduce._0;
                    const _symbol = _Reduce._1;
                    count$4 = _count;
                    symbol$5 = _symbol;
                    break _L$6;
                  }
                  case 3: {
                    const _ReduceNoLookahead = _bind;
                    const _count$2 = _ReduceNoLookahead._0;
                    const _symbol$2 = _ReduceNoLookahead._1;
                    count$4 = _count$2;
                    symbol$5 = _symbol$2;
                    break _L$6;
                  }
                  default: {
                    $panic();
                    break _L$2;
                  }
                }
              }
              _tmp$3 = stack$6;
              _tmp$4 = count$4;
              _tmp$5 = symbol$5;
              continue;
            } else {
              $panic();
              break _L$2;
            }
          }
        }
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (token === undefined) {
    return new Result$Err$42$(new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseError$46$UnexpectedEndOfInput(loc._1, expected));
  } else {
    const _Some = token;
    const _token = _Some;
    return new Result$Err$42$(new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseError$46$UnexpectedToken(_token, loc, expected));
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$yy_parse$51$(tokens, start, return_, initial_pos) {
  let cursor = 0;
  const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$17$;
  let state_stack = new $64$moonbitlang$47$core$47$list$46$List$More$17$(start, _p);
  const data_stack = [];
  const _p$2 = moonbitlang$core$array$$Array$at$77$(tokens, 0)._1;
  let last_pos;
  if (initial_pos === undefined) {
    last_pos = _p$2;
  } else {
    const _p$3 = initial_pos;
    last_pos = _p$3;
  }
  let state = start;
  let lookahead = undefined;
  let last_shifted_state_stack = state_stack;
  while (true) {
    let decision;
    const _func = state;
    const _bind = _func(15);
    switch (_bind.$tag) {
      case 3: {
        decision = _bind;
        break;
      }
      case 0: {
        decision = _bind;
        break;
      }
      default: {
        const _bind$2 = lookahead;
        if (_bind$2 === undefined) {
          if (cursor < tokens.length) {
            const _bind$3 = moonbitlang$core$array$$Array$at$77$(tokens, cursor);
            const _token = _bind$3._0;
            const _start_pos = _bind$3._1;
            const _end_pos = _bind$3._2;
            cursor = cursor + 1 | 0;
            const _bind$4 = moonbitlang$yacc$lib$parser$type_expr_parser$$yy_input(_token, _start_pos, _end_pos);
            const _symbol = _bind$4._0;
            const _data = _bind$4._1;
            lookahead = { _0: _symbol, _1: { _0: _data, _1: _start_pos, _2: _end_pos }, _2: _token };
            const _func$2 = state;
            decision = _func$2(_symbol);
          } else {
            lookahead = { _0: 15, _1: { _0: Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$YYObj_Void$46$YYObj_Void, _1: last_pos, _2: last_pos }, _2: undefined };
            const _func$2 = state;
            decision = _func$2(15);
          }
        } else {
          const _Some = _bind$2;
          const _la = _Some;
          const _func$2 = state;
          decision = _func$2(_la._0);
        }
      }
    }
    let action;
    let count;
    let symbol;
    _L: {
      _L$2: {
        switch (decision.$tag) {
          case 0: {
            return new Result$Ok$43$(return_(moonbitlang$core$array$$Array$unsafe_pop$21$(data_stack)._0));
          }
          case 1: {
            const _Shift = decision;
            const _next_state = _Shift._0;
            const _bind$3 = lookahead;
            if (_bind$3 === undefined) {
              $panic();
            } else {
              const _Some = _bind$3;
              const _la = _Some;
              moonbitlang$core$array$$Array$push$21$(data_stack, _la._1);
              const _p$3 = state_stack;
              state_stack = new $64$moonbitlang$47$core$47$list$46$List$More$17$(_next_state, _p$3);
              last_shifted_state_stack = state_stack;
              state = _next_state;
              last_pos = _la._1._2;
              lookahead = undefined;
            }
            break;
          }
          case 2: {
            const _Reduce = decision;
            const _count = _Reduce._0;
            const _symbol = _Reduce._1;
            const _action = _Reduce._2;
            action = _action;
            count = _count;
            symbol = _symbol;
            break _L$2;
          }
          case 3: {
            const _ReduceNoLookahead = decision;
            const _count$2 = _ReduceNoLookahead._0;
            const _symbol$2 = _ReduceNoLookahead._1;
            const _action$2 = _ReduceNoLookahead._2;
            action = _action$2;
            count = _count$2;
            symbol = _symbol$2;
            break _L$2;
          }
          default: {
            const _p$3 = lookahead;
            let _bind$4;
            if (_p$3 === undefined) {
              _bind$4 = $panic();
            } else {
              const _p$4 = _p$3;
              _bind$4 = _p$4;
            }
            const _x = _bind$4._1;
            const _start_pos = _x._1;
            const _end_pos = _x._2;
            const _token = _bind$4._2;
            const _bind$5 = moonbitlang$yacc$lib$parser$type_expr_parser$$error(last_shifted_state_stack, _token, { _0: _start_pos, _1: _end_pos });
            if (_bind$5.$tag === 1) {
              const _ok = _bind$5;
              _ok._0;
            } else {
              return _bind$5;
            }
          }
        }
        break _L;
      }
      let _tmp = count;
      let _tmp$2 = symbol;
      let _tmp$3 = action;
      _L$3: while (true) {
        const args = moonbitlang$core$array$$Array$sub$46$inner$21$(data_stack, data_stack.length - count | 0, undefined);
        const data = action(last_pos, args);
        let start_pos;
        let end_pos;
        _L$4: {
          if ((args.end - args.start | 0) === 0) {
            const _tmp$4 = last_pos;
            const _tmp$5 = last_pos;
            start_pos = _tmp$4;
            end_pos = _tmp$5;
            break _L$4;
          } else {
            const _tmp$4 = moonbitlang$core$array$$ArrayView$at$21$(args, 0)._1;
            const _tmp$5 = moonbitlang$core$array$$ArrayView$at$21$(args, (args.end - args.start | 0) - 1 | 0)._2;
            start_pos = _tmp$4;
            end_pos = _tmp$5;
            break _L$4;
          }
        }
        let _tmp$4 = 0;
        while (true) {
          const i = _tmp$4;
          if (i < count) {
            moonbitlang$core$array$$Array$unsafe_pop$21$(data_stack);
            state_stack = moonbitlang$core$list$$List$unsafe_tail$43$(state_stack);
            _tmp$4 = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        state = moonbitlang$core$list$$List$unsafe_head$43$(state_stack);
        moonbitlang$core$array$$Array$push$21$(data_stack, { _0: data, _1: start_pos, _2: end_pos });
        let action$2;
        let count$2;
        let symbol$2;
        _L$5: {
          const _func$2 = state;
          const _bind$3 = _func$2(symbol);
          switch (_bind$3.$tag) {
            case 0: {
              return new Result$Ok$43$(return_(moonbitlang$core$array$$Array$unsafe_pop$21$(data_stack)._0));
            }
            case 1: {
              const _Shift = _bind$3;
              const _next_state = _Shift._0;
              const _p$3 = state_stack;
              state_stack = new $64$moonbitlang$47$core$47$list$46$List$More$17$(_next_state, _p$3);
              state = _next_state;
              break _L$3;
            }
            case 2: {
              const _Reduce = _bind$3;
              const _count = _Reduce._0;
              const _symbol = _Reduce._1;
              const _action = _Reduce._2;
              action$2 = _action;
              count$2 = _count;
              symbol$2 = _symbol;
              break _L$5;
            }
            case 3: {
              const _ReduceNoLookahead = _bind$3;
              const _count$2 = _ReduceNoLookahead._0;
              const _symbol$2 = _ReduceNoLookahead._1;
              const _action$2 = _ReduceNoLookahead._2;
              action$2 = _action$2;
              count$2 = _count$2;
              symbol$2 = _symbol$2;
              break _L$5;
            }
            default: {
              $panic();
              break _L$3;
            }
          }
        }
        _tmp = count$2;
        _tmp$2 = symbol$2;
        _tmp$3 = action$2;
        continue;
      }
    }
    continue;
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$parse_type_expr(tokens, initial_pos) {
  return moonbitlang$yacc$lib$parser$type_expr_parser$$yy_parse$51$(tokens, moonbitlang$yacc$lib$parser$type_expr_parser$$yy_state_0, (it) => {
    if (it.$tag === 44) {
      const _YYObj__ast_TypeExpr = it;
      return _YYObj__ast_TypeExpr._0;
    } else {
      return $panic();
    }
  }, initial_pos);
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$token(lexbuf) {
  _L: while (true) {
    let _match_pattern = moonbitlang$core$int$$max_value;
    let _match_start = lexbuf.pos;
    let _match_end = -1;
    let _capture_0_start = -1;
    let _capture_0_end = -1;
    let _capture_1_start = -1;
    let _capture_1_end = -1;
    let _capture_2_start = -1;
    let _capture_2_end = -1;
    let _tag_0 = -1;
    let _tag_1 = -1;
    let _tmp = 0;
    _L$2: while (true) {
      const _param = _tmp;
      switch (_param) {
        case 0: {
          const _bind = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind === -1) {
            _tmp = 1;
          } else {
            if (_bind >= 0 && _bind <= 8) {
              _tmp = 2;
            } else {
              if (_bind >= 9 && _bind <= 10) {
                _tmp = 3;
              } else {
                if (_bind >= 11 && _bind <= 31) {
                  _tmp = 2;
                } else {
                  if (_bind === 32) {
                    _tmp = 3;
                  } else {
                    if (_bind >= 33 && _bind <= 39) {
                      _tmp = 2;
                    } else {
                      if (_bind === 40) {
                        _tmp = 4;
                      } else {
                        if (_bind === 41) {
                          _tmp = 5;
                        } else {
                          if (_bind >= 42 && _bind <= 43) {
                            _tmp = 2;
                          } else {
                            if (_bind === 44) {
                              _tmp = 6;
                            } else {
                              if (_bind === 45) {
                                _tmp = 7;
                              } else {
                                if (_bind >= 46 && _bind <= 62) {
                                  _tmp = 2;
                                } else {
                                  if (_bind === 63) {
                                    _tmp = 8;
                                  } else {
                                    if (_bind === 64) {
                                      _tmp = 9;
                                    } else {
                                      if (_bind >= 65 && _bind <= 90) {
                                        _tmp = 10;
                                      } else {
                                        if (_bind === 91) {
                                          _tmp = 11;
                                        } else {
                                          if (_bind === 92) {
                                            _tmp = 2;
                                          } else {
                                            if (_bind === 93) {
                                              _tmp = 12;
                                            } else {
                                              if (_bind === 94) {
                                                _tmp = 2;
                                              } else {
                                                if (_bind === 95) {
                                                  _tmp = 10;
                                                } else {
                                                  if (_bind === 96) {
                                                    _tmp = 2;
                                                  } else {
                                                    if (_bind >= 97 && _bind <= 122) {
                                                      _tmp = 10;
                                                    } else {
                                                      if (_bind >= 123 && _bind <= 1114111) {
                                                        _tmp = 2;
                                                      } else {
                                                        break _L$2;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 1: {
          _match_pattern = 11;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          break _L$2;
        }
        case 2: {
          _match_pattern = 10;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 3: {
          _match_pattern = 0;
          _match_end = lexbuf.pos;
          const _bind$2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$2 >= 9 && _bind$2 <= 10) {
            _tmp = 3;
          } else {
            if (_bind$2 === 32) {
              _tmp = 3;
            } else {
              break _L$2;
            }
          }
          continue _L$2;
        }
        case 4: {
          _match_pattern = 6;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 5: {
          _match_pattern = 7;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 6: {
          _match_pattern = 8;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 7: {
          _match_pattern = 10;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$3 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$3 === 62) {
            _tmp = 13;
          } else {
            break _L$2;
          }
          continue _L$2;
        }
        case 8: {
          _match_pattern = 9;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 9: {
          _match_pattern = 10;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          const _bind$4 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$4 >= 65 && _bind$4 <= 90) {
            _tmp = 14;
          } else {
            if (_bind$4 === 95) {
              _tmp = 14;
            } else {
              if (_bind$4 >= 97 && _bind$4 <= 122) {
                _tmp = 14;
              } else {
                break _L$2;
              }
            }
          }
          continue _L$2;
        }
        case 10: {
          _match_pattern = 2;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          const _bind$5 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$5 >= 48 && _bind$5 <= 57) {
            _tmp = 10;
          } else {
            if (_bind$5 >= 65 && _bind$5 <= 90) {
              _tmp = 10;
            } else {
              if (_bind$5 === 95) {
                _tmp = 10;
              } else {
                if (_bind$5 >= 97 && _bind$5 <= 122) {
                  _tmp = 10;
                } else {
                  break _L$2;
                }
              }
            }
          }
          continue _L$2;
        }
        case 11: {
          _match_pattern = 4;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 12: {
          _match_pattern = 5;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 1 | 0;
          break _L$2;
        }
        case 13: {
          _match_pattern = 3;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_start + 2 | 0;
          break _L$2;
        }
        case 14: {
          _tag_0 = lexbuf.pos;
          const _bind$6 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$6 === 46) {
            _tmp = 15;
          } else {
            if (_bind$6 === 47) {
              _tmp = 17;
            } else {
              if (_bind$6 >= 48 && _bind$6 <= 57) {
                _tmp = 14;
              } else {
                if (_bind$6 >= 65 && _bind$6 <= 90) {
                  _tmp = 14;
                } else {
                  if (_bind$6 === 95) {
                    _tmp = 14;
                  } else {
                    if (_bind$6 >= 97 && _bind$6 <= 122) {
                      _tmp = 14;
                    } else {
                      break _L$2;
                    }
                  }
                }
              }
            }
          }
          continue _L$2;
        }
        case 15: {
          _tag_1 = lexbuf.pos;
          const _bind$7 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$7 >= 65 && _bind$7 <= 90) {
            _tmp = 16;
          } else {
            if (_bind$7 === 95) {
              _tmp = 16;
            } else {
              if (_bind$7 >= 97 && _bind$7 <= 122) {
                _tmp = 16;
              } else {
                break _L$2;
              }
            }
          }
          continue _L$2;
        }
        case 16: {
          _match_pattern = 1;
          _match_end = lexbuf.pos;
          _capture_0_start = _match_start;
          _capture_0_end = _match_end;
          _capture_1_start = _tag_1;
          _capture_1_end = _match_end;
          _capture_2_start = _match_start + 1 | 0;
          _capture_2_end = _tag_0;
          const _bind$8 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$8 >= 48 && _bind$8 <= 57) {
            _tmp = 16;
          } else {
            if (_bind$8 >= 65 && _bind$8 <= 90) {
              _tmp = 16;
            } else {
              if (_bind$8 === 95) {
                _tmp = 16;
              } else {
                if (_bind$8 >= 97 && _bind$8 <= 122) {
                  _tmp = 16;
                } else {
                  break _L$2;
                }
              }
            }
          }
          continue _L$2;
        }
        case 17: {
          const _bind$9 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$next_as_int$247$(lexbuf);
          if (_bind$9 >= 65 && _bind$9 <= 90) {
            _tmp = 14;
          } else {
            if (_bind$9 === 95) {
              _tmp = 14;
            } else {
              if (_bind$9 >= 97 && _bind$9 <= 122) {
                _tmp = 14;
              } else {
                break _L$2;
              }
            }
          }
          continue _L$2;
        }
        default: {
          $panic();
          break _L$2;
        }
      }
    }
    if (_match_pattern <= 11) {
      moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$reset$247$(lexbuf, _match_end);
      const _bind = _match_pattern;
      switch (_bind) {
        case 0: {
          continue _L;
        }
        case 1: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          const id = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_1_start, _capture_1_end);
          const pkg = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_2_start, _capture_2_end);
          return new Result$Ok$44$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$PKG_AND_IDENT({ _0: pkg, _1: id }), _1: _capture_0_start, _2: _capture_0_end });
        }
        case 2: {
          const t = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$44$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$IDENT(t), _1: _capture_0_start, _2: _capture_0_end });
        }
        case 3: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$44$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$ARROW, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 4: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$44$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$LBRACKET, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 5: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$44$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$RBRACKET, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 6: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$44$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$LPAREN, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 7: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$44$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$RPAREN, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 8: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$44$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$COMMA, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 9: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$44$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$QUESTION, _1: _capture_0_start, _2: _capture_0_end });
        }
        case 10: {
          const t$2 = moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_char$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Err$44$(new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$LexError$46$Unrecognized(t$2, _capture_0_start));
        }
        case 11: {
          moonbitlang$ulex$45$runtime$lexbuf$$IStringLexbuf$get_string$247$(lexbuf, _capture_0_start, _capture_0_end);
          return new Result$Ok$44$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$Token$EOF, _1: _capture_0_start, _2: _capture_0_end });
        }
        default: {
          return new Result$Ok$44$($panic());
        }
      }
    } else {
      return new Result$Ok$44$($panic());
    }
  }
}
function moonbitlang$yacc$lib$parser$type_expr_parser$$parse(str) {
  const lexbuf = moonbitlang$ulex$45$runtime$lexbuf$$StringLexbuf$from_string(str);
  const tokens = [];
  while (true) {
    let triple;
    let _try_err;
    _L: {
      _L$2: {
        const _bind = moonbitlang$yacc$lib$parser$type_expr_parser$$token(lexbuf);
        if (_bind.$tag === 1) {
          const _ok = _bind;
          triple = _ok._0;
        } else {
          const _err = _bind;
          const _tmp = _err._0;
          _try_err = _tmp;
          break _L$2;
        }
        break _L;
      }
      return new Result$Err$45$(new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseOrLexError$46$LexError(_try_err));
    }
    moonbitlang$core$array$$Array$push$77$(tokens, triple);
    const _bind = triple._0;
    if (_bind.$tag === 0) {
      break;
    }
    continue;
  }
  let _try_err;
  _L: {
    const _bind = moonbitlang$yacc$lib$parser$type_expr_parser$$parse_type_expr(tokens, undefined);
    let _tmp;
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _tmp = _ok._0;
    } else {
      const _err = _bind;
      const _tmp$2 = _err._0;
      _try_err = _tmp$2;
      break _L;
    }
    return new Result$Ok$45$(_tmp);
  }
  return new Result$Err$45$(new Error$moonbitlang$47$yacc$47$lib$47$parser$47$type_expr_parser$46$ParseOrLexError$46$ParseError(_try_err));
}
function moonbitlang$yacc$lib$util$hashmap2$$new$249$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$128$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$250$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$251$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$252$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$129$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$253$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$254$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$T$iter$251$(self) {
  const current_entry = { val: self.entry };
  const _p = () => {
    const _bind = current_entry.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      current_entry.val = _entry.prev;
      return { _0: _entry.key, _1: _entry.value };
    }
  };
  return _p;
}
function moonbitlang$yacc$lib$util$hashmap2$$T$iter$250$(self) {
  const current_entry = { val: self.entry };
  const _p = () => {
    const _bind = current_entry.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      current_entry.val = _entry.prev;
      return { _0: _entry.key, _1: _entry.value };
    }
  };
  return _p;
}
function moonbitlang$yacc$lib$util$hashmap2$$T$iter$252$(self) {
  const current_entry = { val: self.entry };
  const _p = () => {
    const _bind = current_entry.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      current_entry.val = _entry.prev;
      return { _0: _entry.key, _1: _entry.value };
    }
  };
  return _p;
}
function moonbitlang$yacc$lib$util$hashmap2$$T$iterator2$128$(self) {
  const current_entry = { val: self.entry };
  return moonbitlang$core$builtin$$Iter2$new$128$(() => {
    const _bind = current_entry.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      current_entry.val = _entry.prev;
      return { _0: _entry.key, _1: _entry.value };
    }
  });
}
function moonbitlang$yacc$lib$util$hashmap2$$T$iterator2$129$(self) {
  const current_entry = { val: self.entry };
  return moonbitlang$core$builtin$$Iter2$new$129$(() => {
    const _bind = current_entry.val;
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      current_entry.val = _entry.prev;
      return { _0: _entry.key, _1: _entry.value };
    }
  });
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$250$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    $bound_check(bucket, index);
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      let _tmp$2;
      if (_entry.hash === hash) {
        const _p = _entry.key;
        _tmp$2 = _p === key;
      } else {
        _tmp$2 = false;
      }
      if (_tmp$2) {
        return _entry;
      }
      if ((index - ideal_index | 0) > _entry.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$249$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    $bound_check(bucket, index);
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && moonbitlang$core$builtin$$Eq$equal$255$(_entry.key, key)) {
        return _entry;
      }
      if ((index - ideal_index | 0) > _entry.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$252$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    $bound_check(bucket, index);
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && moonbitlang$core$builtin$$Eq$equal$54$(_entry.key, key)) {
        return _entry;
      }
      if ((index - ideal_index | 0) > _entry.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$251$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    $bound_check(bucket, index);
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && moonbitlang$core$builtin$$Eq$equal$54$(_entry.key, key)) {
        return _entry;
      }
      if ((index - ideal_index | 0) > _entry.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$128$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    $bound_check(bucket, index);
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && moonbitlang$core$builtin$$Eq$equal$80$(_entry.key, key)) {
        return _entry;
      }
      if ((index - ideal_index | 0) > _entry.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$253$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    $bound_check(bucket, index);
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      if (_entry.hash === hash && _entry.key === key) {
        return _entry;
      }
      if ((index - ideal_index | 0) > _entry.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$129$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    $bound_check(bucket, index);
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      let _tmp$2;
      if (_entry.hash === hash) {
        const _p = _entry.key;
        _tmp$2 = _p === key;
      } else {
        _tmp$2 = false;
      }
      if (_tmp$2) {
        return _entry;
      }
      if ((index - ideal_index | 0) > _entry.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$254$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    $bound_check(bucket, index);
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _entry = _Some;
      let _tmp$2;
      if (_entry.hash === hash) {
        const _p = _entry.key;
        _tmp$2 = _p === key;
      } else {
        _tmp$2 = false;
      }
      if (_tmp$2) {
        return _entry;
      }
      if ((index - ideal_index | 0) > _entry.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get$250$(self, key) {
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$250$(self, key, moonbitlang$core$builtin$$Hash$hash$112$(key));
  if (_bind === undefined) {
    return undefined;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    return _entry.value;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get$253$(self, key) {
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$253$(self, key, moonbitlang$core$builtin$$Hash$hash$108$(key));
  if (_bind === undefined) {
    return Option$None$46$;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    return new Option$Some$46$(_entry.value);
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$contains$129$(self, key) {
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$129$(self, key, moonbitlang$core$builtin$$Hash$hash$82$(key));
  return !(_bind === undefined);
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$250$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    $bound_check(bucket, index$2);
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      $bound_check(bucket, index$2);
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _old_entry = _Some;
      let entry$3;
      if (entry$2.psl > _old_entry.psl) {
        $bound_check(bucket, index$2);
        bucket[index$2] = entry$2;
        entry$3 = _old_entry;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      _tmp = index$2 + 1 & bitmask;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$249$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    $bound_check(bucket, index$2);
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      $bound_check(bucket, index$2);
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _old_entry = _Some;
      let entry$3;
      if (entry$2.psl > _old_entry.psl) {
        $bound_check(bucket, index$2);
        bucket[index$2] = entry$2;
        entry$3 = _old_entry;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      _tmp = index$2 + 1 & bitmask;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$252$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    $bound_check(bucket, index$2);
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      $bound_check(bucket, index$2);
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _old_entry = _Some;
      let entry$3;
      if (entry$2.psl > _old_entry.psl) {
        $bound_check(bucket, index$2);
        bucket[index$2] = entry$2;
        entry$3 = _old_entry;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      _tmp = index$2 + 1 & bitmask;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$251$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    $bound_check(bucket, index$2);
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      $bound_check(bucket, index$2);
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _old_entry = _Some;
      let entry$3;
      if (entry$2.psl > _old_entry.psl) {
        $bound_check(bucket, index$2);
        bucket[index$2] = entry$2;
        entry$3 = _old_entry;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      _tmp = index$2 + 1 & bitmask;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$128$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    $bound_check(bucket, index$2);
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      $bound_check(bucket, index$2);
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _old_entry = _Some;
      let entry$3;
      if (entry$2.psl > _old_entry.psl) {
        $bound_check(bucket, index$2);
        bucket[index$2] = entry$2;
        entry$3 = _old_entry;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      _tmp = index$2 + 1 & bitmask;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$253$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    $bound_check(bucket, index$2);
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      $bound_check(bucket, index$2);
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _old_entry = _Some;
      let entry$3;
      if (entry$2.psl > _old_entry.psl) {
        $bound_check(bucket, index$2);
        bucket[index$2] = entry$2;
        entry$3 = _old_entry;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      _tmp = index$2 + 1 & bitmask;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$129$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    $bound_check(bucket, index$2);
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      $bound_check(bucket, index$2);
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _old_entry = _Some;
      let entry$3;
      if (entry$2.psl > _old_entry.psl) {
        $bound_check(bucket, index$2);
        bucket[index$2] = entry$2;
        entry$3 = _old_entry;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      _tmp = index$2 + 1 & bitmask;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$254$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    $bound_check(bucket, index$2);
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      $bound_check(bucket, index$2);
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _old_entry = _Some;
      let entry$3;
      if (entry$2.psl > _old_entry.psl) {
        $bound_check(bucket, index$2);
        bucket[index$2] = entry$2;
        entry$3 = _old_entry;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      _tmp = index$2 + 1 & bitmask;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$250$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _entry = _Some;
      _entry.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$250$(self, _entry.hash & bitmask, bitmask, _entry);
      _tmp = _entry.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$249$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _entry = _Some;
      _entry.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$249$(self, _entry.hash & bitmask, bitmask, _entry);
      _tmp = _entry.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$252$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _entry = _Some;
      _entry.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$252$(self, _entry.hash & bitmask, bitmask, _entry);
      _tmp = _entry.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$251$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _entry = _Some;
      _entry.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$251$(self, _entry.hash & bitmask, bitmask, _entry);
      _tmp = _entry.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$128$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _entry = _Some;
      _entry.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$128$(self, _entry.hash & bitmask, bitmask, _entry);
      _tmp = _entry.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$253$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _entry = _Some;
      _entry.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$253$(self, _entry.hash & bitmask, bitmask, _entry);
      _tmp = _entry.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$129$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _entry = _Some;
      _entry.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$129$(self, _entry.hash & bitmask, bitmask, _entry);
      _tmp = _entry.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$254$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _entry = _Some;
      _entry.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$254$(self, _entry.hash & bitmask, bitmask, _entry);
      _tmp = _entry.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$249$(self, key, init) {
  const hash = moonbitlang$core$builtin$$Hash$hash$255$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$249$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$249$(self);
    }
    const value = init(key);
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$249$(self, hash & self.bitmask, self.bitmask, entry);
    return value;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    return _entry.value;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$252$(self, key, init) {
  const hash = moonbitlang$core$builtin$$Hash$hash$104$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$252$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$252$(self);
    }
    const value = init(key);
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$252$(self, hash & self.bitmask, self.bitmask, entry);
    return value;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    return _entry.value;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$253$(self, key, init) {
  const hash = moonbitlang$core$builtin$$Hash$hash$108$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$253$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$253$(self);
    }
    const value = init(key);
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$253$(self, hash & self.bitmask, self.bitmask, entry);
    return value;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    return _entry.value;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$254$(self, key, init) {
  const hash = moonbitlang$core$builtin$$Hash$hash$82$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$254$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$254$(self);
    }
    const value = init(key);
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$254$(self, hash & self.bitmask, self.bitmask, entry);
    return value;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    return _entry.value;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$set$250$(self, key, value) {
  const hash = moonbitlang$core$builtin$$Hash$hash$112$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$250$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$250$(self);
    }
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$250$(self, hash & self.bitmask, self.bitmask, entry);
    return;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    _entry.value = value;
    return;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$set$251$(self, key, value) {
  const hash = moonbitlang$core$builtin$$Hash$hash$104$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$251$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$251$(self);
    }
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$251$(self, hash & self.bitmask, self.bitmask, entry);
    return;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    _entry.value = value;
    return;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$set$128$(self, key, value) {
  const hash = moonbitlang$core$builtin$$Hash$hash$113$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$128$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$128$(self);
    }
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$128$(self, hash & self.bitmask, self.bitmask, entry);
    return;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    _entry.value = value;
    return;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$set$129$(self, key, value) {
  const hash = moonbitlang$core$builtin$$Hash$hash$82$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$129$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$129$(self);
    }
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$129$(self, hash & self.bitmask, self.bitmask, entry);
    return;
  } else {
    const _Some = _bind;
    const _entry = _Some;
    _entry.value = value;
    return;
  }
}
function moonbitlang$yacc$lib$util$array_multimap$$new$256$() {
  return moonbitlang$yacc$lib$util$hashmap2$$new$253$(16);
}
function moonbitlang$yacc$lib$util$array_multimap$$T$add$256$(self, key, value) {
  const arr = moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$253$(self, key, (_discard_) => []);
  if (!moonbitlang$core$array$$Array$contains$13$(arr, value)) {
    moonbitlang$core$array$$Array$push$13$(arr, value);
    return;
  } else {
    return;
  }
}
function moonbitlang$yacc$lib$util$array_multimap$$T$get$256$(self, key) {
  return moonbitlang$core$option$$Option$unwrap_or$209$(moonbitlang$yacc$lib$util$hashmap2$$T$get$253$(self, key), []);
}
function moonbitlang$core$builtin$$Hash$hash_combine$81$(_x_3, _x_4) {
  moonbitlang$core$builtin$$Hash$hash_combine$17$(_x_3, _x_4);
}
function moonbitlang$yacc$lib$util$stamp$$new() {
  const stamp = moonbitlang$yacc$lib$util$stamp$$next_stamp.val;
  moonbitlang$yacc$lib$util$stamp$$next_stamp.val = moonbitlang$yacc$lib$util$stamp$$next_stamp.val + 1 | 0;
  return stamp;
}
function moonbitlang$core$builtin$$Eq$equal$75$(_x_316, _x_317) {
  let _tmp = _x_316;
  let _tmp$2 = _x_317;
  _L: while (true) {
    const _x_316$2 = _tmp;
    const _x_317$2 = _tmp$2;
    switch (_x_316$2.$tag) {
      case 0: {
        const _Constr = _x_316$2;
        const _$42$x0_318 = _Constr._0;
        const _$42$x1_319 = _Constr._1;
        const _$42$x2_320 = _Constr._2;
        if (_x_317$2.$tag === 0) {
          const _Constr$2 = _x_317$2;
          const _$42$y0_321 = _Constr$2._0;
          const _$42$y1_322 = _Constr$2._1;
          const _$42$y2_323 = _Constr$2._2;
          return moonbitlang$core$builtin$$Eq$equal$48$(_$42$x0_318, _$42$y0_321) && (_$42$x1_319 === _$42$y1_322 && moonbitlang$core$builtin$$Eq$equal$236$(_$42$x2_320, _$42$y2_323));
        } else {
          return false;
        }
      }
      case 1: {
        const _Param = _x_316$2;
        const _$42$x0_324 = _Param._0;
        if (_x_317$2.$tag === 1) {
          const _Param$2 = _x_317$2;
          const _$42$y0_325 = _Param$2._0;
          return _$42$x0_324 === _$42$y0_325;
        } else {
          return false;
        }
      }
      case 2: {
        const _Option = _x_316$2;
        const _$42$x0_326 = _Option._0;
        if (_x_317$2.$tag === 2) {
          const _Option$2 = _x_317$2;
          const _$42$y0_327 = _Option$2._0;
          _tmp = _$42$x0_326;
          _tmp$2 = _$42$y0_327;
          continue _L;
        } else {
          return false;
        }
      }
      case 3: {
        const _Tuple = _x_316$2;
        const _$42$x0_328 = _Tuple._0;
        if (_x_317$2.$tag === 3) {
          const _Tuple$2 = _x_317$2;
          const _$42$y0_329 = _Tuple$2._0;
          return moonbitlang$core$builtin$$Eq$equal$236$(_$42$x0_328, _$42$y0_329);
        } else {
          return false;
        }
      }
      default: {
        const _Arrow = _x_316$2;
        const _$42$x0_330 = _Arrow._0;
        const _$42$x1_331 = _Arrow._1;
        if (_x_317$2.$tag === 4) {
          const _Arrow$2 = _x_317$2;
          const _$42$y0_332 = _Arrow$2._0;
          const _$42$y1_333 = _Arrow$2._1;
          if (moonbitlang$core$builtin$$Eq$equal$236$(_$42$x0_330, _$42$y0_332)) {
            _tmp = _$42$x1_331;
            _tmp$2 = _$42$y1_333;
            continue _L;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$75$(_x_274, _x_275) {
  let _tmp = _x_274;
  let _tmp$2 = _x_275;
  _L: while (true) {
    const _x_274$2 = _tmp;
    const _x_275$2 = _tmp$2;
    switch (_x_274$2.$tag) {
      case 0: {
        const _Constr = _x_274$2;
        const _$42$x0_276 = _Constr._0;
        const _$42$x1_277 = _Constr._1;
        const _$42$x2_278 = _Constr._2;
        if (_x_275$2.$tag === 0) {
          const _Constr$2 = _x_275$2;
          const _$42$y0_279 = _Constr$2._0;
          const _$42$y1_280 = _Constr$2._1;
          const _$42$y2_281 = _Constr$2._2;
          const _bind = moonbitlang$core$builtin$$Compare$compare$48$(_$42$x0_276, _$42$y0_279);
          if (_bind === 0) {
            const _bind$2 = moonbitlang$core$builtin$$Compare$compare$13$(_$42$x1_277, _$42$y1_280);
            if (_bind$2 === 0) {
              return moonbitlang$core$builtin$$Compare$compare$236$(_$42$x2_278, _$42$y2_281);
            } else {
              return _bind$2;
            }
          } else {
            return _bind;
          }
        } else {
          return -1;
        }
      }
      case 1: {
        const _Param = _x_274$2;
        const _$42$x0_284 = _Param._0;
        switch (_x_275$2.$tag) {
          case 0: {
            return 1;
          }
          case 1: {
            const _Param$2 = _x_275$2;
            const _$42$y0_285 = _Param$2._0;
            return moonbitlang$core$builtin$$Compare$compare$13$(_$42$x0_284, _$42$y0_285);
          }
          default: {
            return -1;
          }
        }
      }
      case 2: {
        const _Option = _x_274$2;
        const _$42$x0_286 = _Option._0;
        switch (_x_275$2.$tag) {
          case 0: {
            return 1;
          }
          case 1: {
            return 1;
          }
          case 2: {
            const _Option$2 = _x_275$2;
            const _$42$y0_287 = _Option$2._0;
            _tmp = _$42$x0_286;
            _tmp$2 = _$42$y0_287;
            continue _L;
          }
          default: {
            return -1;
          }
        }
      }
      case 3: {
        const _Tuple = _x_274$2;
        const _$42$x0_288 = _Tuple._0;
        switch (_x_275$2.$tag) {
          case 0: {
            return 1;
          }
          case 1: {
            return 1;
          }
          case 2: {
            return 1;
          }
          case 3: {
            const _Tuple$2 = _x_275$2;
            const _$42$y0_289 = _Tuple$2._0;
            return moonbitlang$core$builtin$$Compare$compare$236$(_$42$x0_288, _$42$y0_289);
          }
          default: {
            return -1;
          }
        }
      }
      default: {
        const _Arrow = _x_274$2;
        const _$42$x0_290 = _Arrow._0;
        const _$42$x1_291 = _Arrow._1;
        switch (_x_275$2.$tag) {
          case 0: {
            return 1;
          }
          case 1: {
            return 1;
          }
          case 2: {
            return 1;
          }
          case 3: {
            return 1;
          }
          default: {
            const _Arrow$2 = _x_275$2;
            const _$42$y0_292 = _Arrow$2._0;
            const _$42$y1_293 = _Arrow$2._1;
            const _bind = moonbitlang$core$builtin$$Compare$compare$236$(_$42$x0_290, _$42$y0_292);
            if (_bind === 0) {
              _tmp = _$42$x1_291;
              _tmp$2 = _$42$y1_293;
              continue _L;
            } else {
              return _bind;
            }
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$elab$$offset_to_line_column(content, offset) {
  let line = 1;
  let column = 1;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < offset) {
      $bound_check(content, i);
      const _p = content.charCodeAt(i);
      const _p$2 = 10;
      if (_p === _p$2) {
        line = line + 1 | 0;
        column = 1;
      } else {
        column = column + 1 | 0;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: line, _1: column };
}
function moonbitlang$yacc$lib$elab$$Item$type_(self) {
  const _bind = self.term;
  switch (_bind.$tag) {
    case 0: {
      const _Token = _bind;
      const _token = _Token._0;
      return _token.type_;
    }
    case 1: {
      const _Param = _bind;
      return _Param._1;
    }
    default: {
      const _RuleCall = _bind;
      return _RuleCall._2;
    }
  }
}
function moonbitlang$yacc$lib$elab$$elaborate_action$46$item_ident_to_index$124$56(name_to_index, ident) {
  if (ident.$tag === 0) {
    const _Dollar = ident;
    const _index = _Dollar._0;
    return _index - 1 | 0;
  } else {
    const _Name = ident;
    const _name = _Name._0;
    const _p = moonbitlang$core$builtin$$Map$get$221$(name_to_index, _name);
    if (_p === undefined) {
      return $panic();
    } else {
      const _p$2 = _p;
      return _p$2;
    }
  }
}
function moonbitlang$yacc$lib$elab$$elaborate_action$46$add_binding$124$62(_env, desc, loc) {
  const name_to_index = _env._3;
  const visited = _env._2;
  const bindings = _env._1;
  const items = _env._0;
  let _tmp = desc;
  _L: while (true) {
    const desc$2 = _tmp;
    if (!moonbitlang$core$sorted_set$$SortedSet$contains$244$(visited, desc$2)) {
      moonbitlang$core$sorted_set$$SortedSet$add$244$(visited, desc$2);
      switch (desc$2.$tag) {
        case 0: {
          const _Dollar = desc$2;
          const _index = _Dollar._0;
          const name = `_dollar${moonbitlang$core$builtin$$Show$to_string$111$(_index)}`;
          if ((_index - 1 | 0) < items.length) {
            return new Result$Ok$47$(moonbitlang$core$array$$Array$push$27$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$Data(_index - 1 | 0, moonbitlang$yacc$lib$elab$$Item$type_(moonbitlang$core$array$$Array$at$32$(items, _index - 1 | 0))), _1: name }));
          } else {
            return new Result$Err$47$(new Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$OutOfBoundsAccess(_index, loc));
          }
        }
        case 1: {
          return new Result$Ok$47$(moonbitlang$core$array$$Array$push$27$(bindings, { _0: $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$StartPos, _1: "_start_pos" }));
        }
        case 3: {
          const _bind = moonbitlang$yacc$lib$elab$$elaborate_action$46$add_binding$124$62(_env, $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$StartPos, loc);
          if (_bind.$tag === 1) {
            const _ok = _bind;
            _ok._0;
          } else {
            return _bind;
          }
          _tmp = $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$EndPos;
          continue _L;
        }
        case 2: {
          return new Result$Ok$47$(moonbitlang$core$array$$Array$push$27$(bindings, { _0: $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$EndPos, _1: "_end_pos" }));
        }
        case 4: {
          const _StartPosOf = desc$2;
          const _arg = _StartPosOf._0;
          const index = moonbitlang$yacc$lib$elab$$elaborate_action$46$item_ident_to_index$124$56(name_to_index, _arg);
          return new Result$Ok$47$(moonbitlang$core$array$$Array$push$27$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$StartPosOf(index), _1: `_start_pos_of_item${moonbitlang$core$builtin$$Show$to_string$111$(index)}` }));
        }
        case 5: {
          const _EndPosOf = desc$2;
          const _arg$2 = _EndPosOf._0;
          const index$2 = moonbitlang$yacc$lib$elab$$elaborate_action$46$item_ident_to_index$124$56(name_to_index, _arg$2);
          return new Result$Ok$47$(moonbitlang$core$array$$Array$push$27$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$EndPosOf(index$2), _1: `_end_pos_of_item${moonbitlang$core$builtin$$Show$to_string$111$(index$2)}` }));
        }
        case 6: {
          const _LocOf = desc$2;
          const _arg$3 = _LocOf._0;
          const _bind$2 = moonbitlang$yacc$lib$elab$$elaborate_action$46$add_binding$124$62(_env, new $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$StartPosOf(_arg$3), loc);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _ok._0;
          } else {
            return _bind$2;
          }
          _tmp = new $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$EndPosOf(_arg$3);
          continue _L;
        }
        case 7: {
          return new Result$Ok$47$(moonbitlang$core$array$$Array$push$27$(bindings, { _0: $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$SymbolStartPos, _1: "_symbol_start_pos" }));
        }
        default: {
          const _bind$3 = moonbitlang$yacc$lib$elab$$elaborate_action$46$add_binding$124$62(_env, $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$SymbolStartPos, loc);
          if (_bind$3.$tag === 1) {
            const _ok = _bind$3;
            _ok._0;
          } else {
            return _bind$3;
          }
          _tmp = $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$EndPos;
          continue _L;
        }
      }
    } else {
      return new Result$Ok$47$(undefined);
    }
  }
}
function moonbitlang$yacc$lib$elab$$elaborate_action(items, ast_action, parser_spec_str, filename, rule_index, clause_index, ast_clause, nonterminal_name, type_, json_cst) {
  const arity = items.length;
  const _bind = [];
  const name_to_index = moonbitlang$core$builtin$$Map$from_array$221$({ buf: _bind, start: 0, end: 0 });
  const _len = items.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const item = items[_i];
      const _bind$2 = item.binder;
      if (_bind$2 === undefined) {
      } else {
        const _Some = _bind$2;
        const _name = _Some;
        moonbitlang$core$builtin$$Map$set$221$(name_to_index, _name, _i);
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const bindings = [];
  const visited = moonbitlang$core$sorted_set$$SortedSet$new$244$();
  const _env = { _0: items, _1: bindings, _2: visited, _3: name_to_index };
  const body = [];
  if (json_cst === 0) {
    const _len$2 = items.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len$2) {
        const item = items[_i];
        const _x = item.binder;
        if (_x === undefined) {
        } else {
          const _Some = _x;
          const _name = _Some;
          moonbitlang$core$array$$Array$push$27$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$Data(_i, moonbitlang$yacc$lib$elab$$Item$type_(item)), _1: _name });
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _bind$2 = ast_action.code;
    if (_bind$2 === undefined) {
      moonbitlang$core$array$$Array$push$65$(body, { _0: "()", _1: undefined });
    } else {
      const _Some = _bind$2;
      const _code = _Some;
      let last_index = 0;
      const _arr = _code.subst;
      const _len$3 = _arr.length;
      let _tmp$3 = 0;
      while (true) {
        const _i = _tmp$3;
        if (_i < _len$3) {
          const item = _arr[_i];
          if (item.start > last_index) {
            const len = item.start - last_index | 0;
            let _tmp$4;
            let _try_err;
            _L: {
              _L$2: {
                const _bind$3 = moonbitlang$core$string$$String$sub$46$inner(_code.code, last_index, item.start);
                let _tmp$5;
                if (_bind$3.$tag === 1) {
                  const _ok = _bind$3;
                  _tmp$5 = _ok._0;
                } else {
                  const _err = _bind$3;
                  const _tmp$6 = _err._0;
                  _try_err = _tmp$6;
                  break _L$2;
                }
                _tmp$4 = moonbitlang$core$builtin$$Show$to_string$14$(_tmp$5);
                break _L;
              }
              _tmp$4 = $panic();
            }
            moonbitlang$core$array$$Array$push$65$(body, { _0: _tmp$4, _1: { _0: _code.utf8_pos + last_index | 0, _1: len } });
          }
          const _bind$3 = moonbitlang$yacc$lib$elab$$elaborate_action$46$add_binding$124$62(_env, item.desc, { _0: _code.utf8_pos + item.start | 0, _1: _code.utf8_pos + item.end | 0 });
          if (_bind$3.$tag === 1) {
            const _ok = _bind$3;
            _ok._0;
          } else {
            return _bind$3;
          }
          const _bind$4 = item.desc;
          let _tmp$4;
          switch (_bind$4.$tag) {
            case 0: {
              const _Dollar = _bind$4;
              const _index = _Dollar._0;
              _tmp$4 = `_dollar${moonbitlang$core$builtin$$Show$to_string$111$(_index)}`;
              break;
            }
            case 1: {
              _tmp$4 = "_start_pos";
              break;
            }
            case 2: {
              _tmp$4 = "_end_pos";
              break;
            }
            case 3: {
              _tmp$4 = "(_start_pos, _end_pos)";
              break;
            }
            case 4: {
              const _StartPosOf = _bind$4;
              const _arg = _StartPosOf._0;
              _tmp$4 = `_start_pos_of_item${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$elab$$elaborate_action$46$item_ident_to_index$124$56(name_to_index, _arg))}`;
              break;
            }
            case 5: {
              const _EndPosOf = _bind$4;
              const _arg$2 = _EndPosOf._0;
              _tmp$4 = `_end_pos_of_item${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$elab$$elaborate_action$46$item_ident_to_index$124$56(name_to_index, _arg$2))}`;
              break;
            }
            case 6: {
              const _LocOf = _bind$4;
              const _arg$3 = _LocOf._0;
              const index = moonbitlang$yacc$lib$elab$$elaborate_action$46$item_ident_to_index$124$56(name_to_index, _arg$3);
              _tmp$4 = `(_start_pos_of_item${moonbitlang$core$builtin$$Show$to_string$111$(index)}, _end_pos_of_item${moonbitlang$core$builtin$$Show$to_string$111$(index)})`;
              break;
            }
            case 7: {
              _tmp$4 = "_symbol_start_pos";
              break;
            }
            default: {
              _tmp$4 = "(_symbol_start_pos, _end_pos)";
            }
          }
          moonbitlang$core$array$$Array$push$65$(body, { _0: _tmp$4, _1: { _0: _code.utf8_pos + item.start | 0, _1: item.end - item.start | 0 } });
          last_index = item.end;
          _tmp$3 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (last_index < _code.code.length) {
        const len = _code.code.length - last_index | 0;
        let _tmp$4;
        let _try_err;
        _L: {
          _L$2: {
            const _bind$3 = moonbitlang$core$string$$String$sub$46$inner(_code.code, last_index, _code.code.length);
            let _tmp$5;
            if (_bind$3.$tag === 1) {
              const _ok = _bind$3;
              _tmp$5 = _ok._0;
            } else {
              const _err = _bind$3;
              const _tmp$6 = _err._0;
              _try_err = _tmp$6;
              break _L$2;
            }
            _tmp$4 = moonbitlang$core$builtin$$Show$to_string$14$(_tmp$5);
            break _L;
          }
          _tmp$4 = $panic();
        }
        moonbitlang$core$array$$Array$push$65$(body, { _0: _tmp$4, _1: { _0: _code.utf8_pos + last_index | 0, _1: len } });
      }
    }
  } else {
    const _bind$2 = moonbitlang$yacc$lib$elab$$elaborate_action$46$add_binding$124$62(_env, $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$StartPos, moonbitlang$yacc$lib$elab$$elaborate_action$46$tuple$47$7967);
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _ok._0;
    } else {
      return _bind$2;
    }
    const _bind$3 = moonbitlang$yacc$lib$elab$$elaborate_action$46$add_binding$124$62(_env, $64$moonbitlang$47$yacc$47$lib$47$ast$46$SubstItemDesc$EndPos, moonbitlang$yacc$lib$elab$$elaborate_action$46$tuple$47$7968);
    if (_bind$3.$tag === 1) {
      const _ok = _bind$3;
      _ok._0;
    } else {
      return _bind$3;
    }
    moonbitlang$core$array$$Array$push$65$(body, { _0: `{\n  \"type\": \"NONTERMINAL\",\n  \"name\": \"${nonterminal_name}\",\n  \"rule_index\": ${moonbitlang$core$builtin$$Show$to_string$111$(rule_index)},\n  \"clause_index\": ${moonbitlang$core$builtin$$Show$to_string$111$(clause_index)},\n  \"children\": args_to_json(_args),\n  \"start\": _start_pos.to_json(),\n  \"end\": _end_pos.to_json(),\n}\n`, _1: undefined });
  }
  const _ast_clause_without_action = ast_clause._0;
  const _ast_clause_action = ast_clause._1;
  const _bind$2 = moonbitlang$yacc$lib$elab$$offset_to_line_column(parser_spec_str, _ast_clause_without_action.loc._0);
  const _line = _bind$2._0;
  const _column = _bind$2._1;
  const _tmp$2 = _line - 1 | 0;
  const _tmp$3 = _column - 1 | 0;
  let _tmp$4;
  let _try_err;
  _L: {
    _L$2: {
      const _bind$3 = moonbitlang$core$string$$String$sub$46$inner(parser_spec_str, _ast_clause_without_action.loc._0, _ast_clause_action.loc._0 + _ast_clause_action.loc._1 | 0);
      let _tmp$5;
      if (_bind$3.$tag === 1) {
        const _ok = _bind$3;
        _tmp$5 = _ok._0;
      } else {
        const _err = _bind$3;
        const _tmp$6 = _err._0;
        _try_err = _tmp$6;
        break _L$2;
      }
      _tmp$4 = moonbitlang$core$builtin$$Show$to_string$14$(_tmp$5);
      break _L;
    }
    _tmp$4 = $panic();
  }
  const original_clause_info = { file: filename, line: _tmp$2, column: _tmp$3, code: _tmp$4 };
  return new Result$Ok$48$({ stamp: moonbitlang$yacc$lib$util$stamp$$new(), arity: arity, type_: type_, sub_actions: [], bindings: bindings, body: body, original_clause_info: original_clause_info });
}
function moonbitlang$yacc$lib$elab$$elaborate_type_expr_with_generic_params(ast_type_expr, generic_params) {
  const elaborate_type_expr = (ast_type_expr$2) => moonbitlang$yacc$lib$elab$$elaborate_type_expr_with_generic_params(ast_type_expr$2, generic_params);
  let name;
  let pkg;
  let args;
  _L: {
    switch (ast_type_expr.$tag) {
      case 0: {
        const _Constr = ast_type_expr;
        const _x = _Constr._0;
        if (_x === undefined) {
          const _name = _Constr._1;
          const _x$2 = _Constr._2;
          if (_x$2.length === 0) {
            if (moonbitlang$core$set$$Set$contains$13$(generic_params, _name)) {
              return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Param(_name);
            } else {
              name = _name;
              pkg = _x;
              args = _x$2;
              break _L;
            }
          } else {
            name = _name;
            pkg = _x;
            args = _x$2;
            break _L;
          }
        } else {
          const _name = _Constr._1;
          const _args = _Constr._2;
          name = _name;
          pkg = _x;
          args = _args;
          break _L;
        }
      }
      case 1: {
        const _Option = ast_type_expr;
        const _inner = _Option._0;
        return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Option(elaborate_type_expr(_inner));
      }
      case 2: {
        const _Tuple = ast_type_expr;
        const _args = _Tuple._0;
        const _p = new Array(_args.length);
        const _p$2 = _args.length;
        let _tmp = 0;
        while (true) {
          const _p$3 = _tmp;
          if (_p$3 < _p$2) {
            const _p$4 = _args[_p$3];
            _p[_p$3] = elaborate_type_expr(_p$4);
            _tmp = _p$3 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Tuple(_p);
      }
      default: {
        const _Arrow = ast_type_expr;
        const _args$2 = _Arrow._0;
        const _ret = _Arrow._1;
        const _p$3 = new Array(_args$2.length);
        const _p$4 = _args$2.length;
        let _tmp$2 = 0;
        while (true) {
          const _p$5 = _tmp$2;
          if (_p$5 < _p$4) {
            const _p$6 = _args$2[_p$5];
            _p$3[_p$5] = elaborate_type_expr(_p$6);
            _tmp$2 = _p$5 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Arrow(_p$3, elaborate_type_expr(_ret));
      }
    }
  }
  const _p = new Array(args.length);
  const _p$2 = args.length;
  let _tmp = 0;
  while (true) {
    const _p$3 = _tmp;
    if (_p$3 < _p$2) {
      const _p$4 = args[_p$3];
      _p[_p$3] = elaborate_type_expr(_p$4);
      _tmp = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(pkg, name, _p);
}
function moonbitlang$yacc$lib$elab$$map_error$257$(arr, f) {
  const result = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const item = arr[_i];
      const _bind = f(item);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$32$(result, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$49$(result);
}
function moonbitlang$yacc$lib$elab$$map_error$258$(arr, f) {
  const result = [];
  const _len = arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const item = arr[_i];
      const _bind = f(item);
      let _tmp$2;
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _tmp$2 = _ok._0;
      } else {
        return _bind;
      }
      moonbitlang$core$array$$Array$push$67$(result, _tmp$2);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$50$(result);
}
function moonbitlang$yacc$lib$elab$$elaborate_type_expr(ast_type_expr) {
  return moonbitlang$yacc$lib$elab$$elaborate_type_expr_with_generic_params(ast_type_expr, moonbitlang$core$set$$Set$new$46$inner$13$(8));
}
function moonbitlang$yacc$lib$elab$$parse_and_elaborate_type_expr(str) {
  let type_expr;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$yacc$lib$parser$type_expr_parser$$parse(str);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        type_expr = _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err = _tmp;
        break _L$2;
      }
      break _L;
    }
    return new Result$Err$51$(new Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$FailedToParseTypeExpr(str));
  }
  return new Result$Ok$51$(moonbitlang$yacc$lib$elab$$elaborate_type_expr(type_expr));
}
function moonbitlang$yacc$lib$elab$$elaborate$46$get_token_by_name$124$123(_env, name) {
  const tokens = _env._1;
  const token_by_name = _env._0;
  const _bind = moonbitlang$core$builtin$$Map$get$219$(token_by_name, name);
  if (_bind === undefined) {
    const _bind$2 = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Unit", []);
    const _bind$3 = undefined;
    const _bind$4 = undefined;
    const token = { name: name, prec: _bind$4, type_: _bind$2, image: _bind$3 };
    moonbitlang$core$builtin$$Map$set$219$(token_by_name, name, token);
    moonbitlang$core$array$$Array$push$144$(tokens, token);
    return token;
  } else {
    const _Some = _bind;
    return _Some;
  }
}
function moonbitlang$yacc$lib$elab$$elaborate$46$elaborate_token_type$124$124(token_payload_rewrite, type_) {
  switch (token_payload_rewrite) {
    case 2: {
      if (type_ === undefined) {
        return new Result$Ok$51$(new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Unit", []));
      } else {
        const _Some = type_;
        const _type_ = _Some;
        return moonbitlang$yacc$lib$elab$$parse_and_elaborate_type_expr(_type_);
      }
    }
    case 1: {
      return new Result$Ok$51$(new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Json", []));
    }
    default: {
      return new Result$Ok$51$(new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Unit", []));
    }
  }
}
function moonbitlang$yacc$lib$elab$$elaborate$46$map_term$124$196(_env, ast_term, rule_param_map) {
  const rule_by_name = _env._2;
  const token_by_name = _env._1;
  const token_by_image = _env._0;
  switch (ast_term.$tag) {
    case 0: {
      const _Symbol = ast_term;
      const _symbol = _Symbol._0;
      const _loc = _Symbol._1;
      const _bind = moonbitlang$core$builtin$$Map$get$219$(token_by_name, _symbol);
      if (_bind === undefined) {
        const _bind$2 = moonbitlang$core$builtin$$Map$get$220$(rule_param_map, _symbol);
        if (_bind$2 === undefined) {
          const _bind$3 = moonbitlang$core$builtin$$Map$get$216$(rule_by_name, _symbol);
          if (_bind$3 === undefined) {
            return new Result$Err$52$(new Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$UnresolvedSymbol(_symbol, _loc));
          } else {
            const _Some = _bind$3;
            const _rule = _Some;
            return new Result$Ok$52$(new $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$RuleCall(_symbol, [], _rule.type_));
          }
        } else {
          const _Some = _bind$2;
          const _type_ = _Some;
          return new Result$Ok$52$(new $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$Param(_symbol, _type_));
        }
      } else {
        const _Some = _bind;
        const _token = _Some;
        return new Result$Ok$52$(new $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$Token(_token));
      }
    }
    case 1: {
      const _Image = ast_term;
      const _image = _Image._0;
      const _loc$2 = _Image._1;
      const _bind$2 = moonbitlang$core$builtin$$Map$get$219$(token_by_image, _image);
      if (_bind$2 === undefined) {
        return new Result$Err$52$(new Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$UnresolvedSymbol(moonbitlang$core$string$$String$escape(_image), _loc$2));
      } else {
        const _Some = _bind$2;
        const _token = _Some;
        return new Result$Ok$52$(new $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$Token(_token));
      }
    }
    default: {
      const _RuleCall = ast_term;
      const _symbol$2 = _RuleCall._0;
      const _symbol_loc = _RuleCall._1;
      const _args = _RuleCall._2;
      const _bind$3 = moonbitlang$core$builtin$$Map$get$216$(rule_by_name, _symbol$2);
      if (_bind$3 === undefined) {
        return new Result$Err$52$(new Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$UnresolvedSymbol(_symbol$2, _symbol_loc));
      } else {
        const _Some = _bind$3;
        const _rule = _Some;
        const _bind$4 = moonbitlang$yacc$lib$elab$$map_error$258$(_args, (arg) => moonbitlang$yacc$lib$elab$$elaborate$46$map_term$124$196(_env, arg, rule_param_map));
        let _tmp;
        if (_bind$4.$tag === 1) {
          const _ok = _bind$4;
          _tmp = _ok._0;
        } else {
          return _bind$4;
        }
        return new Result$Ok$52$(new $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$RuleCall(_symbol$2, _tmp, _rule.type_));
      }
    }
  }
}
function moonbitlang$yacc$lib$elab$$elaborate(ast_spec, parser_spec_str, filename, json_cst, stdlib_rules, token_payload_rewrite, force_int_position) {
  let header = moonbitlang$core$immut$array$$T$new$65$();
  let trailer = moonbitlang$core$immut$array$$T$new$65$();
  const _arr = ast_spec.decls;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const decl = _arr[_i];
      switch (decl.$tag) {
        case 0: {
          const _Header = decl;
          const _code = _Header._0;
          const _utf8_pos = _Header._1;
          const _utf8_len = _Header._2;
          header = moonbitlang$core$immut$array$$T$push$65$(header, { _0: _code, _1: { _0: _utf8_pos, _1: _utf8_len } });
          break;
        }
        case 1: {
          const _Trailer = decl;
          const _code$2 = _Trailer._0;
          const _utf8_pos$2 = _Trailer._1;
          const _utf8_len$2 = _Trailer._2;
          trailer = moonbitlang$core$immut$array$$T$push$65$(trailer, { _0: _code$2, _1: { _0: _utf8_pos$2, _1: _utf8_len$2 } });
          break;
        }
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _bind = [];
  const token_by_name = moonbitlang$core$builtin$$Map$from_array$219$({ buf: _bind, start: 0, end: 0 });
  const _bind$2 = [];
  const rule_by_name = moonbitlang$core$builtin$$Map$from_array$216$({ buf: _bind$2, start: 0, end: 0 });
  const _bind$3 = [];
  const token_by_image = moonbitlang$core$builtin$$Map$from_array$219$({ buf: _bind$3, start: 0, end: 0 });
  const tokens = [];
  if (stdlib_rules === undefined) {
  } else {
    const _Some = stdlib_rules;
    const _stdlib_rules = _Some;
    const _it = moonbitlang$core$builtin$$Map$iter2$216$(_stdlib_rules);
    while (true) {
      const _bind$4 = moonbitlang$core$builtin$$Iter2$next$216$(_it);
      if (_bind$4 === undefined) {
        break;
      } else {
        const _Some$2 = _bind$4;
        const _x = _Some$2;
        const _rule_name = _x._0;
        const _rule = _x._1;
        moonbitlang$core$builtin$$Map$set$216$(rule_by_name, _rule_name, _rule);
        continue;
      }
    }
  }
  const _env = { _0: token_by_name, _1: tokens };
  const _arr$2 = ast_spec.decls;
  const _len$2 = _arr$2.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const ast_decl = _arr$2[_i];
      switch (ast_decl.$tag) {
        case 3: {
          const _Token = ast_decl;
          const _names = _Token._0;
          const _type_ = _Token._1;
          const _len$3 = _names.length;
          let _tmp$3 = 0;
          while (true) {
            const _i$2 = _tmp$3;
            if (_i$2 < _len$3) {
              const name = _names[_i$2];
              const token = moonbitlang$yacc$lib$elab$$elaborate$46$get_token_by_name$124$123(_env, name.symbol);
              const _bind$4 = moonbitlang$yacc$lib$elab$$elaborate$46$elaborate_token_type$124$124(token_payload_rewrite, _type_);
              let _tmp$4;
              if (_bind$4.$tag === 1) {
                const _ok = _bind$4;
                _tmp$4 = _ok._0;
              } else {
                return _bind$4;
              }
              token.type_ = _tmp$4;
              _tmp$3 = _i$2 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          break;
        }
        case 4: {
          const _Token1 = ast_decl;
          const _name = _Token1._0;
          const _type_$2 = _Token1._1;
          const _image = _Token1._2;
          const token = moonbitlang$yacc$lib$elab$$elaborate$46$get_token_by_name$124$123(_env, _name.symbol);
          const _bind$4 = moonbitlang$yacc$lib$elab$$elaborate$46$elaborate_token_type$124$124(token_payload_rewrite, _type_$2);
          let _tmp$4;
          if (_bind$4.$tag === 1) {
            const _ok = _bind$4;
            _tmp$4 = _ok._0;
          } else {
            return _bind$4;
          }
          token.type_ = _tmp$4;
          token.image = _image;
          moonbitlang$core$builtin$$Map$set$219$(token_by_image, _image, token);
          break;
        }
      }
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _arr$3 = ast_spec.rules;
  const _len$3 = _arr$3.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$3) {
      const ast_rule = _arr$3[_i];
      const _bind$4 = ast_rule.generic_params;
      const generic_params = moonbitlang$core$set$$Set$from_array$13$({ buf: _bind$4, start: 0, end: _bind$4.length });
      const _p = ast_rule.params;
      const _p$2 = new Array(_p.length);
      const _p$3 = _p.length;
      let _tmp$4 = 0;
      while (true) {
        const _p$4 = _tmp$4;
        if (_p$4 < _p$3) {
          const _p$5 = _p[_p$4];
          const _p$6 = _p$5._0;
          const _p$7 = _p$5._1;
          let _p$8;
          if (_p$7 === undefined) {
            const _p$9 = `_${moonbitlang$core$builtin$$Show$to_string$111$(generic_params.size)}`;
            moonbitlang$core$set$$Set$add$13$(generic_params, _p$9);
            _p$8 = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Param(_p$9);
          } else {
            const _p$9 = _p$7;
            const _p$10 = _p$9;
            _p$8 = moonbitlang$yacc$lib$elab$$elaborate_type_expr_with_generic_params(_p$10, generic_params);
          }
          _p$2[_p$4] = { _0: _p$6, _1: _p$8 };
          _tmp$4 = _p$4 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const params = _p$2;
      let type_;
      if (json_cst === 1) {
        type_ = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Json", []);
      } else {
        const _bind$5 = ast_rule.type_;
        if (_bind$5 === undefined) {
          type_ = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Unit", []);
        } else {
          const _Some = _bind$5;
          const _type_ = _Some;
          type_ = moonbitlang$yacc$lib$elab$$elaborate_type_expr_with_generic_params(_type_, generic_params);
        }
      }
      const _bind$5 = ast_rule.inline;
      const _bind$6 = ast_rule.nonterminal;
      const _bind$7 = [];
      const rule = { name: _bind$6, inline: _bind$5, generic_params: generic_params, params: params, type_: type_, clauses: _bind$7 };
      moonbitlang$core$builtin$$Map$set$216$(rule_by_name, rule.name, rule);
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let curr_prec = 0;
  const prec_map = moonbitlang$core$sorted_map$$SortedMap$new$242$();
  const start_rules = [];
  const _arr$4 = ast_spec.decls;
  const _len$4 = _arr$4.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$4) {
      const ast_decl = _arr$4[_i];
      let idents;
      _L: {
        _L$2: {
          switch (ast_decl.$tag) {
            case 8: {
              const _Left = ast_decl;
              const _idents = _Left._0;
              idents = _idents;
              break _L$2;
            }
            case 9: {
              const _Right = ast_decl;
              const _idents$2 = _Right._0;
              idents = _idents$2;
              break _L$2;
            }
            case 10: {
              const _Nonassoc = ast_decl;
              const _idents$3 = _Nonassoc._0;
              idents = _idents$3;
              break _L$2;
            }
            case 2: {
              const _Start = ast_decl;
              const _symbols = _Start._0;
              const _type_ = _Start._1;
              const _len$5 = _symbols.length;
              let _tmp$5 = 0;
              while (true) {
                const _i$2 = _tmp$5;
                if (_i$2 < _len$5) {
                  const symbol = _symbols[_i$2];
                  moonbitlang$core$array$$Array$push$13$(start_rules, symbol.symbol);
                  const _bind$4 = moonbitlang$core$builtin$$Map$get$216$(rule_by_name, symbol.symbol);
                  if (_bind$4 === undefined) {
                    return new Result$Err$53$(new Error$moonbitlang$47$yacc$47$lib$47$elab$46$ElabError$46$UnresolvedSymbol(symbol.symbol, symbol.loc));
                  } else {
                    const _Some = _bind$4;
                    const _rule = _Some;
                    if (json_cst === 0) {
                      if (_type_ === undefined) {
                      } else {
                        const _Some$2 = _type_;
                        const _type_$2 = _Some$2;
                        const _bind$5 = moonbitlang$yacc$lib$elab$$parse_and_elaborate_type_expr(_type_$2);
                        let _tmp$6;
                        if (_bind$5.$tag === 1) {
                          const _ok = _bind$5;
                          _tmp$6 = _ok._0;
                        } else {
                          return _bind$5;
                        }
                        _rule.type_ = _tmp$6;
                      }
                    }
                  }
                  _tmp$5 = _i$2 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              break;
            }
            case 5: {
              const _Type = ast_decl;
              const _idents$4 = _Type._0;
              const _type_$2 = _Type._1;
              const _len$6 = _idents$4.length;
              let _tmp$6 = 0;
              while (true) {
                const _i$2 = _tmp$6;
                if (_i$2 < _len$6) {
                  const ident = _idents$4[_i$2];
                  const _bind$4 = moonbitlang$core$builtin$$Map$get$219$(token_by_name, ident.symbol);
                  if (_bind$4 === undefined) {
                    const _bind$5 = moonbitlang$core$builtin$$Map$get$216$(rule_by_name, ident.symbol);
                    if (_bind$5 === undefined) {
                      $panic();
                    } else {
                      const _Some = _bind$5;
                      const _rule = _Some;
                      if (json_cst === 0) {
                        const _bind$6 = moonbitlang$yacc$lib$elab$$parse_and_elaborate_type_expr(_type_$2);
                        let _tmp$7;
                        if (_bind$6.$tag === 1) {
                          const _ok = _bind$6;
                          _tmp$7 = _ok._0;
                        } else {
                          return _bind$6;
                        }
                        _rule.type_ = _tmp$7;
                      }
                    }
                  } else {
                    const _Some = _bind$4;
                    const _token = _Some;
                    if (token_payload_rewrite === 2) {
                      const _bind$5 = moonbitlang$yacc$lib$elab$$elaborate$46$elaborate_token_type$124$124(token_payload_rewrite, _type_$2);
                      let _tmp$7;
                      if (_bind$5.$tag === 1) {
                        const _ok = _bind$5;
                        _tmp$7 = _ok._0;
                      } else {
                        return _bind$5;
                      }
                      _token.type_ = _tmp$7;
                    }
                  }
                  _tmp$6 = _i$2 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              break;
            }
          }
          break _L;
        }
        let assoc;
        switch (ast_decl.$tag) {
          case 8: {
            assoc = 0;
            break;
          }
          case 9: {
            assoc = 1;
            break;
          }
          case 10: {
            assoc = 2;
            break;
          }
          default: {
            assoc = $panic();
          }
        }
        const prec = curr_prec;
        curr_prec = curr_prec + 1 | 0;
        const _len$5 = idents.length;
        let _tmp$5 = 0;
        while (true) {
          const _i$2 = _tmp$5;
          if (_i$2 < _len$5) {
            const ident = idents[_i$2];
            if (ident.$tag === 0) {
              const _Symbol = ident;
              const _name = _Symbol._0;
              const _bind$4 = moonbitlang$core$builtin$$Map$get$219$(token_by_name, _name);
              if (_bind$4 === undefined) {
              } else {
                const _Some = _bind$4;
                const _token = _Some;
                _token.prec = { _0: prec, _1: assoc };
              }
              moonbitlang$core$sorted_map$$SortedMap$set$242$(prec_map, _name, { _0: prec, _1: assoc });
            } else {
              const _Image = ident;
              const _image = _Image._0;
              const _p = moonbitlang$core$builtin$$Map$get$219$(token_by_image, _image);
              let token;
              if (_p === undefined) {
                token = $panic();
              } else {
                const _p$2 = _p;
                token = _p$2;
              }
              token.prec = { _0: prec, _1: assoc };
              moonbitlang$core$sorted_map$$SortedMap$set$242$(prec_map, token.name, { _0: prec, _1: assoc });
            }
            _tmp$5 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _env$2 = { _0: token_by_image, _1: token_by_name, _2: rule_by_name };
  const _arr$5 = ast_spec.rules;
  const _len$5 = _arr$5.length;
  let _tmp$5 = 0;
  while (true) {
    const _i = _tmp$5;
    if (_i < _len$5) {
      const ast_rule = _arr$5[_i];
      const _p = moonbitlang$core$builtin$$Map$get$216$(rule_by_name, ast_rule.nonterminal);
      let rule;
      if (_p === undefined) {
        rule = $panic();
      } else {
        const _p$2 = _p;
        rule = _p$2;
      }
      const _bind$4 = rule.params;
      const rule_param_map = moonbitlang$core$builtin$$Map$from_array$220$({ buf: _bind$4, start: 0, end: _bind$4.length });
      const ast_clause_iter = moonbitlang$core$builtin$$Iter$flat_map$224$(moonbitlang$core$array$$Array$iter$158$(ast_rule.clauses), (it) => {
        const _clauses = it._0;
        const _action = it._1;
        return moonbitlang$core$builtin$$Iter$map$178$(moonbitlang$core$list$$List$iter$171$(_clauses), (it$2) => ({ _0: it$2, _1: _action }));
      });
      let clause_index = 0;
      while (true) {
        const _bind$5 = moonbitlang$core$builtin$$Iter$next$166$(ast_clause_iter);
        if (_bind$5 === undefined) {
          break;
        } else {
          const _Some = _bind$5;
          const _ast_clause = _Some;
          const _ast_clause$2 = _ast_clause._0;
          const _ast_clause_action = _ast_clause._1;
          const _bind$6 = moonbitlang$yacc$lib$elab$$map_error$257$(_ast_clause$2.items, (ast_item) => {
            const _tmp$6 = ast_item.binder;
            const _bind$7 = moonbitlang$yacc$lib$elab$$elaborate$46$map_term$124$196(_env$2, ast_item.term, rule_param_map);
            let _tmp$7;
            if (_bind$7.$tag === 1) {
              const _ok = _bind$7;
              _tmp$7 = _ok._0;
            } else {
              return _bind$7;
            }
            return new Result$Ok$54$({ binder: _tmp$6, term: _tmp$7 });
          });
          let items;
          if (_bind$6.$tag === 1) {
            const _ok = _bind$6;
            items = _ok._0;
          } else {
            return _bind$6;
          }
          const _bind$7 = _ast_clause$2.prec;
          let prec;
          if (_bind$7 === undefined) {
            prec = undefined;
          } else {
            const _Some$2 = _bind$7;
            const _ident = _Some$2;
            let _bind$8;
            if (_ident.$tag === 0) {
              const _Symbol = _ident;
              const _name = _Symbol._0;
              const _p$2 = moonbitlang$core$sorted_map$$SortedMap$get$242$(prec_map, _name);
              if (_p$2 === undefined) {
                _bind$8 = $panic();
              } else {
                const _p$3 = _p$2;
                _bind$8 = _p$3;
              }
            } else {
              const _Image = _ident;
              const _image = _Image._0;
              const _p$2 = moonbitlang$core$builtin$$Map$get$219$(token_by_image, _image);
              let _tmp$6;
              if (_p$2 === undefined) {
                _tmp$6 = $panic();
              } else {
                const _p$3 = _p$2;
                _tmp$6 = _p$3;
              }
              const _p$3 = moonbitlang$core$sorted_map$$SortedMap$get$242$(prec_map, _tmp$6.name);
              if (_p$3 === undefined) {
                _bind$8 = $panic();
              } else {
                const _p$4 = _p$3;
                _bind$8 = _p$4;
              }
            }
            const _prec = _bind$8._0;
            prec = _prec;
          }
          const _bind$8 = moonbitlang$yacc$lib$elab$$elaborate_action(items, _ast_clause_action, parser_spec_str, filename, _i, clause_index, { _0: _ast_clause$2, _1: _ast_clause_action }, rule.name, rule.type_, json_cst);
          let _tmp$6;
          if (_bind$8.$tag === 1) {
            const _ok = _bind$8;
            _tmp$6 = _ok._0;
          } else {
            return _bind$8;
          }
          const clause = { items: items, prec: prec, action: _tmp$6 };
          moonbitlang$core$array$$Array$push$138$(rule.clauses, clause);
          clause_index = clause_index + 1 | 0;
          continue;
        }
      }
      _tmp$5 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let position_type = force_int_position ? new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Int", []) : new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Unit", []);
  const derive_map = moonbitlang$yacc$lib$util$array_multimap$$new$256$();
  const _arr$6 = ast_spec.decls;
  const _len$6 = _arr$6.length;
  let _tmp$6 = 0;
  while (true) {
    const _i = _tmp$6;
    if (_i < _len$6) {
      const ast_decl = _arr$6[_i];
      switch (ast_decl.$tag) {
        case 7: {
          const _Position = ast_decl;
          const _type_ = _Position._0;
          if (!force_int_position) {
            const _bind$4 = moonbitlang$yacc$lib$elab$$parse_and_elaborate_type_expr(_type_);
            let _tmp$7;
            if (_bind$4.$tag === 1) {
              const _ok = _bind$4;
              _tmp$7 = _ok._0;
            } else {
              return _bind$4;
            }
            position_type = _tmp$7;
          }
          break;
        }
        case 6: {
          const _Derive = ast_decl;
          const _traits = _Derive._0;
          const _type_$2 = _Derive._1;
          const traits = moonbitlang$core$builtin$$Iter$map$179$(moonbitlang$core$string$$String$split(_traits, { str: moonbitlang$yacc$lib$elab$$elaborate$46$42$bind$124$791, start: 0, end: moonbitlang$yacc$lib$elab$$elaborate$46$42$bind$124$791.length }), (t) => moonbitlang$core$builtin$$Show$to_string$14$(moonbitlang$core$string$$StringView$trim$46$inner(t, { str: moonbitlang$yacc$lib$elab$$elaborate$46$42$bind$124$792, start: 0, end: moonbitlang$yacc$lib$elab$$elaborate$46$42$bind$124$792.length })));
          while (true) {
            const _bind$4 = moonbitlang$core$builtin$$Iter$next$13$(traits);
            if (_bind$4 === undefined) {
              break;
            } else {
              const _Some = _bind$4;
              const _trait_ = _Some;
              moonbitlang$yacc$lib$util$array_multimap$$T$add$256$(derive_map, _type_$2, _trait_);
              continue;
            }
          }
          break;
        }
      }
      _tmp$6 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (json_cst === 1) {
    header = moonbitlang$core$immut$array$$T$new$65$();
    trailer = moonbitlang$core$immut$array$$T$new$65$();
  }
  return new Result$Ok$53$({ header: header, trailer: trailer, tokens: tokens, rules: rule_by_name, start_rules: start_rules, position_type: position_type, derive_map: derive_map });
}
function moonbitlang$yacc$lib$elab$$build_rules_from_src(src, filename, json_cst, token_payload_rewrite, force_int_position) {
  const lexer = moonbitlang$yacc$lib$parser$$new_lexer(src);
  const token = () => {
    let _try_err;
    _L: {
      const _bind = moonbitlang$yacc$lib$parser$$Lexer$next_token(lexer);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        return _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err = _tmp;
        break _L;
      }
    }
    return $panic();
  };
  let ast_spec;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$yacc$lib$parser$$spec(token, 0);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        ast_spec = _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err = _tmp;
        break _L$2;
      }
      break _L;
    }
    ast_spec = $panic();
  }
  let spec;
  let _try_err$2;
  _L$2: {
    _L$3: {
      const _bind = moonbitlang$yacc$lib$elab$$elaborate(ast_spec, src, filename, json_cst, undefined, token_payload_rewrite, force_int_position);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        spec = _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err$2 = _tmp;
        break _L$3;
      }
      break _L$2;
    }
    spec = $panic();
  }
  return spec.rules;
}
function moonbitlang$yacc$lib$elab$$elaborate_with_stdlib_rules(ast_spec, parser_spec_str, filename, json_cst, no_std, token_payload_rewrite, force_int_position) {
  let _tmp;
  if (no_std) {
    const _bind = [];
    _tmp = moonbitlang$core$builtin$$Map$from_array$216$({ buf: _bind, start: 0, end: 0 });
  } else {
    _tmp = moonbitlang$yacc$lib$elab$$build_rules_from_src(moonbitlang$yacc$lib$elab$$stdlib_src, "stdlib.mbty", json_cst, token_payload_rewrite, force_int_position);
  }
  return moonbitlang$yacc$lib$elab$$elaborate(ast_spec, parser_spec_str, filename, json_cst, _tmp, token_payload_rewrite, force_int_position);
}
function moonbitlang$core$builtin$$Show$output$75$(self, logger) {
  let _tmp;
  switch (self.$tag) {
    case 0: {
      const _Constr = self;
      const _pkg = _Constr._0;
      const _name = _Constr._1;
      const _args = _Constr._2;
      let primary;
      if (_pkg === undefined) {
        primary = _name;
      } else {
        const _Some = _pkg;
        const _pkg$2 = _Some;
        primary = `@${_pkg$2}.${_name}`;
      }
      _tmp = _args.length === 0 ? primary : `${primary}[${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$188$(moonbitlang$core$array$$Array$iter$75$(_args), moonbitlang$core$builtin$$Show$to_string$122$), ", ")}]`;
      break;
    }
    case 1: {
      _tmp = $panic();
      break;
    }
    case 2: {
      const _Option = self;
      const _type_ = _Option._0;
      if (_type_.$tag === 4) {
        _tmp = `(${moonbitlang$core$builtin$$Show$to_string$122$(_type_)})?`;
      } else {
        _tmp = `${moonbitlang$core$builtin$$Show$to_string$122$(_type_)}?`;
      }
      break;
    }
    case 3: {
      const _Tuple = self;
      const _types = _Tuple._0;
      _tmp = `(${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$188$(moonbitlang$core$array$$Array$iter$75$(_types), moonbitlang$core$builtin$$Show$to_string$122$), ", ")})`;
      break;
    }
    default: {
      const _Arrow = self;
      const _args$2 = _Arrow._0;
      const _ret = _Arrow._1;
      _tmp = `(${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$188$(moonbitlang$core$array$$Array$iter$75$(_args$2), moonbitlang$core$builtin$$Show$to_string$122$), ", ")}) -> ${moonbitlang$core$builtin$$Show$to_string$122$(_ret)}`;
    }
  }
  logger.method_table.method_0(logger.self, _tmp);
}
function moonbitlang$core$builtin$$Eq$equal$54$(_x_117, _x_118) {
  if (_x_117.$tag === 0) {
    const _T = _x_117;
    const _$42$x0_119 = _T._0;
    if (_x_118.$tag === 0) {
      const _T$2 = _x_118;
      const _$42$y0_120 = _T$2._0;
      return _$42$x0_119.num === _$42$y0_120.num;
    } else {
      return false;
    }
  } else {
    const _NT = _x_117;
    const _$42$x0_121 = _NT._0;
    if (_x_118.$tag === 1) {
      const _NT$2 = _x_118;
      const _$42$y0_122 = _NT$2._0;
      return _$42$x0_121.num === _$42$y0_122.num;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$54$(_x_105, _x_106) {
  if (_x_105.$tag === 0) {
    const _T = _x_105;
    const _$42$x0_107 = _T._0;
    if (_x_106.$tag === 0) {
      const _T$2 = _x_106;
      const _$42$y0_108 = _T$2._0;
      return $compare_int(_$42$x0_107.num, _$42$y0_108.num);
    } else {
      return -1;
    }
  } else {
    const _NT = _x_105;
    const _$42$x0_109 = _NT._0;
    if (_x_106.$tag === 0) {
      return 1;
    } else {
      const _NT$2 = _x_106;
      const _$42$y0_110 = _NT$2._0;
      return $compare_int(_$42$x0_109.num, _$42$y0_110.num);
    }
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$54$(_x_97, _x_98) {
  if (_x_97.$tag === 0) {
    const _T = _x_97;
    const _$42$arg_99 = _T._0;
    moonbitlang$core$builtin$$Hasher$combine_int(_x_98, 0);
    moonbitlang$core$builtin$$Hash$hash_combine$55$(_$42$arg_99, _x_98);
    return;
  } else {
    const _NT = _x_97;
    const _$42$arg_100 = _NT._0;
    moonbitlang$core$builtin$$Hasher$combine_int(_x_98, 1);
    moonbitlang$core$builtin$$Hash$hash_combine$53$(_$42$arg_100, _x_98);
    return;
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$55$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self.num);
}
function moonbitlang$core$builtin$$Hash$hash_combine$53$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self.num);
}
function moonbitlang$core$builtin$$Show$output$54$(self, logger) {
  if (self.$tag === 0) {
    const _T = self;
    const _t = _T._0;
    moonbitlang$core$builtin$$Logger$write_object$55$(logger, _t);
    return;
  } else {
    const _NT = self;
    const _nt = _NT._0;
    moonbitlang$core$builtin$$Logger$write_object$53$(logger, _nt);
    return;
  }
}
function moonbitlang$yacc$lib$grm$$Production$output_with_opt_dot$259$(self, logger, dot) {
  moonbitlang$core$builtin$$Logger$write_object$53$({ self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$Logger$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger }, self.lhs);
  logger.method_table.method_0(logger.self, " ");
  const _arr = self.rhs;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const symbol = _arr[_i];
      if (dot === undefined) {
      } else {
        const _Some = dot;
        const _d = _Some;
        if (_i === _d) {
          logger.method_table.method_0(logger.self, " ");
        }
      }
      logger.method_table.method_0(logger.self, " ");
      moonbitlang$core$builtin$$Logger$write_object$54$({ self: logger, method_table: $$$64$moonbitlang$47$core$47$builtin$46$Logger$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger }, symbol);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (dot === undefined) {
    return;
  } else {
    const _Some = dot;
    const _d = _Some;
    if (_d === self.rhs.length) {
      logger.method_table.method_0(logger.self, " ");
      return;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$260$(_x_141, _x_142) {
  return moonbitlang$core$builtin$$Eq$equal$235$(_x_141, _x_142);
}
function moonbitlang$yacc$lib$util$small_int_set$$singleton(key) {
  const word_index = key >> 5;
  const result = moonbitlang$core$array$$Array$make$17$(2, 0);
  moonbitlang$core$array$$Array$set$17$(result, 0, 1 << word_index);
  moonbitlang$core$array$$Array$set$17$(result, 1, 1 << (key & 31));
  return result;
}
function moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$is_singleton(self, key) {
  return self.length === 2 && (moonbitlang$core$array$$Array$at$17$(self, 0) === 1 << (key >> 5) && moonbitlang$core$array$$Array$at$17$(self, 1) === 1 << (key & 31));
}
function moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$iter(self) {
  const i = { val: 0 };
  const bitmask = { val: moonbitlang$core$array$$Array$at$17$(self, 0) };
  if (bitmask.val === 0) {
    return moonbitlang$core$builtin$$Iter$empty$17$();
  }
  const word = { val: moonbitlang$core$array$$Array$at$17$(self, 1 + i.val | 0) };
  const _p = () => {
    if (bitmask.val === 0) {
      return undefined;
    }
    let word_index = $i32_ctz(bitmask.val);
    if (word.val === 0) {
      bitmask.val = bitmask.val & ~(1 << word_index);
      i.val = i.val + 1 | 0;
      if (bitmask.val === 0) {
        return undefined;
      }
      word_index = $i32_ctz(bitmask.val);
      word.val = moonbitlang$core$array$$Array$at$17$(self, 1 + i.val | 0);
    }
    const bit = $i32_ctz(word.val);
    word.val = word.val & ~(1 << bit);
    return (Math.imul(word_index, 32) | 0) + bit | 0;
  };
  return _p;
}
function moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$union(self, other) {
  const bitmask1 = moonbitlang$core$array$$Array$at$17$(self, 0);
  if (bitmask1 === 0) {
    return other;
  }
  const bitmask2 = moonbitlang$core$array$$Array$at$17$(other, 0);
  if (bitmask2 === 0) {
    return self;
  }
  const bitmask = bitmask1 | bitmask2;
  if (bitmask === bitmask1) {
    if (self === other) {
      return self;
    }
    const result = moonbitlang$core$array$$Array$copy$17$(self);
    let bitmask2$2 = bitmask2;
    let j = 1;
    while (true) {
      const jb = $i32_ctz(bitmask2$2);
      if (jb === 32) {
        break;
      }
      const i = 1 + $i32_popcnt(bitmask1 & ((1 << jb) - 1 | 0)) | 0;
      moonbitlang$core$array$$Array$set$17$(result, i, moonbitlang$core$array$$Array$at$17$(result, i) | moonbitlang$core$array$$Array$at$17$(other, j));
      j = j + 1 | 0;
      bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
      continue;
    }
    return result;
  } else {
    if (bitmask === bitmask2) {
      if (self === other) {
        return self;
      }
      const result = moonbitlang$core$array$$Array$copy$17$(other);
      let bitmask1$2 = bitmask1;
      let i = 1;
      while (true) {
        const ib = $i32_ctz(bitmask1$2);
        if (ib === 32) {
          break;
        }
        const j = 1 + $i32_popcnt(bitmask2 & ((1 << ib) - 1 | 0)) | 0;
        moonbitlang$core$array$$Array$set$17$(result, j, moonbitlang$core$array$$Array$at$17$(result, j) | moonbitlang$core$array$$Array$at$17$(self, i));
        i = i + 1 | 0;
        bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
        continue;
      }
      return result;
    } else {
      const result = moonbitlang$core$array$$Array$make$17$(1 + $i32_popcnt(bitmask) | 0, 0);
      moonbitlang$core$array$$Array$set$17$(result, 0, bitmask);
      let i = 1;
      let j = 1;
      let k = 1;
      let bitmask1$2 = bitmask1;
      let bitmask2$2 = bitmask2;
      while (true) {
        const ib = $i32_ctz(bitmask1$2);
        const jb = $i32_ctz(bitmask2$2);
        if (ib < jb) {
          moonbitlang$core$array$$Array$set$17$(result, k, moonbitlang$core$array$$Array$at$17$(self, i));
          i = i + 1 | 0;
          bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
        } else {
          if (ib > jb) {
            moonbitlang$core$array$$Array$set$17$(result, k, moonbitlang$core$array$$Array$at$17$(other, j));
            j = j + 1 | 0;
            bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
          } else {
            if (ib === 32) {
              break;
            }
            moonbitlang$core$array$$Array$set$17$(result, k, moonbitlang$core$array$$Array$at$17$(self, i) | moonbitlang$core$array$$Array$at$17$(other, j));
            i = i + 1 | 0;
            j = j + 1 | 0;
            bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
            bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
          }
        }
        k = k + 1 | 0;
        continue;
      }
      return result;
    }
  }
}
function moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$disjoint(self, other) {
  const bitmask1 = moonbitlang$core$array$$Array$at$17$(self, 0);
  const bitmask2 = moonbitlang$core$array$$Array$at$17$(other, 0);
  if ((bitmask1 & bitmask2) !== 0) {
    return false;
  }
  let i = 1;
  let j = 1;
  let bitmask1$2 = bitmask1;
  let bitmask2$2 = bitmask2;
  while (true) {
    const ib = $i32_ctz(bitmask1$2);
    const jb = $i32_ctz(bitmask2$2);
    if (ib < jb) {
      i = i + 1 | 0;
      bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
    } else {
      if (ib > jb) {
        j = j + 1 | 0;
        bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
      } else {
        if (ib === 32) {
          break;
        }
        if ((moonbitlang$core$array$$Array$at$17$(self, i) & moonbitlang$core$array$$Array$at$17$(other, j)) !== 0) {
          return false;
        }
        i = i + 1 | 0;
        j = j + 1 | 0;
        bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
        bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
      }
    }
    continue;
  }
  return true;
}
function moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$subset(self, other) {
  const bitmask1 = moonbitlang$core$array$$Array$at$17$(self, 0);
  const bitmask2 = moonbitlang$core$array$$Array$at$17$(other, 0);
  if ((bitmask1 & bitmask2) !== bitmask1) {
    return false;
  }
  let i = 1;
  let j = 1;
  let bitmask1$2 = bitmask1;
  let bitmask2$2 = bitmask2;
  while (true) {
    const ib = $i32_ctz(bitmask1$2);
    const jb = $i32_ctz(bitmask2$2);
    if (ib < jb) {
      i = i + 1 | 0;
      bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
    } else {
      if (ib > jb) {
        j = j + 1 | 0;
        bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
      } else {
        if (ib === 32) {
          break;
        }
        if ((moonbitlang$core$array$$Array$at$17$(self, i) & moonbitlang$core$array$$Array$at$17$(other, j)) !== moonbitlang$core$array$$Array$at$17$(self, i)) {
          return false;
        }
        i = i + 1 | 0;
        j = j + 1 | 0;
        bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
        bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
      }
    }
    continue;
  }
  return true;
}
function moonbitlang$core$builtin$$Eq$equal$80$(_x_466, _x_467) {
  const _p = _x_466.state;
  const _p$2 = _x_467.state;
  if (_p.num === _p$2.num) {
    return moonbitlang$core$builtin$$Eq$equal$52$(_x_466.input, _x_467.input);
  } else {
    return false;
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$80$(_x_462, _x_463) {
  moonbitlang$core$builtin$$Hash$hash_combine$134$(_x_462.state, _x_463);
  moonbitlang$core$builtin$$Hash$hash_combine$52$(_x_462.input, _x_463);
}
function moonbitlang$core$builtin$$Hash$hash_combine$79$(_x_436, _x_437) {
  moonbitlang$core$builtin$$Hash$hash_combine$17$(_x_436, _x_437);
}
function moonbitlang$core$builtin$$Eq$equal$52$(_x_428, _x_429) {
  if (_x_428.$tag === 0) {
    if (_x_429.$tag === 0) {
      return true;
    } else {
      return false;
    }
  } else {
    const _Input = _x_428;
    const _$42$x0_430 = _Input._0;
    if (_x_429.$tag === 1) {
      const _Input$2 = _x_429;
      const _$42$y0_431 = _Input$2._0;
      return _$42$x0_430.num === _$42$y0_431.num;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$52$(_x_420, _x_421) {
  if (_x_420.$tag === 0) {
    if (_x_421.$tag === 0) {
      return 0;
    } else {
      return -1;
    }
  } else {
    const _Input = _x_420;
    const _$42$x0_422 = _Input._0;
    if (_x_421.$tag === 0) {
      return 1;
    } else {
      const _Input$2 = _x_421;
      const _$42$y0_423 = _Input$2._0;
      return $compare_int(_$42$x0_422.num, _$42$y0_423.num);
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$86$(_x_404, _x_405) {
  switch (_x_404.$tag) {
    case 0: {
      const _Shift = _x_404;
      const _$42$x0_406 = _Shift._0;
      if (_x_405.$tag === 0) {
        const _Shift$2 = _x_405;
        const _$42$y0_407 = _Shift$2._0;
        return _$42$x0_406.num === _$42$y0_407.num;
      } else {
        return false;
      }
    }
    case 1: {
      const _Reduce = _x_404;
      const _$42$x0_408 = _Reduce._0;
      if (_x_405.$tag === 1) {
        const _Reduce$2 = _x_405;
        const _$42$y0_409 = _Reduce$2._0;
        return _$42$x0_408.num === _$42$y0_409.num;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_405.$tag === 2) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      const _Conflict = _x_404;
      const _$42$x0_410 = _Conflict._0;
      if (_x_405.$tag === 3) {
        const _Conflict$2 = _x_405;
        const _$42$y0_411 = _Conflict$2._0;
        return moonbitlang$core$builtin$$Eq$equal$239$(_$42$x0_410, _$42$y0_411);
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$equal$72$(_x_388, _x_389) {
  return moonbitlang$core$builtin$$Eq$equal$260$(_x_388, _x_389);
}
function moonbitlang$yacc$lib$lr1$$resolve_conflicts(conflicts) {
  const errors = [];
  const _it = moonbitlang$yacc$lib$util$hashmap2$$T$iterator2$128$(conflicts);
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter2$next$128$(_it);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const _location = _x._0;
      const _decisions = _x._1;
      const _state = _location.state;
      const _input = _location.input;
      const shift = [];
      const reduce = [];
      const _it$2 = moonbitlang$core$list$$List$iter$86$(_decisions);
      while (true) {
        const _bind$2 = moonbitlang$core$builtin$$Iter$next$86$(_it$2);
        if (_bind$2 === undefined) {
          break;
        } else {
          const _Some$2 = _bind$2;
          const _decision = _Some$2;
          switch (_decision.$tag) {
            case 0: {
              const _Shift = _decision;
              const _state$2 = _Shift._0;
              moonbitlang$core$array$$Array$push$135$(shift, { _0: _input, _1: _state$2 });
              break;
            }
            case 1: {
              const _Reduce = _decision;
              const _production = _Reduce._0;
              moonbitlang$core$array$$Array$push$34$(reduce, _production);
              break;
            }
            case 2: {
              $panic();
              break;
            }
            default: {
              $panic();
            }
          }
          continue;
        }
      }
      if (shift.length <= 1) {
        if (reduce.length >= 1) {
          moonbitlang$core$array$$Array$sort_by_key$232$(reduce, (prod) => prod.num);
          const best_reduce = moonbitlang$core$array$$Array$at$34$(reduce, 0);
          let decision;
          if (shift.length === 0) {
            decision = new Result$Ok$55$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(best_reduce));
          } else {
            if (shift.length === 1) {
              const _x$2 = shift[0];
              const _input$2 = _x$2._0;
              const _shift_state = _x$2._1;
              let term_prec;
              if (_input$2.$tag === 1) {
                const _Input = _input$2;
                const _term = _Input._0;
                term_prec = _term.prec;
              } else {
                term_prec = undefined;
              }
              const _bind$2 = best_reduce.prec;
              if (term_prec === undefined) {
                if (_bind$2 === undefined) {
                  moonbitlang$core$array$$Array$push$136$(errors, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_resolved_without_precedence(_state, _input$2, _shift_state, best_reduce));
                  decision = new Result$Ok$55$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(_shift_state));
                } else {
                  decision = new Result$Ok$55$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(best_reduce));
                }
              } else {
                const _Some$2 = term_prec;
                if (_bind$2 === undefined) {
                  decision = new Result$Ok$55$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(_shift_state));
                } else {
                  const _x$3 = _Some$2;
                  const _prec1 = _x$3._0;
                  const _assoc1 = _x$3._1;
                  const _Some$3 = _bind$2;
                  const _prec2 = _Some$3;
                  if (_prec1 > _prec2) {
                    decision = new Result$Ok$55$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(_shift_state));
                  } else {
                    if (_prec2 > _prec1) {
                      decision = new Result$Ok$55$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(best_reduce));
                    } else {
                      switch (_assoc1) {
                        case 0: {
                          decision = new Result$Ok$55$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(best_reduce));
                          break;
                        }
                        case 1: {
                          decision = new Result$Ok$55$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(_shift_state));
                          break;
                        }
                        default: {
                          decision = new Result$Err$55$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_not_resolved_because_of_non_assoc(_state, _input$2, _shift_state, best_reduce));
                        }
                      }
                    }
                  }
                }
              }
            } else {
              decision = $panic();
            }
          }
          if (reduce.length >= 2) {
            _L: {
              _L$2: {
                if (decision.$tag === 1) {
                  const _Ok = decision;
                  const _x$2 = _Ok._0;
                  if (_x$2.$tag === 1) {
                    const _Reduce = _x$2;
                    const _prod = _Reduce._0;
                    if (_prod.num === best_reduce.num) {
                      moonbitlang$core$array$$Array$push$136$(errors, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Reduce_conflict_resolved_by_presentation_order(_state, _input, reduce, best_reduce));
                    }
                  } else {
                    break _L$2;
                  }
                } else {
                  break _L$2;
                }
                break _L;
              }
            }
          }
          if (decision.$tag === 1) {
            const _Ok = decision;
            const _decision = _Ok._0;
            moonbitlang$core$sorted_map$$SortedMap$set$226$(_state.action, _input, _decision);
          } else {
            const _Err = decision;
            const _error = _Err._0;
            moonbitlang$core$array$$Array$push$136$(errors, _error);
          }
        } else {
          $panic();
        }
      } else {
        $panic();
      }
      continue;
    }
  }
  return errors;
}
function moonbitlang$core$builtin$$Hash$hash_combine$52$(self, hasher) {
  if (self.$tag === 0) {
    moonbitlang$core$builtin$$Hasher$combine_int(hasher, -1);
    return;
  } else {
    const _Input = self;
    const _t = _Input._0;
    moonbitlang$core$builtin$$Hasher$combine_int(hasher, _t.num);
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$52$(self, logger) {
  if (self.$tag === 1) {
    const _Input = self;
    const _t = _Input._0;
    moonbitlang$core$builtin$$Logger$write_object$55$(logger, _t);
    return;
  } else {
    logger.method_table.method_0(logger.self, "$");
    return;
  }
}
function moonbitlang$yacc$lib$lr1$$EpsilonLookaheadSet$union$142$(set1, set2) {
  return { set: moonbitlang$yacc$lib$lr1$$AbstractLookaheadSet$union$142$(set1.set, set2.set), nullable: set1.nullable || set2.nullable };
}
function moonbitlang$yacc$lib$lr1$$compute_first_fn$142$(grammar) {
  const nt_first_map = moonbitlang$core$array$$Array$make$76$(grammar.nonterminals.length, { set: moonbitlang$yacc$lib$lr1$$_empty, nullable: false });
  const first = (symbols) => {
    if ((symbols.end - symbols.start | 0) === 0) {
      return { set: moonbitlang$yacc$lib$lr1$$_empty, nullable: true };
    } else {
      const _symbol = symbols.buf[symbols.start];
      const _x = { buf: symbols.buf, start: 1 + symbols.start | 0, end: symbols.end };
      let _tmp;
      if (_symbol.$tag === 0) {
        const _T = _symbol;
        const _t = _T._0;
        _tmp = { set: moonbitlang$yacc$lib$lr1$$AbstractLookaheadSet$singleton$142$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(_t)), nullable: false };
      } else {
        const _NT = _symbol;
        const _nt = _NT._0;
        _tmp = moonbitlang$core$array$$Array$at$76$(nt_first_map, _nt.num);
      }
      return moonbitlang$core$builtin$$Add$add$261$(_tmp, first(_x));
    }
  };
  let fixedpoint_reached = false;
  while (true) {
    if (!fixedpoint_reached) {
      fixedpoint_reached = true;
      const _arr = grammar.nonterminals;
      const _len = _arr.length;
      let _tmp = 0;
      while (true) {
        const _i = _tmp;
        if (_i < _len) {
          const nt = _arr[_i];
          const old_set = moonbitlang$core$array$$Array$at$76$(nt_first_map, nt.num);
          const _p = nt.productions;
          const _p$2 = { set: moonbitlang$yacc$lib$lr1$$_empty, nullable: false };
          let new_set;
          let _tmp$2 = 0;
          let _tmp$3 = _p$2;
          while (true) {
            const _p$3 = _tmp$2;
            const _p$4 = _tmp$3;
            if (_p$3 < _p.length) {
              _tmp$2 = _p$3 + 1 | 0;
              const _p$5 = moonbitlang$core$array$$Array$at$34$(_p, _p$3);
              const _p$6 = _p$5.rhs;
              _tmp$3 = moonbitlang$yacc$lib$lr1$$EpsilonLookaheadSet$union$142$(_p$4, first({ buf: _p$6, start: 0, end: _p$6.length }));
              continue;
            } else {
              new_set = _p$4;
              break;
            }
          }
          if (!moonbitlang$core$builtin$$Eq$equal$261$(old_set, new_set)) {
            fixedpoint_reached = false;
            moonbitlang$core$array$$Array$set$76$(nt_first_map, nt.num, new_set);
          }
          _tmp = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      continue;
    } else {
      break;
    }
  }
  return first;
}
function moonbitlang$core$builtin$$Eq$equal$261$(self, other) {
  return moonbitlang$core$builtin$$Eq$equal$142$(self.set, other.set) && self.nullable === other.nullable;
}
function moonbitlang$core$builtin$$Add$add$261$(set1, set2) {
  return set1.nullable ? { set: moonbitlang$yacc$lib$lr1$$AbstractLookaheadSet$union$142$(set1.set, set2.set), nullable: set2.nullable } : set1;
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$empty() {
  return moonbitlang$yacc$lib$util$small_int_set$$_empty;
}
function moonbitlang$core$builtin$$Eq$equal$142$(self, other) {
  return moonbitlang$core$builtin$$Eq$equal$72$(self.concrete_set, other.concrete_set) && moonbitlang$core$builtin$$Eq$equal$260$(self.vars, other.vars);
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$end_of_input() {
  return moonbitlang$yacc$lib$util$small_int_set$$singleton(0);
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$terminal(t) {
  return moonbitlang$yacc$lib$util$small_int_set$$singleton(t.num + 1 | 0);
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$singleton(input) {
  if (input.$tag === 1) {
    const _Input = input;
    const _t = _Input._0;
    return moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$terminal(_t);
  } else {
    return moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$end_of_input();
  }
}
function moonbitlang$yacc$lib$lr1$$AbstractLookaheadSet$singleton$142$(lookahead) {
  return { concrete_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$singleton(lookahead), vars: moonbitlang$yacc$lib$util$small_int_set$$_empty };
}
function moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$variable(var_) {
  return { concrete_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$empty(), vars: moonbitlang$yacc$lib$util$small_int_set$$singleton(var_) };
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$union(self, other) {
  return moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$union(self, other);
}
function moonbitlang$yacc$lib$lr1$$AbstractLookaheadSet$union$142$(self, other) {
  return { concrete_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$union(self.concrete_set, other.concrete_set), vars: moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$union(self.vars, other.vars) };
}
function moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(self, subst) {
  const _p = moonbitlang$core$builtin$$Iter$map$181$(moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$iter(self.vars), (var_) => moonbitlang$core$array$$Array$at$72$(subst, var_));
  const _p$2 = self.concrete_set;
  let _p$3 = _p$2;
  while (true) {
    const _p$4 = moonbitlang$core$builtin$$Iter$next$72$(_p);
    if (_p$4.$tag === 1) {
      const _p$5 = _p$4;
      const _p$6 = _p$5._0;
      _p$3 = moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$union(_p$3, _p$6);
      continue;
    } else {
      break;
    }
  }
  return _p$3;
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode(self, grammar) {
  const production = moonbitlang$core$array$$Array$at$34$(grammar.productions, self >> 10);
  const dot = self & 1023;
  return { production: production, dot: dot };
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$decode_iter(self, grammar) {
  return moonbitlang$core$builtin$$Iter$mapi$223$(moonbitlang$core$array$$Array$iter$79$(self.items), (index, item) => ({ _0: index, _1: moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode(item, grammar) }));
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$decode_iter(self, grammar) {
  return moonbitlang$core$builtin$$Iter$map$182$(moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$iter(self), (t) => t === 0 ? $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput : new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(moonbitlang$core$array$$Array$at$55$(grammar.terminals, t - 1 | 0)));
}
function moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$decode_item_groups(self, grammar) {
  const _p = self.core.closure_symbolic_lookahead_set;
  const _p$2 = new Array(_p.length);
  const _p$3 = _p.length;
  let _tmp = 0;
  while (true) {
    const _p$4 = _tmp;
    if (_p$4 < _p$3) {
      const _p$5 = _p[_p$4];
      _p$2[_p$4] = moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(_p$5, self.kernel_lookahead_set_table);
      _tmp = _p$4 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const lookahead_set_array = _p$2;
  return moonbitlang$core$builtin$$Iter$map$190$(moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$decode_iter(self.core.closure_items, grammar), (item) => {
    const _index = item._0;
    const _item = item._1;
    const lookahead_set = moonbitlang$core$array$$Array$at$72$(lookahead_set_array, _index);
    return { core: _item, lookahead_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$decode_iter(lookahead_set, grammar) };
  });
}
function moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$merge(self, other) {
  const _p = self.core;
  const _p$2 = other.core;
  if (_p.num === _p$2.num) {
    const _tmp = self.core;
    const _p$3 = self.kernel_lookahead_set_table;
    let _tmp$2;
    let _p$4;
    _L: {
      _L$2: {
        if (_p$3.length === 0) {
          const _tmp$3 = [];
          _p$4 = _tmp$3;
          break _L$2;
        }
        const _p$5 = new Array(_p$3.length);
        const _p$6 = _p$3.length;
        let _tmp$3 = 0;
        while (true) {
          const _p$7 = _tmp$3;
          if (_p$7 < _p$6) {
            const _p$8 = _p$3[_p$7];
            _p$5[_p$7] = moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$union(_p$8, moonbitlang$core$array$$Array$at$72$(other.kernel_lookahead_set_table, _p$7));
            _tmp$3 = _p$7 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        _tmp$2 = _p$5;
        break _L;
      }
      _tmp$2 = _p$4;
    }
    return { core: _tmp, kernel_lookahead_set_table: _tmp$2 };
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(self, other) {
  return moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$subset(self, other);
}
function moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$subsume(self, other) {
  const _p = self.core;
  const _p$2 = other.core;
  if (_p.num === _p$2.num) {
    const len = self.kernel_lookahead_set_table.length;
    const self_table = self.kernel_lookahead_set_table;
    const other_table = other.kernel_lookahead_set_table;
    switch (len) {
      case 1: {
        return moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(moonbitlang$core$array$$Array$at$72$(self_table, 0), moonbitlang$core$array$$Array$at$72$(other_table, 0));
      }
      case 2: {
        return moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(moonbitlang$core$array$$Array$at$72$(self_table, 0), moonbitlang$core$array$$Array$at$72$(other_table, 0)) && moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(moonbitlang$core$array$$Array$at$72$(self_table, 1), moonbitlang$core$array$$Array$at$72$(other_table, 1));
      }
      default: {
        let _tmp = 0;
        while (true) {
          const i = _tmp;
          if (i < len) {
            if (!moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(moonbitlang$core$array$$Array$at$72$(self_table, i), moonbitlang$core$array$$Array$at$72$(other_table, i))) {
              return false;
            }
            _tmp = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return true;
      }
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(self, other) {
  return moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$disjoint(self, other);
}
function moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$weak_compat(self, other) {
  const _p = self.core;
  const _p$2 = other.core;
  if (_p.num === _p$2.num) {
    const len = self.kernel_lookahead_set_table.length;
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const la_set1i = moonbitlang$core$array$$Array$at$72$(self.kernel_lookahead_set_table, i);
        const la_set2i = moonbitlang$core$array$$Array$at$72$(other.kernel_lookahead_set_table, i);
        let _tmp$2 = i;
        while (true) {
          const j = _tmp$2;
          if (j < len) {
            _L: {
              if (i !== j) {
                const la_set1j = moonbitlang$core$array$$Array$at$72$(self.kernel_lookahead_set_table, j);
                const la_set2j = moonbitlang$core$array$$Array$at$72$(other.kernel_lookahead_set_table, j);
                const compat = moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(la_set1i, la_set2j) && moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(la_set2i, la_set1j) || (!moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(la_set1i, la_set1j) || !moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(la_set2i, la_set2j));
                if (!compat) {
                  return false;
                }
              } else {
                break _L;
              }
              break _L;
            }
            _tmp$2 = j + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return true;
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$is_singleton(self, key) {
  let _tmp;
  if (key.$tag === 0) {
    _tmp = 0;
  } else {
    const _Input = key;
    const _key = _Input._0;
    _tmp = _key.num + 1 | 0;
  }
  return moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$is_singleton(self, _tmp);
}
function moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$eoi_compact(self, other) {
  const _p = self.core;
  const _p$2 = other.core;
  if (_p.num === _p$2.num) {
    const len = self.kernel_lookahead_set_table.length;
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const la_set1 = moonbitlang$core$array$$Array$at$72$(self.kernel_lookahead_set_table, i);
        const la_set2 = moonbitlang$core$array$$Array$at$72$(other.kernel_lookahead_set_table, i);
        if (moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$is_singleton(la_set1, $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput)) {
          if (!moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$is_singleton(la_set2, $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput)) {
            return false;
          }
        } else {
          if (moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$is_singleton(la_set2, $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput)) {
            if (!moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$is_singleton(la_set1, $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput)) {
              return false;
            }
          }
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return true;
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$Eq$equal$255$(self, other) {
  return moonbitlang$core$builtin$$Eq$equal$234$(self.items, other.items);
}
function moonbitlang$core$builtin$$Hash$hash$255$(self) {
  const _bind = self.hash;
  if (_bind === undefined) {
    const hasher = moonbitlang$core$builtin$$Hasher$new(undefined);
    const _arr = self.items;
    const _len = _arr.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const item = _arr[_i];
        moonbitlang$core$builtin$$Hasher$combine_int(hasher, item);
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const hash = moonbitlang$core$builtin$$Hasher$finalize(hasher);
    self.hash = hash;
    return hash;
  } else {
    const _Some = _bind;
    return _Some;
  }
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$from_sorted_array(items) {
  return { items: items, hash: undefined };
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_production(self, grammar) {
  return moonbitlang$core$array$$Array$at$34$(grammar.productions, self >> 10);
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_postdot(self, grammar) {
  const production = moonbitlang$core$array$$Array$at$34$(grammar.productions, self >> 10);
  const dot = self & 1023;
  return moonbitlang$core$array$$Array$get$54$(production.rhs, dot);
}
function moonbitlang$yacc$lib$lr1$$build_closure_fn$46$visit$47$8686(_env, node, lookahead_set, parent) {
  const stamp = _env._1;
  if (lookahead_set.nullable) {
    const _p = node.predecessors;
    node.predecessors = new $64$moonbitlang$47$core$47$list$46$List$More$11$(parent, _p);
  }
  const _p = node.stamp;
  if (_p === stamp) {
    node.lookahead_set = moonbitlang$yacc$lib$lr1$$AbstractLookaheadSet$union$142$(node.lookahead_set, lookahead_set.set);
    return;
  } else {
    node.lookahead_set = lookahead_set.set;
    moonbitlang$yacc$lib$lr1$$build_closure_fn$46$follow$47$8687(_env, node);
    return;
  }
}
function moonbitlang$yacc$lib$lr1$$build_closure_fn$46$follow$47$8687(_env, node) {
  const stamp = _env._1;
  const nodes = _env._0;
  node.stamp = stamp;
  moonbitlang$core$array$$Array$push$140$(nodes, node);
  const _arr = node.epsilon_transitions;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const epsilon_transition = _arr[_i];
      moonbitlang$yacc$lib$lr1$$build_closure_fn$46$visit$47$8686(_env, epsilon_transition, node.partial_lookahead_set, node);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$yacc$lib$lr1$$build_closure_fn$46$walk$47$8688(stamp, node) {
  if (moonbitlang$core$builtin$$Eq$not_equal$82$(node.stamp, stamp)) {
    node.stamp = stamp;
    const _it = moonbitlang$core$list$$List$iter$140$(node.predecessors);
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$140$(_it);
      if (_bind === undefined) {
        return;
      } else {
        const _Some = _bind;
        const _predecessor = _Some;
        moonbitlang$yacc$lib$lr1$$build_closure_fn$46$walk$47$8688(stamp, _predecessor);
        node.lookahead_set = moonbitlang$yacc$lib$lr1$$AbstractLookaheadSet$union$142$(node.lookahead_set, _predecessor.lookahead_set);
        continue;
      }
    }
  } else {
    return;
  }
}
function moonbitlang$yacc$lib$lr1$$build_closure_fn$142$(grammar) {
  const first = moonbitlang$yacc$lib$lr1$$compute_first_fn$142$(grammar);
  const node_by_item = moonbitlang$yacc$lib$util$hashmap2$$new$250$(16);
  const _arr = grammar.productions;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const production = _arr[_i];
      const _end175 = production.rhs.length;
      let _tmp$2 = 0;
      while (true) {
        const dot = _tmp$2;
        if (dot <= _end175) {
          const item = production.num << 10 | dot;
          const partial_lookahead_set = dot < production.rhs.length ? first(moonbitlang$core$array$$Array$sub$46$inner$54$(production.rhs, dot + 1 | 0, undefined)) : { set: moonbitlang$yacc$lib$lr1$$_empty, nullable: false };
          const node = { item: item, partial_lookahead_set: partial_lookahead_set, epsilon_transitions: [], stamp: moonbitlang$yacc$lib$util$stamp$$initial_stamp, predecessors: $64$moonbitlang$47$core$47$list$46$List$Empty$11$, lookahead_set: moonbitlang$yacc$lib$lr1$$_empty };
          moonbitlang$yacc$lib$util$hashmap2$$T$set$250$(node_by_item, item, node);
          _tmp$2 = dot + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _it = moonbitlang$yacc$lib$util$hashmap2$$T$iter$250$(node_by_item);
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$167$(_it);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _pair = _Some;
      const node = _pair._1;
      const _bind$2 = moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_postdot(node.item, grammar);
      if (_bind$2 === undefined) {
      } else {
        const _Some$2 = _bind$2;
        const _x = _Some$2;
        if (_x.$tag === 0) {
        } else {
          const _NT = _x;
          const _nt = _NT._0;
          const _arr$2 = _nt.productions;
          const _len$2 = _arr$2.length;
          let _tmp$2 = 0;
          while (true) {
            const _i = _tmp$2;
            if (_i < _len$2) {
              const production = _arr$2[_i];
              const _p = 0;
              const encoded_item = production.num << 10 | _p;
              const _tmp$3 = node.epsilon_transitions;
              const _p$2 = moonbitlang$yacc$lib$util$hashmap2$$T$get$250$(node_by_item, encoded_item);
              let _tmp$4;
              if (_p$2 === undefined) {
                _tmp$4 = $panic();
              } else {
                const _p$3 = _p$2;
                _tmp$4 = _p$3;
              }
              moonbitlang$core$array$$Array$push$140$(_tmp$3, _tmp$4);
              _tmp$2 = _i + 1 | 0;
              continue;
            } else {
              break;
            }
          }
        }
      }
      continue;
    }
  }
  return (item_set) => {
    const stamp = moonbitlang$yacc$lib$util$stamp$$new();
    const nodes = [];
    const _env = { _0: nodes, _1: stamp };
    while (true) {
      const _bind = moonbitlang$core$builtin$$Iter$next$41$(item_set);
      if (_bind === undefined) {
        break;
      } else {
        const _Some = _bind;
        const _item = _Some;
        const _item$2 = _item._0;
        const _lookahead_set = _item._1;
        const _p = moonbitlang$yacc$lib$util$hashmap2$$T$get$250$(node_by_item, _item$2);
        let node;
        if (_p === undefined) {
          node = $panic();
        } else {
          const _p$2 = _p;
          node = _p$2;
        }
        node.lookahead_set = _lookahead_set;
        moonbitlang$yacc$lib$lr1$$build_closure_fn$46$follow$47$8687(_env, node);
        continue;
      }
    }
    const stamp$2 = moonbitlang$yacc$lib$util$stamp$$new();
    const _len$2 = nodes.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len$2) {
        const node = nodes[_i];
        moonbitlang$yacc$lib$lr1$$build_closure_fn$46$walk$47$8688(stamp$2, node);
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _p = new Array(nodes.length);
    const _p$2 = nodes.length;
    let _tmp$3 = 0;
    while (true) {
      const _p$3 = _tmp$3;
      if (_p$3 < _p$2) {
        const _p$4 = nodes[_p$3];
        _p[_p$3] = { _0: _p$4.item, _1: _p$4.lookahead_set };
        _tmp$3 = _p$3 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const closure = _p;
    const _len$3 = nodes.length;
    let _tmp$4 = 0;
    while (true) {
      const _i = _tmp$4;
      if (_i < _len$3) {
        const node = nodes[_i];
        node.predecessors = $64$moonbitlang$47$core$47$list$46$List$Empty$11$;
        node.lookahead_set = moonbitlang$yacc$lib$lr1$$_empty;
        _tmp$4 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$array$$Array$sort_by_key$233$(closure, (pair) => pair._0);
    return closure;
  };
}
function moonbitlang$core$builtin$$Show$output$124$(self, logger) {
  logger.method_table.method_0(logger.self, "[");
  moonbitlang$core$builtin$$Logger$write_object$17$(logger, self.core.production.num);
  logger.method_table.method_0(logger.self, ", ");
  moonbitlang$yacc$lib$grm$$Production$output_with_opt_dot$259$(self.core.production, logger, self.core.dot);
  logger.method_table.method_0(logger.self, ", ");
  let first = true;
  const _it = self.lookahead_set;
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$52$(_it);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _lookahead = _Some;
      if (!first) {
        logger.method_table.method_0(logger.self, " / ");
      }
      moonbitlang$core$builtin$$Logger$write_object$52$(logger, _lookahead);
      first = false;
      continue;
    }
  }
  logger.method_table.method_0(logger.self, "]");
}
function moonbitlang$core$builtin$$Hash$hash_combine$134$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self.num);
}
function moonbitlang$yacc$lib$lr1$$LR1State$iter_item_groups(self) {
  return moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$decode_item_groups(self.items, self.grammar);
}
function moonbitlang$yacc$lib$lr1$$LR1State$set_action(self, input, decision) {
  const _bind = moonbitlang$core$sorted_map$$SortedMap$get$226$(self.action, input);
  if (_bind === undefined) {
    moonbitlang$core$sorted_map$$SortedMap$set$226$(self.action, input, decision);
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 3) {
      const _Conflict = _x;
      const _decisions = _Conflict._0;
      if (!moonbitlang$core$list$$List$contains$86$(_decisions, decision)) {
        moonbitlang$core$sorted_map$$SortedMap$set$226$(self.action, input, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Conflict(new $64$moonbitlang$47$core$47$list$46$List$More$12$(decision, _decisions)));
        return;
      } else {
        return;
      }
    } else {
      if (moonbitlang$core$builtin$$Eq$not_equal$85$(_x, decision)) {
        const _tmp = self.action;
        const _p = $64$moonbitlang$47$core$47$list$46$List$Empty$12$;
        const _p$2 = new $64$moonbitlang$47$core$47$list$46$List$More$12$(_x, _p);
        moonbitlang$core$sorted_map$$SortedMap$set$226$(_tmp, input, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Conflict(new $64$moonbitlang$47$core$47$list$46$List$More$12$(decision, _p$2)));
        return;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$yacc$lib$lr1$$build$46$explore$124$10(_env, kernel_items) {
  const grammar = _env._4;
  const node_by_kernel_items = _env._3;
  const node_reductions = _env._2;
  const closure = _env._1;
  const node_transitions = _env._0;
  const defer_ = { val: Option$None$56$ };
  const node = moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$249$(node_by_kernel_items, kernel_items, (kernel_items$2) => {
    const _p = kernel_items$2.items;
    let _tmp;
    let _p$2;
    _L: {
      _L$2: {
        if (_p.length === 0) {
          const _tmp$2 = [];
          _p$2 = _tmp$2;
          break _L$2;
        }
        const _p$3 = new Array(_p.length);
        const _p$4 = _p.length;
        let _tmp$2 = 0;
        while (true) {
          const _p$5 = _tmp$2;
          if (_p$5 < _p$4) {
            const _p$6 = _p[_p$5];
            _p$3[_p$5] = { _0: _p$6, _1: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$variable(_p$5) };
            _tmp$2 = _p$5 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        _tmp = _p$3;
        break _L;
      }
      _tmp = _p$2;
    }
    const symbolic_items = closure(moonbitlang$core$array$$Array$iter$41$(_tmp));
    const _tmp$2 = node_by_kernel_items.size;
    const _p$3 = new Array(symbolic_items.length);
    const _p$4 = symbolic_items.length;
    let _tmp$3 = 0;
    while (true) {
      const _p$5 = _tmp$3;
      if (_p$5 < _p$4) {
        const _p$6 = symbolic_items[_p$5];
        _p$3[_p$5] = _p$6._0;
        _tmp$3 = _p$5 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _tmp$4 = moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$from_sorted_array(_p$3);
    const _p$5 = new Array(symbolic_items.length);
    const _p$6 = symbolic_items.length;
    let _tmp$5 = 0;
    while (true) {
      const _p$7 = _tmp$5;
      if (_p$7 < _p$6) {
        const _p$8 = symbolic_items[_p$7];
        _p$5[_p$7] = _p$8._1;
        _tmp$5 = _p$7 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const node$2 = { num: _tmp$2, closure_items: _tmp$4, closure_symbolic_lookahead_set: _p$5 };
    defer_.val = new Option$Some$56$(symbolic_items);
    return node$2;
  });
  const _bind = defer_.val;
  if (_bind.$tag === 1) {
    const _Some = _bind;
    const _symbolic_items = _Some._0;
    const result = [];
    const _len = _symbolic_items.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const symbolic_item = _symbolic_items[_i];
        const _item = symbolic_item._0;
        const _symbolic_lookahead_set = symbolic_item._1;
        const _bind$2 = moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_postdot(_item, grammar);
        if (_bind$2 === undefined) {
          moonbitlang$core$array$$Array$push$141$(result, { _0: _symbolic_lookahead_set, _1: moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_production(_item, grammar) });
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$array$$Array$push$69$(node_reductions, result);
    moonbitlang$core$array$$Array$push$68$(node_transitions, moonbitlang$yacc$lib$util$hashmap2$$new$251$(16));
    const trans = moonbitlang$yacc$lib$util$hashmap2$$new$252$(16);
    const _len$2 = _symbolic_items.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len$2) {
        const entry = _symbolic_items[_i];
        const _item = entry._0;
        const _symbolic_lookahead_set = entry._1;
        const _bind$2 = moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_postdot(_item, grammar);
        if (_bind$2 === undefined) {
        } else {
          const _Some$2 = _bind$2;
          const _symbol = _Some$2;
          const next_item = _item + 1 | 0;
          const _bind$3 = moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$252$(trans, _symbol, (_arg) => ({ _0: [], _1: [] }));
          const _kernel_items = _bind$3._0;
          const _symbolic_lookahead_set_table = _bind$3._1;
          moonbitlang$core$array$$Array$push$79$(_kernel_items, next_item);
          moonbitlang$core$array$$Array$push$142$(_symbolic_lookahead_set_table, _symbolic_lookahead_set);
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _it = moonbitlang$yacc$lib$util$hashmap2$$T$iter$252$(trans);
    while (true) {
      const _bind$2 = moonbitlang$core$builtin$$Iter$next$168$(_it);
      if (_bind$2 === undefined) {
        break;
      } else {
        const _Some$2 = _bind$2;
        const _tran = _Some$2;
        const _symbol = _tran._0;
        const _x = _tran._1;
        const _kernel_items = _x._0;
        const _kernel_symbolic_lookahead_set_table = _x._1;
        const target = moonbitlang$yacc$lib$lr1$$build$46$explore$124$10(_env, moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$from_sorted_array(_kernel_items));
        moonbitlang$yacc$lib$util$hashmap2$$T$set$251$(moonbitlang$core$array$$Array$at$68$(node_transitions, node.num), _symbol, { _0: target, _1: _kernel_symbolic_lookahead_set_table });
        continue;
      }
    }
  }
  return node;
}
function moonbitlang$yacc$lib$lr1$$build$46$fuse$124$65(_env, family, candidate) {
  const queue = _env._1;
  const user_eoi = _env._0;
  let _tmp = candidate;
  _L: while (true) {
    const candidate$2 = _tmp;
    const _len = family.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len) {
        const state = family[_i];
        if (moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$weak_compat(state.items, candidate$2.items) && (user_eoi ? moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$eoi_compact(state.items, candidate$2.items) : true)) {
          const new_state = { items: moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$merge(candidate$2.items, state.items), state: undefined };
          const _p = family.length;
          let _bind;
          let _tmp$3 = 0;
          while (true) {
            const _p$2 = _tmp$3;
            if (_p$2 < _p) {
              const _p$3 = family[_p$2];
              if (_p$3 === state) {
                _bind = _p$2;
                break;
              }
              _tmp$3 = _p$2 + 1 | 0;
              continue;
            } else {
              _bind = undefined;
              break;
            }
          }
          if (_bind === undefined) {
          } else {
            const _Some = _bind;
            const _index = _Some;
            moonbitlang$core$array$$Array$remove$23$(family, _index);
          }
          _tmp = new_state;
          continue _L;
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        moonbitlang$core$array$$Array$push$23$(family, candidate$2);
        moonbitlang$core$array$$Array$push$23$(queue, candidate$2);
        return;
      }
    }
  }
}
function moonbitlang$yacc$lib$lr1$$build$46$state_from_pre$124$91(_env, pre_state) {
  const grammar = _env._1;
  const next_state_num = _env._0;
  const _bind = pre_state.state;
  if (_bind === undefined) {
    const state = { grammar: grammar, num: next_state_num.val, items: pre_state.items, goto: moonbitlang$core$sorted_map$$SortedMap$new$227$(), action: moonbitlang$core$sorted_map$$SortedMap$new$226$(), stamp: moonbitlang$yacc$lib$util$stamp$$initial_stamp };
    next_state_num.val = next_state_num.val + 1 | 0;
    pre_state.state = state;
    return state;
  } else {
    const _Some = _bind;
    return _Some;
  }
}
function moonbitlang$yacc$lib$lr1$$build$46$check_add_conflict$124$124(conflicts, state, input) {
  const _bind = moonbitlang$core$sorted_map$$SortedMap$get$226$(state.action, input);
  if (_bind === undefined) {
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 3) {
      const _Conflict = _x;
      const _decisions = _Conflict._0;
      moonbitlang$yacc$lib$util$hashmap2$$T$set$128$(conflicts, { state: state, input: input }, _decisions);
      return;
    } else {
      return;
    }
  }
}
function moonbitlang$yacc$lib$lr1$$Automaton$build(grammar, user_eoi) {
  const closure = moonbitlang$yacc$lib$lr1$$build_closure_fn$142$(grammar);
  const node_by_kernel_items = moonbitlang$yacc$lib$util$hashmap2$$new$249$(65536);
  const node_transitions = [];
  const node_reductions = [];
  const node_starts = [];
  const _env = { _0: node_transitions, _1: closure, _2: node_reductions, _3: node_by_kernel_items, _4: grammar };
  const _arr = grammar.starts;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const start_production = _arr[_i];
      const _p = 0;
      moonbitlang$core$array$$Array$push$132$(node_starts, { _0: moonbitlang$yacc$lib$lr1$$build$46$explore$124$10(_env, moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$from_sorted_array([start_production.num << 10 | _p])), _1: start_production });
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const next_state_num = { val: 0 };
  const starts = [];
  const _p = node_by_kernel_items.size;
  let families;
  if (_p <= 0) {
    families = [];
  } else {
    const _p$2 = $make_array_len_and_init(_p, []);
    let _tmp$2 = 1;
    while (true) {
      const _p$3 = _tmp$2;
      if (_p$3 < _p) {
        $bound_check(_p$2, _p$3);
        _p$2[_p$3] = [];
        _tmp$2 = _p$3 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    families = _p$2;
  }
  const queue = [];
  const _len$2 = node_starts.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const entry = node_starts[_i];
      const _node = entry._0;
      const _start_production = entry._1;
      const start_state = { items: { core: _node, kernel_lookahead_set_table: [moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$end_of_input()] }, state: undefined };
      const _tmp$3 = start_state.items.core.num;
      $bound_check(families, _tmp$3);
      moonbitlang$core$array$$Array$push$23$(families[_tmp$3], start_state);
      moonbitlang$core$array$$Array$push$133$(starts, { _0: _start_production, _1: start_state });
      moonbitlang$core$array$$Array$push$23$(queue, start_state);
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _env$2 = { _0: user_eoi, _1: queue };
  while (true) {
    if (!(queue.length === 0)) {
      const state = moonbitlang$core$array$$Array$unsafe_pop$23$(queue);
      const trans = moonbitlang$core$array$$Array$at$68$(node_transitions, state.items.core.num);
      const _it = moonbitlang$yacc$lib$util$hashmap2$$T$iter$251$(trans);
      while (true) {
        const _bind = moonbitlang$core$builtin$$Iter$next$162$(_it);
        if (_bind === undefined) {
          break;
        } else {
          const _Some = _bind;
          const _entry = _Some;
          const _x = _entry._1;
          const _target_node = _x._0;
          const _kernel_symbolic_lookahead_set_array = _x._1;
          const _p$2 = new Array(_kernel_symbolic_lookahead_set_array.length);
          const _p$3 = _kernel_symbolic_lookahead_set_array.length;
          let _tmp$3 = 0;
          while (true) {
            const _p$4 = _tmp$3;
            if (_p$4 < _p$3) {
              const _p$5 = _kernel_symbolic_lookahead_set_array[_p$4];
              _p$2[_p$4] = moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(_p$5, state.items.kernel_lookahead_set_table);
              _tmp$3 = _p$4 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          const kernel_lookahead_set_table = _p$2;
          const target_state = { items: { core: _target_node, kernel_lookahead_set_table: kernel_lookahead_set_table }, state: undefined };
          let _return_value;
          _L: {
            _L$2: {
              const _tmp$4 = target_state.items.core.num;
              $bound_check(families, _tmp$4);
              const family = families[_tmp$4];
              const _len$3 = family.length;
              let _tmp$5 = 0;
              while (true) {
                const _i = _tmp$5;
                if (_i < _len$3) {
                  const state$2 = family[_i];
                  if (moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$subsume(target_state.items, state$2.items)) {
                    _return_value = undefined;
                    break _L$2;
                  }
                  _tmp$5 = _i + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              moonbitlang$yacc$lib$lr1$$build$46$fuse$124$65(_env$2, family, target_state);
              break _L;
            }
          }
          continue;
        }
      }
      continue;
    } else {
      break;
    }
  }
  const states = [];
  const _env$3 = { _0: next_state_num, _1: grammar };
  const queue$2 = [];
  const _len$3 = starts.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$3) {
      const entry = starts[_i];
      const _pre_state = entry._1;
      moonbitlang$core$array$$Array$push$134$(queue$2, moonbitlang$yacc$lib$lr1$$build$46$state_from_pre$124$91(_env$3, _pre_state));
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const stamp = moonbitlang$yacc$lib$util$stamp$$new();
  while (true) {
    if (!(queue$2.length === 0)) {
      const state = moonbitlang$core$array$$Array$unsafe_pop$134$(queue$2);
      const _p$2 = state.stamp;
      if (_p$2 === stamp) {
        continue;
      }
      state.stamp = stamp;
      moonbitlang$core$array$$Array$push$134$(states, state);
      const trans = moonbitlang$core$array$$Array$at$68$(node_transitions, state.items.core.num);
      const _it = moonbitlang$yacc$lib$util$hashmap2$$T$iter$251$(trans);
      while (true) {
        const _bind = moonbitlang$core$builtin$$Iter$next$162$(_it);
        if (_bind === undefined) {
          break;
        } else {
          const _Some = _bind;
          const _entry = _Some;
          const _symbol = _entry._0;
          const _x = _entry._1;
          const _target_node = _x._0;
          const _symbolic_lookahead_set_array = _x._1;
          const _tmp$4 = _target_node.num;
          $bound_check(families, _tmp$4);
          const family = families[_tmp$4];
          let pre_state;
          if (family.length === 0) {
            pre_state = $panic();
          } else {
            if (family.length === 1) {
              pre_state = family[0];
            } else {
              const _p$3 = new Array(_symbolic_lookahead_set_array.length);
              const _p$4 = _symbolic_lookahead_set_array.length;
              let _tmp$5 = 0;
              while (true) {
                const _p$5 = _tmp$5;
                if (_p$5 < _p$4) {
                  const _p$6 = _symbolic_lookahead_set_array[_p$5];
                  _p$3[_p$5] = moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(_p$6, state.items.kernel_lookahead_set_table);
                  _tmp$5 = _p$5 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              const kernel_lookahead_set_table = _p$3;
              const next_items = { core: _target_node, kernel_lookahead_set_table: kernel_lookahead_set_table };
              const _p$5 = moonbitlang$core$builtin$$Iter$find_first$23$(moonbitlang$core$array$$Array$iter$23$(family), (state$2) => moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$subsume(next_items, state$2.items));
              if (_p$5 === undefined) {
                pre_state = $panic();
              } else {
                const _p$6 = _p$5;
                pre_state = _p$6;
              }
            }
          }
          const target_state = moonbitlang$yacc$lib$lr1$$build$46$state_from_pre$124$91(_env$3, pre_state);
          moonbitlang$core$sorted_map$$SortedMap$set$227$(state.goto, _symbol, target_state);
          if (moonbitlang$core$builtin$$Eq$not_equal$82$(target_state.stamp, stamp)) {
            moonbitlang$core$array$$Array$push$134$(queue$2, target_state);
          }
          continue;
        }
      }
      continue;
    } else {
      break;
    }
  }
  const _len$4 = states.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$4) {
      const state = states[_i];
      state.num = _i;
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const conflicts = moonbitlang$yacc$lib$util$hashmap2$$new$128$(16);
  const _len$5 = states.length;
  let _tmp$5 = 0;
  while (true) {
    const _i = _tmp$5;
    if (_i < _len$5) {
      const state = states[_i];
      const core = state.items.core;
      const _it = moonbitlang$yacc$lib$util$hashmap2$$T$iter$251$(moonbitlang$core$array$$Array$at$68$(node_transitions, core.num));
      while (true) {
        const _bind = moonbitlang$core$builtin$$Iter$next$162$(_it);
        if (_bind === undefined) {
          break;
        } else {
          const _Some = _bind;
          const _tran = _Some;
          const _symbol = _tran._0;
          if (_symbol.$tag === 1) {
          } else {
            const _T = _symbol;
            const _term = _T._0;
            const _tmp$6 = new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(_term);
            const _p$2 = moonbitlang$core$sorted_map$$SortedMap$get$227$(state.goto, new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$T(_term));
            let _tmp$7;
            if (_p$2 === undefined) {
              _tmp$7 = $panic();
            } else {
              const _p$3 = _p$2;
              _tmp$7 = _p$3;
            }
            moonbitlang$yacc$lib$lr1$$LR1State$set_action(state, _tmp$6, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(_tmp$7));
            moonbitlang$yacc$lib$lr1$$build$46$check_add_conflict$124$124(conflicts, state, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(_term));
          }
          continue;
        }
      }
      const _arr$2 = moonbitlang$core$array$$Array$at$69$(node_reductions, core.num);
      const _len$6 = _arr$2.length;
      let _tmp$6 = 0;
      while (true) {
        const _i$2 = _tmp$6;
        if (_i$2 < _len$6) {
          const reduction = _arr$2[_i$2];
          const _symbolic_lookahead_set = reduction._0;
          const _production = reduction._1;
          const lookahead_set = moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(_symbolic_lookahead_set, state.items.kernel_lookahead_set_table);
          const _it$2 = moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$decode_iter(core.closure_items, grammar);
          while (true) {
            const _bind = moonbitlang$core$builtin$$Iter$next$163$(_it$2);
            if (_bind === undefined) {
              break;
            } else {
              const _Some = _bind;
              const _item = _Some;
              const _it$3 = moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$decode_iter(lookahead_set, grammar);
              while (true) {
                const _bind$2 = moonbitlang$core$builtin$$Iter$next$52$(_it$3);
                if (_bind$2 === undefined) {
                  break;
                } else {
                  const _Some$2 = _bind$2;
                  const _lookahead = _Some$2;
                  if (moonbitlang$core$builtin$$Eq$equal$52$(_lookahead, $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput) && (moonbitlang$core$array$$Array$contains$34$(grammar.starts, _production) && _item._1.dot === 1)) {
                    moonbitlang$yacc$lib$lr1$$LR1State$set_action(state, _lookahead, $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Accept);
                  } else {
                    moonbitlang$yacc$lib$lr1$$LR1State$set_action(state, _lookahead, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(_production));
                  }
                  moonbitlang$yacc$lib$lr1$$build$46$check_add_conflict$124$124(conflicts, state, _lookahead);
                  continue;
                }
              }
              continue;
            }
          }
          _tmp$6 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp$5 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _p$2 = new Array(starts.length);
  const _p$3 = starts.length;
  let _tmp$6 = 0;
  while (true) {
    const _p$4 = _tmp$6;
    if (_p$4 < _p$3) {
      const _p$5 = starts[_p$4];
      const _p$6 = _p$5._0;
      const _p$7 = _p$5._1;
      _p$2[_p$4] = { _0: _p$6, _1: moonbitlang$yacc$lib$lr1$$build$46$state_from_pre$124$91(_env$3, _p$7) };
      _tmp$6 = _p$4 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const starts$2 = _p$2;
  return { states: states, starts: starts$2, conflicts: conflicts };
}
function moonbitlang$yacc$lib$util$logger_with_cursor$$new$46$inner(logger, cursor) {
  return { logger: logger, cursor: cursor };
}
function moonbitlang$core$builtin$$Logger$write_char$5$(self, char) {
  const _tmp = self.logger;
  _tmp.method_table.method_3(_tmp.self, char);
  self.cursor = self.cursor + 1 | 0;
}
function moonbitlang$core$builtin$$Logger$write_string$5$(self, str) {
  const _tmp = self.logger;
  _tmp.method_table.method_0(_tmp.self, str);
  self.cursor = self.cursor + str.length | 0;
}
function moonbitlang$core$builtin$$Logger$write_view$5$(self, view) {
  const _tmp = self.logger;
  _tmp.method_table.method_2(_tmp.self, view);
  self.cursor = self.cursor + (view.end - view.start | 0) | 0;
}
function moonbitlang$core$builtin$$ToJson$to_json$130$(_x_17) {
  const _bind = [];
  const $36$map = moonbitlang$core$builtin$$Map$from_array$218$({ buf: _bind, start: 0, end: 0 });
  const _p = _x_17.source;
  moonbitlang$core$builtin$$Map$set$218$($36$map, "source", new $64$moonbitlang$47$core$47$builtin$46$Json$String(_p));
  moonbitlang$core$builtin$$Map$set$218$($36$map, "original_offset", moonbitlang$core$builtin$$ToJson$to_json$17$(_x_17.original_offset));
  moonbitlang$core$builtin$$Map$set$218$($36$map, "generated_offset", moonbitlang$core$builtin$$ToJson$to_json$17$(_x_17.generated_offset));
  moonbitlang$core$builtin$$Map$set$218$($36$map, "length", moonbitlang$core$builtin$$ToJson$to_json$17$(_x_17.length));
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Object($36$map);
}
function moonbitlang$core$builtin$$ToJson$to_json$0$(_x_14) {
  const _bind = [];
  const $36$map = moonbitlang$core$builtin$$Map$from_array$218$({ buf: _bind, start: 0, end: 0 });
  moonbitlang$core$builtin$$Map$set$218$($36$map, "mappings", moonbitlang$core$builtin$$ToJson$to_json$222$(_x_14.mappings));
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Object($36$map);
}
function moonbitlang$yacc$lib$codegen$$SourceMap$new() {
  return { mappings: [] };
}
function moonbitlang$yacc$lib$codegen$$SourceMapBuilder$add_mapping$0$(self, source, original_offset_in_utf8, generated_offset_in_utf8, length_in_utf8) {
  moonbitlang$core$array$$Array$push$130$(self.mappings, { source: source, original_offset: original_offset_in_utf8, generated_offset: generated_offset_in_utf8, length: length_in_utf8 });
}
function moonbitlang$yacc$lib$util$default_hashmap$$new$254$(default_fn) {
  return { map: moonbitlang$yacc$lib$util$hashmap2$$new$254$(16), default_fn: default_fn };
}
function moonbitlang$yacc$lib$util$default_hashmap$$DefaultHashMap$get$254$(self, key) {
  return moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$254$(self.map, key, (key$2) => {
    const _func = self.default_fn;
    return _func(key$2);
  });
}
function moonbitlang$core$builtin$$Eq$equal$74$(_x_337, _x_338) {
  switch (_x_337.$tag) {
    case 0: {
      if (_x_338.$tag === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      const _Shift = _x_337;
      const _$42$x0_339 = _Shift._0;
      if (_x_338.$tag === 1) {
        const _Shift$2 = _x_338;
        const _$42$y0_340 = _Shift$2._0;
        return _$42$x0_339 === _$42$y0_340;
      } else {
        return false;
      }
    }
    case 2: {
      const _Reduce = _x_337;
      const _$42$x0_341 = _Reduce._0;
      const _$42$x1_342 = _Reduce._1;
      const _$42$x2_343 = _Reduce._2;
      if (_x_338.$tag === 2) {
        const _Reduce$2 = _x_338;
        const _$42$y0_344 = _Reduce$2._0;
        const _$42$y1_345 = _Reduce$2._1;
        const _$42$y2_346 = _Reduce$2._2;
        return _$42$x0_341 === _$42$y0_344 && (_$42$x1_342.num === _$42$y1_345.num && _$42$x2_343 === _$42$y2_346);
      } else {
        return false;
      }
    }
    default: {
      const _ReduceNoLookahead = _x_337;
      const _$42$x0_347 = _ReduceNoLookahead._0;
      const _$42$x1_348 = _ReduceNoLookahead._1;
      const _$42$x2_349 = _ReduceNoLookahead._2;
      if (_x_338.$tag === 3) {
        const _ReduceNoLookahead$2 = _x_338;
        const _$42$y0_350 = _ReduceNoLookahead$2._0;
        const _$42$y1_351 = _ReduceNoLookahead$2._1;
        const _$42$y2_352 = _ReduceNoLookahead$2._2;
        return _$42$x0_347 === _$42$y0_350 && (_$42$x1_348.num === _$42$y1_351.num && _$42$x2_349 === _$42$y2_352);
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$74$(_x_297, _x_298) {
  switch (_x_297.$tag) {
    case 0: {
      if (_x_298.$tag === 0) {
        return 0;
      } else {
        return -1;
      }
    }
    case 1: {
      const _Shift = _x_297;
      const _$42$x0_299 = _Shift._0;
      switch (_x_298.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          const _Shift$2 = _x_298;
          const _$42$y0_300 = _Shift$2._0;
          return $compare_int(_$42$x0_299, _$42$y0_300);
        }
        default: {
          return -1;
        }
      }
    }
    case 2: {
      const _Reduce = _x_297;
      const _$42$x0_301 = _Reduce._0;
      const _$42$x1_302 = _Reduce._1;
      const _$42$x2_303 = _Reduce._2;
      switch (_x_298.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          const _Reduce$2 = _x_298;
          const _$42$y0_304 = _Reduce$2._0;
          const _$42$y1_305 = _Reduce$2._1;
          const _$42$y2_306 = _Reduce$2._2;
          const _bind = $compare_int(_$42$x0_301, _$42$y0_304);
          if (_bind === 0) {
            const _bind$2 = $compare_int(_$42$x1_302.num, _$42$y1_305.num);
            if (_bind$2 === 0) {
              return $compare_int(_$42$x2_303, _$42$y2_306);
            } else {
              return _bind$2;
            }
          } else {
            return _bind;
          }
        }
        default: {
          return -1;
        }
      }
    }
    default: {
      const _ReduceNoLookahead = _x_297;
      const _$42$x0_309 = _ReduceNoLookahead._0;
      const _$42$x1_310 = _ReduceNoLookahead._1;
      const _$42$x2_311 = _ReduceNoLookahead._2;
      switch (_x_298.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        default: {
          const _ReduceNoLookahead$2 = _x_298;
          const _$42$y0_312 = _ReduceNoLookahead$2._0;
          const _$42$y1_313 = _ReduceNoLookahead$2._1;
          const _$42$y2_314 = _ReduceNoLookahead$2._2;
          const _bind$2 = $compare_int(_$42$x0_309, _$42$y0_312);
          if (_bind$2 === 0) {
            const _bind$3 = $compare_int(_$42$x1_310.num, _$42$y1_313.num);
            if (_bind$3 === 0) {
              return $compare_int(_$42$x2_311, _$42$y2_314);
            } else {
              return _bind$3;
            }
          } else {
            return _bind$2;
          }
        }
      }
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$176$(_x_273, _x_274) {
  switch (_x_273.$tag) {
    case 0: {
      const _T = _x_273;
      const _$42$x0_275 = _T._0;
      if (_x_274.$tag === 0) {
        const _T$2 = _x_274;
        const _$42$y0_276 = _T$2._0;
        return $compare_int(_$42$x0_275.num, _$42$y0_276.num);
      } else {
        return -1;
      }
    }
    case 1: {
      const _NT = _x_273;
      const _$42$x0_277 = _NT._0;
      switch (_x_274.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          const _NT$2 = _x_274;
          const _$42$y0_278 = _NT$2._0;
          return $compare_int(_$42$x0_277.num, _$42$y0_278.num);
        }
        default: {
          return -1;
        }
      }
    }
    default: {
      switch (_x_274.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        default: {
          return 0;
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident(nont) {
  const name = nont.name;
  return moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(name, { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$478, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$478.length }, { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$479, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$479.length }), { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$480, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$480.length }, { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$481, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$481.length }), { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$482, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$482.length }, { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$483, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$483.length }), { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$484, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$484.length }, { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$485, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident$46$42$bind$124$485.length });
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$CodegenSymbol$to_string(self) {
  switch (self.$tag) {
    case 0: {
      const _T = self;
      const _t = _T._0;
      return `T_${_t.name}`;
    }
    case 1: {
      const _NT = self;
      const _nt = _NT._0;
      return `NT_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident(_nt)}`;
    }
    default: {
      return "EOI";
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(type_) {
  switch (type_.$tag) {
    case 0: {
      const _Constr = type_;
      const _pkg = _Constr._0;
      const _name = _Constr._1;
      const _args = _Constr._2;
      let primary;
      if (_pkg === undefined) {
        primary = _name;
      } else {
        const _Some = _pkg;
        const _pkg$2 = _Some;
        const pkg2 = moonbitlang$core$string$$String$replace_all(_pkg$2, { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident$46$42$bind$124$493, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident$46$42$bind$124$493.length }, { str: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident$46$42$bind$124$494, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident$46$42$bind$124$494.length });
        primary = `_${pkg2}_${_name}`;
      }
      return _args.length === 0 ? primary : `${primary}_${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$188$(moonbitlang$core$array$$Array$iter$75$(_args), moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident), "__")}_`;
    }
    case 1: {
      return $panic();
    }
    case 2: {
      const _Option = type_;
      const _type_ = _Option._0;
      if (_type_.$tag === 4) {
        return `_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(_type_)}__`;
      } else {
        return `${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(_type_)}_`;
      }
    }
    case 3: {
      const _Tuple = type_;
      const _types = _Tuple._0;
      return `_${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$188$(moonbitlang$core$array$$Array$iter$75$(_types), moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident), "__")}_`;
    }
    default: {
      const _Arrow = type_;
      const _args$2 = _Arrow._0;
      const _ret = _Arrow._1;
      return `_${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$188$(moonbitlang$core$array$$Array$iter$75$(_args$2), moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident), "__")}_____${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(_ret)}`;
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$inner$46$inject_derive$124$233(derive_map, type_) {
  const _bind = moonbitlang$yacc$lib$util$array_multimap$$T$get$256$(derive_map, type_);
  if (_bind.length === 0) {
    return "";
  } else {
    const joined = moonbitlang$core$builtin$$Iter$join(moonbitlang$core$array$$Array$iter$13$(_bind), ", ");
    return ` derive(${joined})`;
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$inner(terminals, terminal_meta, output, no_comments, derive_map) {
  output.method_table.method_0(output.self, "pub(all) enum Token {\n");
  const _len = terminals.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const term = terminals[_i];
      const meta = terminal_meta(term.name);
      _L: {
        _L$2: {
          const _bind = meta.data_type;
          if (_bind.$tag === 0) {
            const _Constr = _bind;
            const _x = _Constr._0;
            if (_x === undefined) {
              const _x$2 = _Constr._1;
              if (_x$2 === "Unit") {
                const _x$3 = _Constr._2;
                if (_x$3.length === 0) {
                  output.method_table.method_0(output.self, `  ${term.name}\n`);
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$2;
            }
          } else {
            break _L$2;
          }
          break _L;
        }
        output.method_table.method_0(output.self, `  ${term.name}(${moonbitlang$core$builtin$$Show$to_string$122$(meta.data_type)})\n`);
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_table.method_0(output.self, `}${moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$inner$46$inject_derive$124$233(derive_map, "Token")}\n\npub fn Token::kind(self : Token) -> TokenKind {\n  match self {\n`);
  const _len$2 = terminals.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const term = terminals[_i];
      const meta = terminal_meta(term.name);
      _L: {
        _L$2: {
          const _bind = meta.data_type;
          if (_bind.$tag === 0) {
            const _Constr = _bind;
            const _x = _Constr._0;
            if (_x === undefined) {
              const _x$2 = _Constr._1;
              if (_x$2 === "Unit") {
                const _x$3 = _Constr._2;
                if (_x$3.length === 0) {
                  output.method_table.method_0(output.self, `    ${term.name} => TK_${term.name}\n`);
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$2;
            }
          } else {
            break _L$2;
          }
          break _L;
        }
        output.method_table.method_0(output.self, `    ${term.name}(_) => TK_${term.name}\n`);
      }
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_table.method_0(output.self, "  }\n}\n\n");
  output.method_table.method_0(output.self, "pub(all) enum TokenKind {\n");
  const _len$3 = terminals.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$3) {
      const term = terminals[_i];
      output.method_table.method_0(output.self, `  TK_${term.name}\n`);
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_table.method_0(output.self, `}${moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$inner$46$inject_derive$124$233(derive_map, "TokenKind")}\n\n`);
  output.method_table.method_0(output.self, "pub impl Show for TokenKind with output(self, logger) {\n  logger.write_string(\n    match self {\n");
  const _len$4 = terminals.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$4) {
      const term = terminals[_i];
      const _bind = terminal_meta(term.name).image;
      let name;
      if (_bind === undefined) {
        name = term.name;
      } else {
        const _Some = _bind;
        name = _Some;
      }
      output.method_table.method_0(output.self, `      TK_${term.name} => ${moonbitlang$core$string$$String$escape(name)}\n`);
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_table.method_0(output.self, "    }\n  )\n}\n\n");
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$fix_result_type(str) {
  return moonbitlang$core$string$$String$contains(str, { str: moonbitlang$yacc$lib$codegen$gen_mbt$$fix_result_type$46$42$bind$124$562, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$fix_result_type$46$42$bind$124$562.length }) ? `(${str})` : str;
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$add_action$124$53(_env, action) {
  const data_types = _env._1;
  const dedup = _env._0;
  if (moonbitlang$core$set$$Set$add_and_check$81$(dedup, action.stamp)) {
    const _arr = action.sub_actions;
    const _len = _arr.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const sub_action = _arr[_i];
        moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$add_action$124$53(_env, sub_action.action);
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _arr$2 = action.bindings;
    const _len$2 = _arr$2.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len$2) {
        const binding = _arr$2[_i];
        const _bind = binding._0;
        if (_bind.$tag === 0) {
          const _Data = _bind;
          const _type_ = _Data._1;
          _L: {
            _L$2: {
              if (_type_.$tag === 0) {
                const _Constr = _type_;
                const _x = _Constr._0;
                if (_x === undefined) {
                  const _x$2 = _Constr._1;
                  if (_x$2 === "Unit") {
                    const _x$3 = _Constr._2;
                    if (_x$3.length === 0) {
                    } else {
                      break _L$2;
                    }
                  } else {
                    break _L$2;
                  }
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
              break _L;
            }
            moonbitlang$core$sorted_set$$SortedSet$add$75$(data_types, _type_);
          }
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$sorted_set$$SortedSet$add$75$(data_types, action.type_);
    return;
  } else {
    return;
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$add_action$124$82(actions, action) {
  if (moonbitlang$yacc$lib$util$hashmap2$$T$contains$129$(actions, action.stamp)) {
    return undefined;
  }
  const _arr = action.sub_actions;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const sub_action = _arr[_i];
      moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$add_action$124$82(actions, sub_action.action);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$yacc$lib$util$hashmap2$$T$set$129$(actions, action.stamp, action);
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$get_action_id$124$99(stamp_to_action_id, action) {
  return moonbitlang$yacc$lib$util$default_hashmap$$DefaultHashMap$get$254$(stamp_to_action_id, action.stamp);
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$add_symbol_decision$124$158(_env, symbol, decision) {
  const sum = _env._2;
  const decision_groups = _env._1;
  const grammar = _env._0;
  const _p = moonbitlang$core$sorted_map$$SortedMap$get$228$(decision_groups, decision);
  const _p$2 = $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Empty$28$;
  let _tmp;
  if (_p === undefined) {
    _tmp = _p$2;
  } else {
    const _p$3 = _p;
    _tmp = _p$3;
  }
  moonbitlang$core$sorted_map$$SortedMap$set$228$(decision_groups, decision, moonbitlang$core$immut$sorted_set$$SortedSet$add$176$(_tmp, symbol));
  switch (symbol.$tag) {
    case 0: {
      const _T = symbol;
      const _t = _T._0;
      sum.val = sum.val + _t.num | 0;
      return;
    }
    case 1: {
      const _NT = symbol;
      const _nt = _NT._0;
      sum.val = sum.val + (grammar.terminals.length + _nt.num | 0) | 0;
      return;
    }
    default: {
      sum.val = sum.val + (grammar.terminals.length + grammar.nonterminals.length | 0) | 0;
      return;
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$get_action_id_by_prod_num$124$184(_env, prod_num) {
  const stamp_to_action_id = _env._1;
  const _production_meta = _env._0;
  return moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$get_action_id$124$99(stamp_to_action_id, _production_meta(prod_num).action);
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$gen_decision$124$182(_env, decision) {
  const stamp_to_action_id = _env._1;
  const _production_meta = _env._0;
  const _env$2 = { _0: _production_meta, _1: stamp_to_action_id };
  switch (decision.$tag) {
    case 0: {
      return "Accept";
    }
    case 1: {
      const _Shift = decision;
      const _state_num = _Shift._0;
      return `Shift(yy_state_${moonbitlang$core$builtin$$Show$to_string$111$(_state_num)})`;
    }
    case 2: {
      const _Reduce = decision;
      const _num_symbols = _Reduce._0;
      const _nonterm = _Reduce._1;
      const _prod_num = _Reduce._2;
      return `Reduce(${moonbitlang$core$builtin$$Show$to_string$111$(_num_symbols)}, NT_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident(_nonterm)}, yy_action_${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$get_action_id_by_prod_num$124$184(_env$2, _prod_num))})`;
    }
    default: {
      const _ReduceNoLookahead = decision;
      const _num_symbols$2 = _ReduceNoLookahead._0;
      const _nonterm$2 = _ReduceNoLookahead._1;
      const _prod_num$2 = _ReduceNoLookahead._2;
      return `ReduceNoLookahead(${moonbitlang$core$builtin$$Show$to_string$111$(_num_symbols$2)}, NT_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident(_nonterm$2)}, yy_action_${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$get_action_id_by_prod_num$124$184(_env$2, _prod_num$2))})`;
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner(grammar, automaton, meta, output, source_map_builder, grammar_filename, external_tokens, no_comments, mode, input_mode) {
  const used_runtime_funcs = moonbitlang$core$sorted_set$$SortedSet$new$13$();
  const _terminal_meta = meta.terminal_meta;
  const _nonterminal_meta = meta.nonterminal_meta;
  const _production_meta = meta.production_meta;
  const _it = moonbitlang$core$immut$array$$T$iter$65$(meta.header);
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$65$(_it);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _chunk = _Some;
      const _code = _chunk._0;
      const _original_range = _chunk._1;
      if (source_map_builder.$tag === 0) {
      } else {
        if (_original_range === undefined) {
        } else {
          const _Some$2 = source_map_builder;
          const _source_map_builder = _Some$2._0;
          const _Some$3 = _original_range;
          const _x = _Some$3;
          const _original_utf8_pos = _x._0;
          const _utf8_len = _x._1;
          const generated_utf8_pos = output.cursor;
          _source_map_builder.method_table.method_0(_source_map_builder.self, grammar_filename, _original_utf8_pos, generated_utf8_pos, _utf8_len);
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, _code);
      continue;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "\n");
  if (external_tokens) {
  } else {
    moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$inner(grammar.terminals, _terminal_meta, { self: output, method_table: $$$64$moonbitlang$47$yacc$47$lib$47$util$47$logger_with_cursor$46$LoggerWithCursor$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger }, no_comments, meta.derive_map);
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, `pub suberror ParseError {\n  UnexpectedToken(Token, (${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}), Array[TokenKind])\n`);
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `  UnexpectedEndOfInput(${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, Array[TokenKind])\n`);
  }
  const _bind = moonbitlang$yacc$lib$util$array_multimap$$T$get$256$(meta.derive_map, moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$type_$124$36);
  let _tmp;
  if (_bind.length === 0) {
    _tmp = "";
  } else {
    const joined = moonbitlang$core$builtin$$Iter$join(moonbitlang$core$array$$Array$iter$13$(_bind), ", ");
    _tmp = ` derive(${joined})`;
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, `}${_tmp}\n\n`);
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "type YYObj = Error\n\n");
  if (mode === 0) {
    const data_types = moonbitlang$core$sorted_set$$SortedSet$new$75$();
    const _arr = grammar.terminals;
    const _len = _arr.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len) {
        const term = _arr[_i];
        const meta$2 = _terminal_meta(term.name);
        _L: {
          _L$2: {
            const _bind$2 = meta$2.data_type;
            if (_bind$2.$tag === 0) {
              const _Constr = _bind$2;
              const _x = _Constr._0;
              if (_x === undefined) {
                const _x$2 = _Constr._1;
                if (_x$2 === "Unit") {
                  const _x$3 = _Constr._2;
                  if (_x$3.length === 0) {
                  } else {
                    break _L$2;
                  }
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$2;
            }
            break _L;
          }
          moonbitlang$core$sorted_set$$SortedSet$add$75$(data_types, meta$2.data_type);
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const dedup = moonbitlang$core$set$$Set$new$46$inner$81$(8);
    const _env = { _0: dedup, _1: data_types };
    const _arr$2 = automaton.states;
    const _len$2 = _arr$2.length;
    let _tmp$3 = 0;
    while (true) {
      const _i = _tmp$3;
      if (_i < _len$2) {
        const state = _arr$2[_i];
        const _it$2 = moonbitlang$core$sorted_map$$SortedMap$iter2$226$(state.action);
        while (true) {
          const _bind$2 = moonbitlang$core$builtin$$Iter2$next$226$(_it$2);
          if (_bind$2 === undefined) {
            break;
          } else {
            const _Some = _bind$2;
            const _x = _Some;
            const _action = _x._1;
            switch (_action.$tag) {
              case 0: {
                break;
              }
              case 2: {
                break;
              }
              case 1: {
                const _Reduce = _action;
                const _production = _Reduce._0;
                if (!moonbitlang$core$array$$Array$contains$34$(grammar.starts, _production)) {
                  const meta$2 = _production_meta(_production.num);
                  moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$add_action$124$53(_env, meta$2.action);
                }
                break;
              }
              default: {
                $panic();
              }
            }
            continue;
          }
        }
        _tmp$3 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "priv suberror YYObj_Void\n\n");
    const _it$2 = moonbitlang$core$sorted_set$$SortedSet$iter$75$(data_types);
    while (true) {
      const _bind$2 = moonbitlang$core$builtin$$Iter$next$75$(_it$2);
      if (_bind$2 === undefined) {
        break;
      } else {
        const _Some = _bind$2;
        const _data_type = _Some;
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `priv suberror YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(_data_type)} {\n  YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(_data_type)}(${moonbitlang$core$builtin$$Show$to_string$122$(_data_type)})\n}\n\n`);
        continue;
      }
    }
  } else {
    if (input_mode === 0) {
      moonbitlang$core$builtin$$Logger$write_string$5$(output, "priv suberror YYObj_Void\n\n");
    }
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "priv suberror YYObj_Json {\n YYObj_Json(Json)\n}\n");
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, `type YYState = (YYSymbol) -> YYDecision\n\ntype YYAction = (${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ArrayView[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})]) -> YYObj\n\npriv enum YYDecision {\n  Accept\n  Shift(YYState)\n  Reduce(Int, YYSymbol, YYAction)\n  ReduceNoLookahead(Int, YYSymbol, YYAction)\n  Error\n}\n\n`);
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "priv enum YYSymbol {\n");
  const _arr = grammar.terminals;
  const _len = _arr.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len) {
      const term = _arr[_i];
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `  T_${term.name}\n`);
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _arr$2 = grammar.nonterminals;
  const _len$2 = _arr$2.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$2) {
      _L: {
        const nonterm = _arr$2[_i];
        if (!moonbitlang$core$builtin$$Iter$contains$53$(moonbitlang$core$builtin$$Iter$map$185$(moonbitlang$core$array$$Array$iter$34$(grammar.starts), (p) => p.lhs), nonterm)) {
          moonbitlang$core$builtin$$Logger$write_string$5$(output, `  NT_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_nonterminal_ident(nonterm)}\n`);
        } else {
          break _L;
        }
        break _L;
      }
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "  EOI\n}\n\n// Workaround for EOI unused warning\nfn init {\n  match (EOI : YYSymbol) {\n    EOI => ()\n    _ => ()\n  }\n}\n\n");
  const actions = moonbitlang$yacc$lib$util$hashmap2$$new$129$(16);
  const _arr$3 = automaton.states;
  const _len$3 = _arr$3.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$3) {
      const state = _arr$3[_i];
      const _it$2 = moonbitlang$core$sorted_map$$SortedMap$iter2$226$(state.action);
      while (true) {
        const _bind$2 = moonbitlang$core$builtin$$Iter2$next$226$(_it$2);
        if (_bind$2 === undefined) {
          break;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _decision = _x._1;
          if (_decision.$tag === 1) {
            const _Reduce = _decision;
            const _production = _Reduce._0;
            if (!moonbitlang$core$array$$Array$contains$34$(grammar.starts, _production)) {
              const meta$2 = _production_meta(_production.num);
              moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$add_action$124$82(actions, meta$2.action);
            } else {
              continue;
            }
          }
          continue;
        }
      }
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const next_action_id = { val: 0 };
  const stamp_to_action_id = moonbitlang$yacc$lib$util$default_hashmap$$new$254$((_key) => {
    const action_id = next_action_id.val;
    next_action_id.val = next_action_id.val + 1 | 0;
    return action_id;
  });
  const _it$2 = moonbitlang$yacc$lib$util$hashmap2$$T$iterator2$129$(actions);
  while (true) {
    const _bind$2 = moonbitlang$core$builtin$$Iter2$next$129$(_it$2);
    if (_bind$2 === undefined) {
      break;
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      const _action = _x._1;
      const clause_info = _action.original_clause_info;
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `// file:///./${clause_info.file}\n`);
      const clause_lines = moonbitlang$core$builtin$$Iter$to_array$14$(moonbitlang$core$string$$String$split(clause_info.code, { str: moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$42$bind$124$749, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$42$bind$124$749.length }));
      const max_line_number = (clause_info.line + 1 | 0) + (clause_lines.length - 1 | 0) | 0;
      const num_digits = moonbitlang$core$int$$Int$to_string$46$inner(max_line_number, 10).length;
      const _len$4 = clause_lines.length;
      let _tmp$5 = 0;
      while (true) {
        const _i = _tmp$5;
        if (_i < _len$4) {
          const line = clause_lines[_i];
          moonbitlang$core$builtin$$Logger$write_string$5$(output, "// ");
          const line_number = (clause_info.line + 1 | 0) + _i | 0;
          const line_number_str = moonbitlang$core$string$$String$pad_start(moonbitlang$core$int$$Int$to_string$46$inner(line_number, 10), num_digits, 32);
          moonbitlang$core$builtin$$Logger$write_string$5$(output, line_number_str);
          moonbitlang$core$builtin$$Logger$write_char$5$(output, 124);
          if (_i === 0) {
            if (clause_info.column > 0) {
              moonbitlang$core$builtin$$Logger$write_string$5$(output, moonbitlang$core$string$$String$repeat(" ", clause_info.column));
            }
          }
          moonbitlang$core$builtin$$Logger$write_string$5$(output, moonbitlang$core$builtin$$Show$to_string$14$(line));
          moonbitlang$core$builtin$$Logger$write_char$5$(output, 10);
          _tmp$5 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn yy_action_${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$get_action_id$124$99(stamp_to_action_id, _action))}(_last_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, _args : ArrayView[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})]) -> YYObj {\n`);
      const _arr$4 = _action.sub_actions;
      const _len$5 = _arr$4.length;
      let _tmp$6 = 0;
      while (true) {
        const _i = _tmp$6;
        if (_i < _len$5) {
          const sub_action = _arr$4[_i];
          const _start = sub_action.start;
          const _end = sub_action.end;
          const _action2 = sub_action.action;
          const last_pos_code = _start === 0 ? "_last_pos" : `_args[${moonbitlang$core$builtin$$Show$to_string$111$(_start - 1 | 0)}].2`;
          moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let _sub_action_${moonbitlang$core$builtin$$Show$to_string$111$(_i)}_result = yy_action_${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$get_action_id$124$99(stamp_to_action_id, _action2))}(${last_pos_code}, _args[${moonbitlang$core$builtin$$Show$to_string$111$(_start)}:${moonbitlang$core$builtin$$Show$to_string$111$(_end)}])\n`);
          _tmp$6 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const _arr$5 = _action.bindings;
      const _len$6 = _arr$5.length;
      let _tmp$7 = 0;
      while (true) {
        const _i = _tmp$7;
        if (_i < _len$6) {
          const binding = _arr$5[_i];
          let index;
          _L: {
            _L$2: {
              const _bind$3 = binding._0;
              switch (_bind$3.$tag) {
                case 0: {
                  const _Data = _bind$3;
                  const _index = _Data._0;
                  const _type_ = _Data._1;
                  _L$3: {
                    _L$4: {
                      if (_type_.$tag === 0) {
                        const _Constr = _type_;
                        const _x$2 = _Constr._0;
                        if (_x$2 === undefined) {
                          const _x$3 = _Constr._1;
                          if (_x$3 === "Unit") {
                            const _x$4 = _Constr._2;
                            if (_x$4.length === 0) {
                              moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = ()\n`);
                            } else {
                              break _L$4;
                            }
                          } else {
                            break _L$4;
                          }
                        } else {
                          break _L$4;
                        }
                      } else {
                        break _L$4;
                      }
                      break _L$3;
                    }
                    moonbitlang$core$builtin$$Logger$write_string$5$(output, `  guard _args[${moonbitlang$core$builtin$$Show$to_string$111$(_index)}].0 is YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(_type_)}(${binding._1})\n`);
                  }
                  break;
                }
                case 3: {
                  moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = if _args.length() == 0 { _last_pos } else { _args[0].1 }\n`);
                  break;
                }
                case 4: {
                  moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = if _args.length() == 0 { _last_pos } else { _args[_args.length() - 1].2 }\n`);
                  break;
                }
                case 1: {
                  const _StartPosOf = _bind$3;
                  const _index$2 = _StartPosOf._0;
                  index = _index$2;
                  break _L$2;
                }
                case 2: {
                  const _EndPosOf = _bind$3;
                  const _index$3 = _EndPosOf._0;
                  index = _index$3;
                  break _L$2;
                }
                case 5: {
                  moonbitlang$core$sorted_set$$SortedSet$add$13$(used_runtime_funcs, "_get_symbol_start_pos");
                  moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = _get_symbol_start_pos(_args, _last_pos)\n`);
                  break;
                }
                default: {
                  const _SubAction = _bind$3;
                  const _index$4 = _SubAction._0;
                  const _type_$2 = _SubAction._1;
                  _L$4: {
                    _L$5: {
                      if (_type_$2.$tag === 0) {
                        const _Constr = _type_$2;
                        const _x$2 = _Constr._0;
                        if (_x$2 === undefined) {
                          const _x$3 = _Constr._1;
                          if (_x$3 === "Unit") {
                            const _x$4 = _Constr._2;
                            if (_x$4.length === 0) {
                              moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = ()\n`);
                            } else {
                              break _L$5;
                            }
                          } else {
                            break _L$5;
                          }
                        } else {
                          break _L$5;
                        }
                      } else {
                        break _L$5;
                      }
                      break _L$4;
                    }
                    moonbitlang$core$builtin$$Logger$write_string$5$(output, `  guard _sub_action_${moonbitlang$core$builtin$$Show$to_string$111$(_index$4)}_result is YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(_type_$2)}(${binding._1})\n`);
                  }
                }
              }
              break _L;
            }
            if (_action.arity === 0) {
              moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = _last_pos\n`);
            } else {
              const _bind$3 = binding._0;
              let field;
              switch (_bind$3.$tag) {
                case 1: {
                  field = 1;
                  break;
                }
                case 2: {
                  field = 2;
                  break;
                }
                default: {
                  field = $panic();
                }
              }
              moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = _args[${moonbitlang$core$builtin$$Show$to_string$111$(index)}].${moonbitlang$core$builtin$$Show$to_string$111$(field)}\n`);
            }
          }
          _tmp$7 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const result_data_type = _action.type_;
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `  YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(result_data_type)}({(); `);
      const _arr$6 = _action.body;
      const _len$7 = _arr$6.length;
      let _tmp$8 = 0;
      while (true) {
        const _i = _tmp$8;
        if (_i < _len$7) {
          const part = _arr$6[_i];
          const _code = part._0;
          const _original_range = part._1;
          if (_original_range === undefined) {
          } else {
            const _Some$2 = _original_range;
            const _x$2 = _Some$2;
            const _original_utf8_pos = _x$2._0;
            const _original_utf8_len = _x$2._1;
            const generated_utf8_pos = output.cursor;
            if (source_map_builder.$tag === 0) {
            } else {
              const _Some$3 = source_map_builder;
              const _source_map_builder = _Some$3._0;
              if (_code.length === _original_utf8_len) {
                _source_map_builder.method_table.method_0(_source_map_builder.self, grammar_filename, _original_utf8_pos, generated_utf8_pos, _code.length);
              }
            }
          }
          moonbitlang$core$builtin$$Logger$write_string$5$(output, _code);
          _tmp$8 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, "})\n");
      moonbitlang$core$builtin$$Logger$write_string$5$(output, "}\n\n");
      continue;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn yy_input(token : Token, _start_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, _end_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}) -> (YYSymbol, YYObj) {\n  match token {\n`);
  const _arr$4 = grammar.terminals;
  const _len$4 = _arr$4.length;
  let _tmp$5 = 0;
  while (true) {
    const _i = _tmp$5;
    if (_i < _len$4) {
      const term = _arr$4[_i];
      const meta$2 = _terminal_meta(term.name);
      if (mode === 0) {
        _L: {
          _L$2: {
            const _bind$2 = meta$2.data_type;
            if (_bind$2.$tag === 0) {
              const _Constr = _bind$2;
              const _x = _Constr._0;
              if (_x === undefined) {
                const _x$2 = _Constr._1;
                if (_x$2 === "Unit") {
                  const _x$3 = _Constr._2;
                  if (_x$3.length === 0) {
                    moonbitlang$core$builtin$$Logger$write_string$5$(output, `    ${term.name} => (T_${term.name}, YYObj_Void)\n`);
                  } else {
                    break _L$2;
                  }
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$2;
            }
            break _L;
          }
          moonbitlang$core$builtin$$Logger$write_string$5$(output, `    ${term.name}(data) => (T_${term.name}, YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(meta$2.data_type)}(data))\n`);
        }
      } else {
        const _bind$2 = meta$2.data_type;
        let payload_code;
        if (_bind$2.$tag === 0) {
          const _Constr = _bind$2;
          const _x = _Constr._0;
          if (_x === undefined) {
            const _x$2 = _Constr._1;
            if (_x$2 === "Unit") {
              const _x$3 = _Constr._2;
              payload_code = _x$3.length === 0 ? "" : "(data)";
            } else {
              payload_code = "(data)";
            }
          } else {
            payload_code = "(data)";
          }
        } else {
          payload_code = "(data)";
        }
        const _bind$3 = meta$2.data_type;
        let data_code;
        if (_bind$3.$tag === 0) {
          const _Constr = _bind$3;
          const _x = _Constr._0;
          if (_x === undefined) {
            const _x$2 = _Constr._1;
            if (_x$2 === "Unit") {
              const _x$3 = _Constr._2;
              data_code = _x$3.length === 0 ? "Json::null()" : "data.to_json()";
            } else {
              data_code = "data.to_json()";
            }
          } else {
            data_code = "data.to_json()";
          }
        } else {
          data_code = "data.to_json()";
        }
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `    ${term.name}${payload_code} => (T_${term.name}, YYObj_Json({\n      \"type\": \"TERMINAL\",\n      \"name\": \"${term.name}\",\n      \"data\": ${data_code},\n      \"start\": _start_pos.to_json(),\n      \"end\": _end_pos.to_json()\n    }))\n`);
      }
      _tmp$5 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "  }\n}\n\n");
  const _arr$5 = automaton.states;
  const _len$5 = _arr$5.length;
  let _tmp$6 = 0;
  while (true) {
    const _i = _tmp$6;
    if (_i < _len$5) {
      const state = _arr$5[_i];
      if (!no_comments) {
        const _it$3 = moonbitlang$yacc$lib$lr1$$LR1State$iter_item_groups(state);
        while (true) {
          const _bind$2 = moonbitlang$core$builtin$$Iter$next$124$(_it$3);
          if (_bind$2 === undefined) {
            break;
          } else {
            const _Some = _bind$2;
            const _item = _Some;
            moonbitlang$core$builtin$$Logger$write_string$5$(output, `// ${moonbitlang$core$builtin$$Show$to_string$123$(_item)}\n`);
            continue;
          }
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn yy_state_${moonbitlang$core$builtin$$Show$to_string$111$(state.num)}(_lookahead : YYSymbol) -> YYDecision {\n`);
      const sum = { val: 0 };
      const decision_groups = moonbitlang$core$sorted_map$$SortedMap$new$228$();
      const _env = { _0: grammar, _1: decision_groups, _2: sum };
      const _it$3 = moonbitlang$core$sorted_map$$SortedMap$iter2$226$(state.action);
      while (true) {
        const _bind$2 = moonbitlang$core$builtin$$Iter2$next$226$(_it$3);
        if (_bind$2 === undefined) {
          break;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _input = _x._0;
          const _decision = _x._1;
          let _tmp$7;
          if (_input.$tag === 1) {
            const _Input = _input;
            const _term = _Input._0;
            _tmp$7 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$T(_term);
          } else {
            _tmp$7 = $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$EOI;
          }
          const _tmp$8 = _tmp$7;
          let _tmp$9;
          switch (_decision.$tag) {
            case 2: {
              _tmp$9 = $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Accept;
              break;
            }
            case 0: {
              const _Shift = _decision;
              const _next_state = _Shift._0;
              _tmp$9 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Shift(_next_state.num);
              break;
            }
            case 1: {
              const _Reduce = _decision;
              const _production = _Reduce._0;
              _tmp$9 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Reduce(_production.rhs.length, _production.lhs, _production.num);
              break;
            }
            default: {
              _tmp$9 = $panic();
            }
          }
          moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$add_symbol_decision$124$158(_env, _tmp$8, _tmp$9);
          continue;
        }
      }
      const _it$4 = moonbitlang$core$sorted_map$$SortedMap$iter2$227$(state.goto);
      while (true) {
        const _bind$2 = moonbitlang$core$builtin$$Iter2$next$227$(_it$4);
        if (_bind$2 === undefined) {
          break;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _symbol = _x._0;
          const _state = _x._1;
          if (_symbol.$tag === 1) {
            const _NT = _symbol;
            const _nonterm = _NT._0;
            moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$add_symbol_decision$124$158(_env, new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$NT(_nonterm), new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Shift(_state.num));
          }
          continue;
        }
      }
      let total = 0;
      const _arr$6 = grammar.terminals;
      const _len$6 = _arr$6.length;
      let _tmp$7 = 0;
      while (true) {
        const _i$2 = _tmp$7;
        if (_i$2 < _len$6) {
          const term = _arr$6[_i$2];
          total = total + term.num | 0;
          _tmp$7 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const _arr$7 = grammar.nonterminals;
      const _len$7 = _arr$7.length;
      let _tmp$8 = 0;
      while (true) {
        const _i$2 = _tmp$8;
        if (_i$2 < _len$7) {
          _L: {
            const nonterm = _arr$7[_i$2];
            if (!moonbitlang$core$builtin$$Iter$contains$53$(moonbitlang$core$builtin$$Iter$map$185$(moonbitlang$core$array$$Array$iter$34$(grammar.starts), (p) => p.lhs), nonterm)) {
              total = total + (grammar.terminals.length + nonterm.num | 0) | 0;
            } else {
              break _L;
            }
            break _L;
          }
          _tmp$8 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      total = total + (grammar.terminals.length + grammar.nonterminals.length | 0) | 0;
      const _env$2 = { _0: _production_meta, _1: stamp_to_action_id };
      let _tmp$9;
      if (decision_groups.size === 1) {
        const _self = [];
        moonbitlang$core$array$$Array$push_iter$74$(_self, moonbitlang$core$sorted_map$$SortedMap$keys_as_iter$228$(decision_groups));
        const _bind$2 = moonbitlang$core$array$$Array$at$74$(_self, 0);
        let _tmp$10;
        switch (_bind$2.$tag) {
          case 2: {
            _tmp$10 = true;
            break;
          }
          case 0: {
            _tmp$10 = true;
            break;
          }
          default: {
            _tmp$10 = false;
          }
        }
        _tmp$9 = _tmp$10;
      } else {
        _tmp$9 = false;
      }
      if (_tmp$9) {
        const _self = [];
        moonbitlang$core$array$$Array$push_iter$74$(_self, moonbitlang$core$sorted_map$$SortedMap$keys_as_iter$228$(decision_groups));
        const decision = moonbitlang$core$array$$Array$at$74$(_self, 0);
        let decision$2;
        if (decision.$tag === 2) {
          const _Reduce = decision;
          const _num_symbols = _Reduce._0;
          const _nonterm = _Reduce._1;
          const _prod_num = _Reduce._2;
          decision$2 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$ReduceNoLookahead(_num_symbols, _nonterm, _prod_num);
        } else {
          decision$2 = decision;
        }
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `  ${moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$gen_decision$124$182(_env$2, decision$2)}\n`);
      } else {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, "  match _lookahead {\n");
        const _it$5 = moonbitlang$core$sorted_map$$SortedMap$iter2$228$(decision_groups);
        while (true) {
          const _bind$2 = moonbitlang$core$builtin$$Iter2$next$228$(_it$5);
          if (_bind$2 === undefined) {
            break;
          } else {
            const _Some = _bind$2;
            const _x = _Some;
            const _decision = _x._0;
            const _symbols = _x._1;
            const pattern = moonbitlang$core$array$$Array$join$13$(moonbitlang$core$builtin$$Iter$to_array$13$(moonbitlang$core$builtin$$Iter$map$186$(moonbitlang$core$immut$sorted_set$$SortedSet$iter$176$(_symbols), moonbitlang$yacc$lib$codegen$gen_mbt$$CodegenSymbol$to_string)), { str: moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$42$bind$124$863, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$42$bind$124$863.length });
            moonbitlang$core$builtin$$Logger$write_string$5$(output, `    ${pattern} => ${moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner$46$gen_decision$124$182(_env$2, _decision)}\n`);
            continue;
          }
        }
        const exhaustive = sum.val === total;
        if (!exhaustive) {
          moonbitlang$core$builtin$$Logger$write_string$5$(output, "    _ => Error\n");
        }
        moonbitlang$core$builtin$$Logger$write_string$5$(output, "  }\n");
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, "}\n\n");
      _tmp$6 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn[T] yy_parse(\n  tokens : Array[(Token, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})],\n  start : YYState,\n  return_ : (YYObj) -> T,\n  initial_pos? : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)},\n) -> T raise ParseError {\n  let mut cursor = 0\n  let mut state_stack : @list.List[YYState] = @list.cons(start, @list.empty())\n  let data_stack : Array[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})] = []\n  let mut last_pos = initial_pos.unwrap_or(tokens[0].1)\n  let mut state = start\n  let mut lookahead : Option[(YYSymbol, (YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}), Token?)] = None\n  let mut last_shifted_state_stack = state_stack\n  while true {\n    let decision = match state(EOI) {\n      ReduceNoLookahead(_) | Accept as t => t\n      _ => {\n        match lookahead {\n          Some(la) => state(la.0)\n          None => {\n            if cursor < tokens.length() {\n              let (token, start_pos, end_pos) = tokens[cursor]\n              cursor += 1\n              let (symbol, data) = yy_input(token, start_pos, end_pos)\n              lookahead = Some((symbol, (data, start_pos, end_pos), Some(token)))\n              state(symbol)\n            } else {\n              lookahead = Some((EOI, (YYObj_Void, last_pos, last_pos), None))\n              state(EOI)\n            }\n          }\n        }\n      }\n    }\n    match decision {\n      Accept => return return_(data_stack.unsafe_pop().0)\n      Shift(next_state) => {\n        guard lookahead is Some(la)\n        data_stack.push(la.1)\n        state_stack = @list.cons(next_state, state_stack)\n        last_shifted_state_stack = state_stack\n        state = next_state\n        last_pos = la.1.2\n        lookahead = None\n      }\n      Reduce(count, symbol, action)\n      | ReduceNoLookahead(count, symbol, action) => {\n        loop (count, symbol, action) {\n          _ => {\n            let args = data_stack[data_stack.length() - count:]\n            let data = action(last_pos, args)\n            let (start_pos, end_pos) = if args.length() == 0 {\n              (last_pos, last_pos)\n            } else {\n              (args[0].1, args[args.length() - 1].2)\n            }\n            for i in 0..<count {\n              ignore(data_stack.unsafe_pop())\n              state_stack = state_stack.unsafe_tail()\n            }\n            state = state_stack.unsafe_head()\n            data_stack.push((data, start_pos, end_pos))\n            match state(symbol) {\n              Accept => return return_(data_stack.unsafe_pop().0)\n              Shift(next_state) => {\n                state_stack = @list.cons(next_state, state_stack)\n                state = next_state\n              }\n              Reduce(count, symbol, action)\n              | ReduceNoLookahead(count, symbol, action) => continue (count, symbol, action)\n              _ => panic()\n            }\n          }\n        }\n      }\n      Error => {\n        let (_, (_, start_pos, end_pos), token) = lookahead.unwrap()\n        error(last_shifted_state_stack, token, (start_pos, end_pos))\n      }\n    }\n  }\n  panic()\n}\n\n`);
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn[T] yy_parse(\n  read_token : () -> (Token, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}),\n  start_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)},\n  start : YYState,\n  return_ : (YYObj) -> T\n) -> T raise ParseError {\n  let mut state_stack : @list.List[YYState] = @list.cons(start, @list.empty())\n  let data_stack : Array[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})] = []\n  let mut last_pos = start_pos\n  let mut state = start\n  let mut lookahead : Option[(YYSymbol, (YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}), Token)] = None\n  let mut last_shifted_state_stack = state_stack\n  while true {\n    let decision = match state(EOI) {\n      ReduceNoLookahead(_) | Accept as t => t\n      _ => {\n        match lookahead {\n          Some(la) => state(la.0)\n          None => {\n            let (token, start_pos, end_pos) = read_token()\n            let (symbol, data) = yy_input(token, start_pos, end_pos)\n            lookahead = Some((symbol, (data, start_pos, end_pos), token))\n            state(symbol)\n          }\n        }\n      }\n    }\n    match decision {\n      Accept => return return_(data_stack.unsafe_pop().0)\n      Shift(next_state) => {\n        guard lookahead is Some(la)\n        data_stack.push(la.1)\n        state_stack = @list.cons(next_state, state_stack)\n        last_shifted_state_stack = state_stack\n        state = next_state\n        last_pos = la.1.2\n        lookahead = None\n      }\n      Reduce(count, symbol, action)\n      | ReduceNoLookahead(count, symbol, action) => {\n        loop (count, symbol, action) {\n          _ => {\n            let args = data_stack[data_stack.length() - count:]\n            let data = action(last_pos, args)\n            let (start_pos, end_pos) = if args.length() == 0 {\n              (last_pos, last_pos)\n            } else {\n              (args[0].1, args[args.length() - 1].2)\n            }\n            for i in 0..<count {\n              ignore(data_stack.unsafe_pop())\n              state_stack = state_stack.unsafe_tail()\n            }\n            state = state_stack.unsafe_head()\n            data_stack.push((data, start_pos, end_pos))\n            match state(symbol) {\n              Accept => return return_(data_stack.unsafe_pop().0)\n              Shift(next_state) => {\n                state_stack = @list.cons(next_state, state_stack)\n                state = next_state\n              }\n              Reduce(count, symbol, action)\n              | ReduceNoLookahead(count, symbol, action) => continue (count, symbol, action)\n              _ => panic()\n            }\n          }\n        }\n      }\n      Error => {\n        let (_, (_, start_pos, end_pos), token) = lookahead.unwrap()\n        error(last_shifted_state_stack, token, (start_pos, end_pos))\n      }\n    }\n  }\n  panic()\n}\n\n`);
  }
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn error(stack : @list.List[YYState], token : Token?, loc : (${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})) -> Unit raise ParseError {\n`);
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn error(stack : @list.List[YYState], token : Token, loc : (${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})) -> Unit raise ParseError {\n`);
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "  let expected = []\n  fn try_add(symbol : YYSymbol, kind : TokenKind) {\n    fn go(stack : @list.List[YYState]) {\n      match stack {\n        Empty => ()\n        More(state, ..) => {\n          match state(symbol) {\n            Accept | Shift(_) => expected.push(kind)\n            Reduce(count, symbol, _) | ReduceNoLookahead(count, symbol, _) => {\n              fn inner_go(stack : @list.List[YYState], count, symbol) {\n                let stack = stack.drop(count)\n                guard stack is More(state, ..)\n                match state(symbol) {\n                  Shift(state) => go(@list.cons(state, stack))\n                  Reduce(count, symbol, _) | ReduceNoLookahead(count, symbol, _) => inner_go(stack, count, symbol)\n                  _ => panic()\n                }\n              }\n              inner_go(stack, count, symbol)\n            }\n            Error => ()\n          }\n        }\n      }\n    }\n    go(stack)\n  }\n");
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "  for term in ([");
  const _arr$6 = grammar.terminals;
  const _len$6 = _arr$6.length;
  let _tmp$7 = 0;
  while (true) {
    const _i = _tmp$7;
    if (_i < _len$6) {
      const term = _arr$6[_i];
      if (_i > 0) {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, ", ");
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `(T_${term.name}, TK_${term.name})`);
      _tmp$7 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "] : Array[(YYSymbol, TokenKind)]) {\n");
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "    try_add(term.0, term.1)\n  }\n");
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "  match token {\n    None => raise UnexpectedEndOfInput(loc.1, expected)\n    Some(token) => raise UnexpectedToken(token, loc, expected)\n  }\n");
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "  raise UnexpectedToken(token, loc, expected)\n");
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "}\n\n");
  const _arr$7 = automaton.starts;
  const _len$7 = _arr$7.length;
  let _tmp$8 = 0;
  while (true) {
    const _i = _tmp$8;
    if (_i < _len$7) {
      const start = _arr$7[_i];
      const _start_production = start._0;
      const _start_state = start._1;
      const name = _start_production.lhs.name;
      let original_name;
      let _try_err;
      _L: {
        _L$2: {
          const _bind$2 = moonbitlang$core$string$$String$sub$46$inner(name, 0, name.length - "_prime".length | 0);
          let _tmp$9;
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _tmp$9 = _ok._0;
          } else {
            const _err = _bind$2;
            const _tmp$10 = _err._0;
            _try_err = _tmp$10;
            break _L$2;
          }
          original_name = moonbitlang$core$builtin$$Show$to_string$14$(_tmp$9);
          break _L;
        }
        original_name = $panic();
      }
      if (input_mode === 0) {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `pub fn ${original_name}(tokens : Array[(Token, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})], initial_pos? : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}) -> ${moonbitlang$yacc$lib$codegen$gen_mbt$$fix_result_type(moonbitlang$core$builtin$$Show$to_string$122$(_nonterminal_meta(name).data_type))} raise ParseError {\n  yy_parse(\n    tokens,\n    yy_state_${moonbitlang$core$builtin$$Show$to_string$111$(_start_state.num)},\n    (it) => {\n      guard it is YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(_nonterminal_meta(name).data_type)}(result)\n      result\n    },\n    initial_pos?,\n  )\n}\n`);
      } else {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `pub fn ${original_name}(read_token : () -> (Token, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}), start_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}) -> ${moonbitlang$yacc$lib$codegen$gen_mbt$$fix_result_type(moonbitlang$core$builtin$$Show$to_string$122$(_nonterminal_meta(name).data_type))} raise ParseError {\n  yy_parse(\n    read_token,\n    start_pos,\n    yy_state_${moonbitlang$core$builtin$$Show$to_string$111$(_start_state.num)},\n    (it) => {\n      guard it is YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$derive_type_ident(_nonterminal_meta(name).data_type)}(result)\n      result\n    },\n  )\n}\n`);
      }
      _tmp$8 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _it$3 = moonbitlang$core$sorted_set$$SortedSet$iter$13$(used_runtime_funcs);
  while (true) {
    const _bind$2 = moonbitlang$core$builtin$$Iter$next$13$(_it$3);
    if (_bind$2 === undefined) {
      break;
    } else {
      const _Some = _bind$2;
      const _func = _Some;
      if (_func === "_get_symbol_start_pos") {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `\nfn _get_symbol_start_pos(args : ArrayView[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})], last_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}) -> ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)} {\n  if args.length() == 0 {\n    last_pos\n  } else {\n    for i = 0; i < args.length(); i = i + 1 {\n      let (_, start_pos, end_pos) = args[i]\n      if start_pos == end_pos {\n        continue\n      }\n      return start_pos\n    }\n    args[args.length() - 1].2\n  }\n}\n`);
      } else {
        $panic();
      }
      continue;
    }
  }
  if (mode === 0) {
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `\nfn args_to_json(args : ArrayView[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})]) -> Json {\n  Json::array(args.iter().map((it) => {\n    guard it.0 is YYObj_Json(json)\n    json\n  }).to_array())\n}\n`);
  }
  const _it$4 = moonbitlang$core$immut$array$$T$iter$65$(meta.footer);
  while (true) {
    const _bind$2 = moonbitlang$core$builtin$$Iter$next$65$(_it$4);
    if (_bind$2 === undefined) {
      return;
    } else {
      const _Some = _bind$2;
      const _chunk = _Some;
      const _code = _chunk._0;
      const _original_range = _chunk._1;
      if (source_map_builder.$tag === 0) {
      } else {
        if (_original_range === undefined) {
        } else {
          const _Some$2 = source_map_builder;
          const _source_map_builder = _Some$2._0;
          const _Some$3 = _original_range;
          const _x = _Some$3;
          const _original_utf8_pos = _x._0;
          const _utf8_len = _x._1;
          const generated_utf8_pos = output.cursor;
          _source_map_builder.method_table.method_0(_source_map_builder.self, grammar_filename, _original_utf8_pos, generated_utf8_pos, _utf8_len);
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, _code);
      continue;
    }
  }
}
function moonbitlang$yacc$lib$codegen$$CodeGenerator$void_type$2$(self) {
  return "Unit";
}
function moonbitlang$yacc$lib$codegen$$CodeGenerator$void_action_code$2$(self) {
  return "()";
}
function moonbitlang$yacc$lib$codegen$$CodeGenerator$codegen_tokens$2$(self, terminals, terminal_meta, output, no_comments, derive_map) {
  moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$inner(terminals, terminal_meta, output, no_comments, derive_map);
}
function moonbitlang$yacc$lib$codegen$$CodeGenerator$codegen$2$(self, grammar, automaton, meta, output, source_map_builder, grammar_filename, external_tokens, no_comments, mode, input_mode) {
  moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$inner(grammar, automaton, meta, output, source_map_builder, grammar_filename, external_tokens, no_comments, mode, input_mode);
}
function moonbitlang$core$builtin$$Eq$equal$73$(_x_332, _x_333) {
  switch (_x_332.$tag) {
    case 0: {
      if (_x_333.$tag === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_333.$tag === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      const _Shift = _x_332;
      const _$42$x0_334 = _Shift._0;
      if (_x_333.$tag === 2) {
        const _Shift$2 = _x_333;
        const _$42$y0_335 = _Shift$2._0;
        return _$42$x0_334.num === _$42$y0_335.num;
      } else {
        return false;
      }
    }
    case 3: {
      const _Reduce = _x_332;
      const _$42$x0_336 = _Reduce._0;
      if (_x_333.$tag === 3) {
        const _Reduce$2 = _x_333;
        const _$42$y0_337 = _Reduce$2._0;
        return _$42$x0_336.num === _$42$y0_337.num;
      } else {
        return false;
      }
    }
    default: {
      const _ReduceNoLookahead = _x_332;
      const _$42$x0_338 = _ReduceNoLookahead._0;
      if (_x_333.$tag === 4) {
        const _ReduceNoLookahead$2 = _x_333;
        const _$42$y0_339 = _ReduceNoLookahead$2._0;
        return _$42$x0_338.num === _$42$y0_339.num;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$73$(_x_316, _x_317) {
  switch (_x_316.$tag) {
    case 0: {
      if (_x_317.$tag === 0) {
        return 0;
      } else {
        return -1;
      }
    }
    case 1: {
      switch (_x_317.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 0;
        }
        default: {
          return -1;
        }
      }
    }
    case 2: {
      const _Shift = _x_316;
      const _$42$x0_318 = _Shift._0;
      switch (_x_317.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          const _Shift$2 = _x_317;
          const _$42$y0_319 = _Shift$2._0;
          return $compare_int(_$42$x0_318.num, _$42$y0_319.num);
        }
        default: {
          return -1;
        }
      }
    }
    case 3: {
      const _Reduce = _x_316;
      const _$42$x0_320 = _Reduce._0;
      switch (_x_317.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          const _Reduce$2 = _x_317;
          const _$42$y0_321 = _Reduce$2._0;
          return $compare_int(_$42$x0_320.num, _$42$y0_321.num);
        }
        default: {
          return -1;
        }
      }
    }
    default: {
      const _ReduceNoLookahead = _x_316;
      const _$42$x0_322 = _ReduceNoLookahead._0;
      switch (_x_317.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        default: {
          const _ReduceNoLookahead$2 = _x_317;
          const _$42$y0_323 = _ReduceNoLookahead$2._0;
          return $compare_int(_$42$x0_322.num, _$42$y0_323.num);
        }
      }
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$170$(_x_292, _x_293) {
  switch (_x_292.$tag) {
    case 0: {
      const _T = _x_292;
      const _$42$x0_294 = _T._0;
      if (_x_293.$tag === 0) {
        const _T$2 = _x_293;
        const _$42$y0_295 = _T$2._0;
        return $compare_int(_$42$x0_294.num, _$42$y0_295.num);
      } else {
        return -1;
      }
    }
    case 1: {
      const _NT = _x_292;
      const _$42$x0_296 = _NT._0;
      switch (_x_293.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          const _NT$2 = _x_293;
          const _$42$y0_297 = _NT$2._0;
          return $compare_int(_$42$x0_296.num, _$42$y0_297.num);
        }
        default: {
          return -1;
        }
      }
    }
    default: {
      switch (_x_293.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        default: {
          return 0;
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode(self, grammar) {
  switch (self.$tag) {
    case 2: {
      return 0;
    }
    case 0: {
      const _T = self;
      const _t = _T._0;
      return 1 + _t.num | 0;
    }
    default: {
      const _NT = self;
      const _nt = _NT._0;
      return (1 + grammar.terminals.length | 0) + _nt.num | 0;
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(type_) {
  switch (type_.$tag) {
    case 0: {
      const _Constr = type_;
      const _pkg = _Constr._0;
      const _name = _Constr._1;
      const _args = _Constr._2;
      let primary;
      if (_pkg === undefined) {
        primary = _name;
      } else {
        const _Some = _pkg;
        const _pkg$2 = _Some;
        const pkg2 = moonbitlang$core$string$$String$replace_all(_pkg$2, { str: moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident$46$42$bind$124$441, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident$46$42$bind$124$441.length }, { str: moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident$46$42$bind$124$442, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident$46$42$bind$124$442.length });
        primary = `_${pkg2}_${_name}`;
      }
      return _args.length === 0 ? primary : `${primary}_${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$188$(moonbitlang$core$array$$Array$iter$75$(_args), moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident), "__")}_`;
    }
    case 1: {
      return $panic();
    }
    case 2: {
      const _Option = type_;
      const _type_ = _Option._0;
      if (_type_.$tag === 4) {
        return `_${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(_type_)}__`;
      } else {
        return `${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(_type_)}_`;
      }
    }
    case 3: {
      const _Tuple = type_;
      const _types = _Tuple._0;
      return `_${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$188$(moonbitlang$core$array$$Array$iter$75$(_types), moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident), "__")}_`;
    }
    default: {
      const _Arrow = type_;
      const _args$2 = _Arrow._0;
      const _ret = _Arrow._1;
      return `_${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$188$(moonbitlang$core$array$$Array$iter$75$(_args$2), moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident), "__")}_____${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(_ret)}`;
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen_tokens$46$inner$46$inject_derive$124$251(derive_map, type_) {
  const _bind = moonbitlang$yacc$lib$util$array_multimap$$T$get$256$(derive_map, type_);
  if (_bind.length === 0) {
    return "";
  } else {
    const joined = moonbitlang$core$builtin$$Iter$join(moonbitlang$core$array$$Array$iter$13$(_bind), ", ");
    return ` derive(${joined})`;
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen_tokens$46$inner(terminals, terminal_meta, output, no_comments, derive_map) {
  output.method_table.method_0(output.self, "pub(all) enum Token {\n");
  const _len = terminals.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const term = terminals[_i];
      const meta = terminal_meta(term.name);
      _L: {
        _L$2: {
          const _bind = meta.data_type;
          if (_bind.$tag === 0) {
            const _Constr = _bind;
            const _x = _Constr._0;
            if (_x === undefined) {
              const _x$2 = _Constr._1;
              if (_x$2 === "Unit") {
                const _x$3 = _Constr._2;
                if (_x$3.length === 0) {
                  output.method_table.method_0(output.self, `  ${term.name}\n`);
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$2;
            }
          } else {
            break _L$2;
          }
          break _L;
        }
        output.method_table.method_0(output.self, `  ${term.name}(${moonbitlang$core$builtin$$Show$to_string$122$(meta.data_type)})\n`);
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_table.method_0(output.self, `}${moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen_tokens$46$inner$46$inject_derive$124$251(derive_map, "Token")}\n\npub fn Token::kind(self : Token) -> TokenKind {\n  match self {\n`);
  const _len$2 = terminals.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const term = terminals[_i];
      const meta = terminal_meta(term.name);
      _L: {
        _L$2: {
          const _bind = meta.data_type;
          if (_bind.$tag === 0) {
            const _Constr = _bind;
            const _x = _Constr._0;
            if (_x === undefined) {
              const _x$2 = _Constr._1;
              if (_x$2 === "Unit") {
                const _x$3 = _Constr._2;
                if (_x$3.length === 0) {
                  output.method_table.method_0(output.self, `    ${term.name} => TK_${term.name}\n`);
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$2;
            }
          } else {
            break _L$2;
          }
          break _L;
        }
        output.method_table.method_0(output.self, `    ${term.name}(_) => TK_${term.name}\n`);
      }
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_table.method_0(output.self, "  }\n}\n\n");
  output.method_table.method_0(output.self, "pub(all) enum TokenKind {\n");
  const _len$3 = terminals.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$3) {
      const term = terminals[_i];
      output.method_table.method_0(output.self, `  TK_${term.name}\n`);
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_table.method_0(output.self, `}${moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen_tokens$46$inner$46$inject_derive$124$251(derive_map, "TokenKind")}\n\n`);
  output.method_table.method_0(output.self, "pub impl Show for TokenKind with output(self, logger) {\n  logger.write_string(\n    match self {\n");
  const _len$4 = terminals.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$4) {
      const term = terminals[_i];
      const _bind = terminal_meta(term.name).image;
      let name;
      if (_bind === undefined) {
        name = term.name;
      } else {
        const _Some = _bind;
        name = _Some;
      }
      output.method_table.method_0(output.self, `      TK_${term.name} => ${moonbitlang$core$string$$String$escape(name)}\n`);
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_table.method_0(output.self, "    }\n  )\n}\n\n");
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$fix_result_type(str) {
  return moonbitlang$core$string$$String$contains(str, { str: moonbitlang$yacc$lib$codegen$gen_mbt_table$$fix_result_type$46$42$bind$124$510, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt_table$$fix_result_type$46$42$bind$124$510.length }) ? `(${str})` : str;
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$add_action$124$54(_env, action) {
  const data_types = _env._1;
  const dedup = _env._0;
  if (moonbitlang$core$set$$Set$add_and_check$81$(dedup, action.stamp)) {
    const _arr = action.sub_actions;
    const _len = _arr.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const sub_action = _arr[_i];
        moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$add_action$124$54(_env, sub_action.action);
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _arr$2 = action.bindings;
    const _len$2 = _arr$2.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len$2) {
        const binding = _arr$2[_i];
        const _bind = binding._0;
        if (_bind.$tag === 0) {
          const _Data = _bind;
          const _type_ = _Data._1;
          _L: {
            _L$2: {
              if (_type_.$tag === 0) {
                const _Constr = _type_;
                const _x = _Constr._0;
                if (_x === undefined) {
                  const _x$2 = _Constr._1;
                  if (_x$2 === "Unit") {
                    const _x$3 = _Constr._2;
                    if (_x$3.length === 0) {
                    } else {
                      break _L$2;
                    }
                  } else {
                    break _L$2;
                  }
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
              break _L;
            }
            moonbitlang$core$sorted_set$$SortedSet$add$75$(data_types, _type_);
          }
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$sorted_set$$SortedSet$add$75$(data_types, action.type_);
    return;
  } else {
    return;
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$add_action$124$74(actions, action) {
  if (moonbitlang$yacc$lib$util$hashmap2$$T$contains$129$(actions, action.stamp)) {
    return undefined;
  }
  const _arr = action.sub_actions;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const sub_action = _arr[_i];
      moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$add_action$124$74(actions, sub_action.action);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$yacc$lib$util$hashmap2$$T$set$129$(actions, action.stamp, action);
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$get_action_id$124$91(stamp_to_action_id, action) {
  return moonbitlang$yacc$lib$util$default_hashmap$$DefaultHashMap$get$254$(stamp_to_action_id, action.stamp);
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$get_used_production_num$124$153(used_productions, prod) {
  const _p = moonbitlang$core$array$$Array$search$34$(used_productions, prod);
  if (_p === undefined) {
    return $panic();
  } else {
    const _p$2 = _p;
    return _p$2;
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$add_symbol_decision$124$184(decision_groups, symbol, decision) {
  const _p = moonbitlang$core$sorted_map$$SortedMap$get$243$(decision_groups, decision);
  const _p$2 = $64$moonbitlang$47$core$47$immut$47$sorted_set$46$SortedSet$Empty$27$;
  let _tmp;
  if (_p === undefined) {
    _tmp = _p$2;
  } else {
    const _p$3 = _p;
    _tmp = _p$3;
  }
  moonbitlang$core$sorted_map$$SortedMap$set$243$(decision_groups, decision, moonbitlang$core$immut$sorted_set$$SortedSet$add$170$(_tmp, symbol));
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$to_codegen_decision$124$196(no_lookahead_needed, decision) {
  if (decision === undefined) {
    return $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Error;
  } else {
    const _Some = decision;
    const _x = _Some;
    switch (_x.$tag) {
      case 2: {
        return $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Accept;
      }
      case 0: {
        const _Shift = _x;
        const _next_state = _Shift._0;
        return new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Shift(_next_state);
      }
      case 1: {
        const _Reduce = _x;
        const _production = _Reduce._0;
        return no_lookahead_needed ? new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$ReduceNoLookahead(_production) : new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Reduce(_production);
      }
      default: {
        return $panic();
      }
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner(grammar, automaton, meta, output, source_map_builder, grammar_filename, external_tokens, no_comments, mode, input_mode, compress) {
  const used_runtime_funcs = moonbitlang$core$sorted_set$$SortedSet$new$13$();
  const _terminal_meta = meta.terminal_meta;
  const _nonterminal_meta = meta.nonterminal_meta;
  const _production_meta = meta.production_meta;
  const _it = moonbitlang$core$immut$array$$T$iter$65$(meta.header);
  while (true) {
    const _bind = moonbitlang$core$builtin$$Iter$next$65$(_it);
    if (_bind === undefined) {
      break;
    } else {
      const _Some = _bind;
      const _chunk = _Some;
      const _code = _chunk._0;
      const _original_range = _chunk._1;
      if (source_map_builder.$tag === 0) {
      } else {
        if (_original_range === undefined) {
        } else {
          const _Some$2 = source_map_builder;
          const _source_map_builder = _Some$2._0;
          const _Some$3 = _original_range;
          const _x = _Some$3;
          const _original_utf8_pos = _x._0;
          const _utf8_len = _x._1;
          const generated_utf8_pos = output.cursor;
          _source_map_builder.method_table.method_0(_source_map_builder.self, grammar_filename, _original_utf8_pos, generated_utf8_pos, _utf8_len);
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, _code);
      continue;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "\n");
  if (external_tokens) {
  } else {
    moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen_tokens$46$inner(grammar.terminals, _terminal_meta, { self: output, method_table: $$$64$moonbitlang$47$yacc$47$lib$47$util$47$logger_with_cursor$46$LoggerWithCursor$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger }, no_comments, meta.derive_map);
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, `pub suberror ParseError {\n  UnexpectedToken(Token, (${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}), Array[TokenKind])\n`);
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `  UnexpectedEndOfInput(${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, Array[TokenKind])\n`);
  }
  const _bind = moonbitlang$yacc$lib$util$array_multimap$$T$get$256$(meta.derive_map, moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$type_$124$37);
  let _tmp;
  if (_bind.length === 0) {
    _tmp = "";
  } else {
    const joined = moonbitlang$core$builtin$$Iter$join(moonbitlang$core$array$$Array$iter$13$(_bind), ", ");
    _tmp = ` derive(${joined})`;
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, `}${_tmp}\n\n`);
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "type YYObj = Error\n\n");
  if (mode === 0) {
    const data_types = moonbitlang$core$sorted_set$$SortedSet$new$75$();
    const _arr = grammar.terminals;
    const _len = _arr.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len) {
        const term = _arr[_i];
        const meta$2 = _terminal_meta(term.name);
        _L: {
          _L$2: {
            const _bind$2 = meta$2.data_type;
            if (_bind$2.$tag === 0) {
              const _Constr = _bind$2;
              const _x = _Constr._0;
              if (_x === undefined) {
                const _x$2 = _Constr._1;
                if (_x$2 === "Unit") {
                  const _x$3 = _Constr._2;
                  if (_x$3.length === 0) {
                  } else {
                    break _L$2;
                  }
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$2;
            }
            break _L;
          }
          moonbitlang$core$sorted_set$$SortedSet$add$75$(data_types, meta$2.data_type);
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const dedup = moonbitlang$core$set$$Set$new$46$inner$81$(8);
    const _env = { _0: dedup, _1: data_types };
    const _arr$2 = automaton.states;
    const _len$2 = _arr$2.length;
    let _tmp$3 = 0;
    while (true) {
      const _i = _tmp$3;
      if (_i < _len$2) {
        const state = _arr$2[_i];
        const _it$2 = moonbitlang$core$sorted_map$$SortedMap$iter2$226$(state.action);
        while (true) {
          const _bind$2 = moonbitlang$core$builtin$$Iter2$next$226$(_it$2);
          if (_bind$2 === undefined) {
            break;
          } else {
            const _Some = _bind$2;
            const _x = _Some;
            const _action = _x._1;
            switch (_action.$tag) {
              case 0: {
                break;
              }
              case 2: {
                break;
              }
              case 1: {
                const _Reduce = _action;
                const _production = _Reduce._0;
                if (!moonbitlang$core$array$$Array$contains$34$(grammar.starts, _production)) {
                  const meta$2 = _production_meta(_production.num);
                  moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$add_action$124$54(_env, meta$2.action);
                }
                break;
              }
              default: {
                $panic();
              }
            }
            continue;
          }
        }
        _tmp$3 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "priv suberror YYObj_Void\n\n");
    const _it$2 = moonbitlang$core$sorted_set$$SortedSet$iter$75$(data_types);
    while (true) {
      const _bind$2 = moonbitlang$core$builtin$$Iter$next$75$(_it$2);
      if (_bind$2 === undefined) {
        break;
      } else {
        const _Some = _bind$2;
        const _data_type = _Some;
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `priv suberror YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(_data_type)} ${moonbitlang$core$builtin$$Show$to_string$122$(_data_type)}\n\n`);
        continue;
      }
    }
  } else {
    if (input_mode === 0) {
      moonbitlang$core$builtin$$Logger$write_string$5$(output, "priv suberror YYObj_Void\n\n");
    }
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "priv suberror YYObj_Json Json\n\n");
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, `type YYState = Int\n\ntype YYAction = (${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ArrayView[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})]) -> YYObj\n\npriv enum YYDecision {\n  Accept\n  Shift(YYState)\n  Reduce(Int, YYSymbol, YYAction)\n  ReduceNoLookahead(Int, YYSymbol, YYAction)\n  Error\n}\n\n`);
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "type YYSymbol = Int\n\n");
  const actions = moonbitlang$yacc$lib$util$hashmap2$$new$129$(16);
  const _arr = automaton.states;
  const _len = _arr.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len) {
      const state = _arr[_i];
      const _it$2 = moonbitlang$core$sorted_map$$SortedMap$iter2$226$(state.action);
      while (true) {
        const _bind$2 = moonbitlang$core$builtin$$Iter2$next$226$(_it$2);
        if (_bind$2 === undefined) {
          break;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _decision = _x._1;
          if (_decision.$tag === 1) {
            const _Reduce = _decision;
            const _production = _Reduce._0;
            if (!moonbitlang$core$array$$Array$contains$34$(grammar.starts, _production)) {
              const meta$2 = _production_meta(_production.num);
              moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$add_action$124$74(actions, meta$2.action);
            } else {
              continue;
            }
          }
          continue;
        }
      }
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const next_action_id = { val: 0 };
  const stamp_to_action_id = moonbitlang$yacc$lib$util$default_hashmap$$new$254$((_key) => {
    const action_id = next_action_id.val;
    next_action_id.val = next_action_id.val + 1 | 0;
    return action_id;
  });
  const _it$2 = moonbitlang$yacc$lib$util$hashmap2$$T$iterator2$129$(actions);
  while (true) {
    const _bind$2 = moonbitlang$core$builtin$$Iter2$next$129$(_it$2);
    if (_bind$2 === undefined) {
      break;
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      const _action = _x._1;
      const clause_info = _action.original_clause_info;
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `// file:///./${clause_info.file}\n`);
      const clause_lines = moonbitlang$core$builtin$$Iter$to_array$14$(moonbitlang$core$string$$String$split(clause_info.code, { str: moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$42$bind$124$694, start: 0, end: moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$42$bind$124$694.length }));
      const max_line_number = (clause_info.line + 1 | 0) + (clause_lines.length - 1 | 0) | 0;
      const num_digits = moonbitlang$core$int$$Int$to_string$46$inner(max_line_number, 10).length;
      const _len$2 = clause_lines.length;
      let _tmp$3 = 0;
      while (true) {
        const _i = _tmp$3;
        if (_i < _len$2) {
          const line = clause_lines[_i];
          moonbitlang$core$builtin$$Logger$write_string$5$(output, "// ");
          const line_number = (clause_info.line + 1 | 0) + _i | 0;
          const line_number_str = moonbitlang$core$string$$String$pad_start(moonbitlang$core$int$$Int$to_string$46$inner(line_number, 10), num_digits, 32);
          moonbitlang$core$builtin$$Logger$write_string$5$(output, line_number_str);
          moonbitlang$core$builtin$$Logger$write_char$5$(output, 124);
          if (_i === 0) {
            if (clause_info.column > 0) {
              moonbitlang$core$builtin$$Logger$write_string$5$(output, moonbitlang$core$string$$String$repeat(" ", clause_info.column));
            }
          }
          moonbitlang$core$builtin$$Logger$write_string$5$(output, moonbitlang$core$builtin$$Show$to_string$14$(line));
          moonbitlang$core$builtin$$Logger$write_char$5$(output, 10);
          _tmp$3 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn yy_action_${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$get_action_id$124$91(stamp_to_action_id, _action))}(_last_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, _args : ArrayView[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})]) -> YYObj {\n`);
      const _arr$2 = _action.sub_actions;
      const _len$3 = _arr$2.length;
      let _tmp$4 = 0;
      while (true) {
        const _i = _tmp$4;
        if (_i < _len$3) {
          const sub_action = _arr$2[_i];
          const _start = sub_action.start;
          const _end = sub_action.end;
          const _action2 = sub_action.action;
          const last_pos_code = _start === 0 ? "_last_pos" : `_args[${moonbitlang$core$builtin$$Show$to_string$111$(_start - 1 | 0)}].2`;
          moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let _sub_action_${moonbitlang$core$builtin$$Show$to_string$111$(_i)}_result = yy_action_${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$get_action_id$124$91(stamp_to_action_id, _action2))}(${last_pos_code}, _args[${moonbitlang$core$builtin$$Show$to_string$111$(_start)}:${moonbitlang$core$builtin$$Show$to_string$111$(_end)}])\n`);
          _tmp$4 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const _arr$3 = _action.bindings;
      const _len$4 = _arr$3.length;
      let _tmp$5 = 0;
      while (true) {
        const _i = _tmp$5;
        if (_i < _len$4) {
          const binding = _arr$3[_i];
          let index;
          _L: {
            _L$2: {
              const _bind$3 = binding._0;
              switch (_bind$3.$tag) {
                case 0: {
                  const _Data = _bind$3;
                  const _index = _Data._0;
                  const _type_ = _Data._1;
                  _L$3: {
                    _L$4: {
                      if (_type_.$tag === 0) {
                        const _Constr = _type_;
                        const _x$2 = _Constr._0;
                        if (_x$2 === undefined) {
                          const _x$3 = _Constr._1;
                          if (_x$3 === "Unit") {
                            const _x$4 = _Constr._2;
                            if (_x$4.length === 0) {
                              moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = ()\n`);
                            } else {
                              break _L$4;
                            }
                          } else {
                            break _L$4;
                          }
                        } else {
                          break _L$4;
                        }
                      } else {
                        break _L$4;
                      }
                      break _L$3;
                    }
                    moonbitlang$core$builtin$$Logger$write_string$5$(output, `  guard _args[${moonbitlang$core$builtin$$Show$to_string$111$(_index)}].0 is YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(_type_)}(${binding._1})\n`);
                  }
                  break;
                }
                case 3: {
                  moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = if _args.length() == 0 { _last_pos } else { _args[0].1 }\n`);
                  break;
                }
                case 4: {
                  moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = if _args.length() == 0 { _last_pos } else { _args[_args.length() - 1].2 }\n`);
                  break;
                }
                case 1: {
                  const _StartPosOf = _bind$3;
                  const _index$2 = _StartPosOf._0;
                  index = _index$2;
                  break _L$2;
                }
                case 2: {
                  const _EndPosOf = _bind$3;
                  const _index$3 = _EndPosOf._0;
                  index = _index$3;
                  break _L$2;
                }
                case 5: {
                  moonbitlang$core$sorted_set$$SortedSet$add$13$(used_runtime_funcs, "_get_symbol_start_pos");
                  moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = _get_symbol_start_pos(_args, _last_pos)\n`);
                  break;
                }
                default: {
                  const _SubAction = _bind$3;
                  const _index$4 = _SubAction._0;
                  const _type_$2 = _SubAction._1;
                  _L$4: {
                    _L$5: {
                      if (_type_$2.$tag === 0) {
                        const _Constr = _type_$2;
                        const _x$2 = _Constr._0;
                        if (_x$2 === undefined) {
                          const _x$3 = _Constr._1;
                          if (_x$3 === "Unit") {
                            const _x$4 = _Constr._2;
                            if (_x$4.length === 0) {
                              moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = ()\n`);
                            } else {
                              break _L$5;
                            }
                          } else {
                            break _L$5;
                          }
                        } else {
                          break _L$5;
                        }
                      } else {
                        break _L$5;
                      }
                      break _L$4;
                    }
                    moonbitlang$core$builtin$$Logger$write_string$5$(output, `  guard _sub_action_${moonbitlang$core$builtin$$Show$to_string$111$(_index$4)}_result is YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(_type_$2)}(${binding._1})\n`);
                  }
                }
              }
              break _L;
            }
            if (_action.arity === 0) {
              moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = _last_pos\n`);
            } else {
              const _bind$3 = binding._0;
              let field;
              switch (_bind$3.$tag) {
                case 1: {
                  field = 1;
                  break;
                }
                case 2: {
                  field = 2;
                  break;
                }
                default: {
                  field = $panic();
                }
              }
              moonbitlang$core$builtin$$Logger$write_string$5$(output, `  let ${binding._1} = _args[${moonbitlang$core$builtin$$Show$to_string$111$(index)}].${moonbitlang$core$builtin$$Show$to_string$111$(field)}\n`);
            }
          }
          _tmp$5 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const result_data_type = _action.type_;
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `  YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(result_data_type)}({(); `);
      const _arr$4 = _action.body;
      const _len$5 = _arr$4.length;
      let _tmp$6 = 0;
      while (true) {
        const _i = _tmp$6;
        if (_i < _len$5) {
          const part = _arr$4[_i];
          const _code = part._0;
          const _original_range = part._1;
          if (_original_range === undefined) {
          } else {
            const _Some$2 = _original_range;
            const _x$2 = _Some$2;
            const _original_utf8_pos = _x$2._0;
            const _original_utf8_len = _x$2._1;
            const generated_utf8_pos = output.cursor;
            if (source_map_builder.$tag === 0) {
            } else {
              const _Some$3 = source_map_builder;
              const _source_map_builder = _Some$3._0;
              if (_code.length === _original_utf8_len) {
                _source_map_builder.method_table.method_0(_source_map_builder.self, grammar_filename, _original_utf8_pos, generated_utf8_pos, _code.length);
              }
            }
          }
          moonbitlang$core$builtin$$Logger$write_string$5$(output, _code);
          _tmp$6 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, "})\n");
      moonbitlang$core$builtin$$Logger$write_string$5$(output, "}\n\n");
      continue;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn yy_input(token : Token, _start_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, _end_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}) -> (YYSymbol, YYObj) {\n  match token {\n`);
  const _arr$2 = grammar.terminals;
  const _len$2 = _arr$2.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$2) {
      const term = _arr$2[_i];
      const meta$2 = _terminal_meta(term.name);
      if (mode === 0) {
        _L: {
          _L$2: {
            const _bind$2 = meta$2.data_type;
            if (_bind$2.$tag === 0) {
              const _Constr = _bind$2;
              const _x = _Constr._0;
              if (_x === undefined) {
                const _x$2 = _Constr._1;
                if (_x$2 === "Unit") {
                  const _x$3 = _Constr._2;
                  if (_x$3.length === 0) {
                    moonbitlang$core$builtin$$Logger$write_string$5$(output, `    ${term.name} => (${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode(new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$T(term), grammar))}, YYObj_Void)\n`);
                  } else {
                    break _L$2;
                  }
                } else {
                  break _L$2;
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$2;
            }
            break _L;
          }
          moonbitlang$core$builtin$$Logger$write_string$5$(output, `    ${term.name}(data) => (${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode(new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$T(term), grammar))}, YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(meta$2.data_type)}(data))\n`);
        }
      } else {
        const _bind$2 = meta$2.data_type;
        let payload_code;
        if (_bind$2.$tag === 0) {
          const _Constr = _bind$2;
          const _x = _Constr._0;
          if (_x === undefined) {
            const _x$2 = _Constr._1;
            if (_x$2 === "Unit") {
              const _x$3 = _Constr._2;
              payload_code = _x$3.length === 0 ? "" : "(data)";
            } else {
              payload_code = "(data)";
            }
          } else {
            payload_code = "(data)";
          }
        } else {
          payload_code = "(data)";
        }
        const _bind$3 = meta$2.data_type;
        let data_code;
        if (_bind$3.$tag === 0) {
          const _Constr = _bind$3;
          const _x = _Constr._0;
          if (_x === undefined) {
            const _x$2 = _Constr._1;
            if (_x$2 === "Unit") {
              const _x$3 = _Constr._2;
              data_code = _x$3.length === 0 ? "Json::null()" : "data.to_json()";
            } else {
              data_code = "data.to_json()";
            }
          } else {
            data_code = "data.to_json()";
          }
        } else {
          data_code = "data.to_json()";
        }
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `    ${term.name}${payload_code} => (${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode(new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$T(term), grammar))}, YYObj_Json({\n      \"type\": \"TERMINAL\",\n      \"name\": \"${term.name}\",\n      \"data\": ${data_code},\n      \"start\": _start_pos.to_json(),\n      \"end\": _end_pos.to_json()\n    }))\n`);
      }
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "  }\n}\n\n");
  const used_productions = moonbitlang$core$sorted_set$$SortedSet$new$34$();
  const _arr$3 = automaton.states;
  const _len$3 = _arr$3.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$3) {
      const state = _arr$3[_i];
      const _it$3 = moonbitlang$core$sorted_map$$SortedMap$iter2$226$(state.action);
      while (true) {
        const _bind$2 = moonbitlang$core$builtin$$Iter2$next$226$(_it$3);
        if (_bind$2 === undefined) {
          break;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _decision = _x._1;
          if (_decision.$tag === 1) {
            const _Reduce = _decision;
            const _production = _Reduce._0;
            moonbitlang$core$sorted_set$$SortedSet$add$34$(used_productions, _production);
          }
          continue;
        }
      }
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const used_productions$2 = moonbitlang$core$sorted_set$$SortedSet$to_array$34$(used_productions);
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "let yy_prod_lhs_table : FixedArray[Int] = [");
  const _len$4 = used_productions$2.length;
  let _tmp$5 = 0;
  while (true) {
    const _i = _tmp$5;
    if (_i < _len$4) {
      const production = used_productions$2[_i];
      if (_i > 0) {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, ", ");
      }
      const _p = production.lhs;
      moonbitlang$core$builtin$$Logger$write_string$5$(output, moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode(new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$NT(_p), grammar)));
      _tmp$5 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "]\n\n");
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "let yy_prod_len_table : FixedArray[Int] = [");
  const _len$5 = used_productions$2.length;
  let _tmp$6 = 0;
  while (true) {
    const _i = _tmp$6;
    if (_i < _len$5) {
      const production = used_productions$2[_i];
      if (_i > 0) {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, ", ");
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, moonbitlang$core$builtin$$Show$to_string$111$(production.rhs.length));
      _tmp$6 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "]\n\n");
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "let yy_prod_act_table : FixedArray[YYAction] = [");
  const _len$6 = used_productions$2.length;
  let _tmp$7 = 0;
  while (true) {
    const _i = _tmp$7;
    if (_i < _len$6) {
      const production = used_productions$2[_i];
      if (_i > 0) {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, ", ");
      }
      const prod_num = production.num;
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `yy_action_${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$get_action_id$124$91(stamp_to_action_id, _production_meta(prod_num).action))}`);
      _tmp$7 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "]\n\n");
  const state_table = [];
  const _arr$4 = automaton.states;
  const _len$7 = _arr$4.length;
  let _tmp$8 = 0;
  while (true) {
    const _i = _tmp$8;
    if (_i < _len$7) {
      const state = _arr$4[_i];
      const decision_groups = moonbitlang$core$sorted_map$$SortedMap$new$243$();
      const _it$3 = moonbitlang$core$sorted_map$$SortedMap$iter2$226$(state.action);
      while (true) {
        const _bind$2 = moonbitlang$core$builtin$$Iter2$next$226$(_it$3);
        if (_bind$2 === undefined) {
          break;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _input = _x._0;
          const _decision = _x._1;
          let _tmp$9;
          if (_input.$tag === 1) {
            const _Input = _input;
            const _term = _Input._0;
            _tmp$9 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$T(_term);
          } else {
            _tmp$9 = $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$EOI;
          }
          const _tmp$10 = _tmp$9;
          let _tmp$11;
          switch (_decision.$tag) {
            case 2: {
              _tmp$11 = $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Accept;
              break;
            }
            case 0: {
              const _Shift = _decision;
              const _next_state = _Shift._0;
              _tmp$11 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Shift(_next_state);
              break;
            }
            case 1: {
              const _Reduce = _decision;
              const _production = _Reduce._0;
              _tmp$11 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Reduce(_production);
              break;
            }
            default: {
              _tmp$11 = $panic();
            }
          }
          moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$add_symbol_decision$124$184(decision_groups, _tmp$10, _tmp$11);
          continue;
        }
      }
      const _it$4 = moonbitlang$core$sorted_map$$SortedMap$iter2$227$(state.goto);
      while (true) {
        const _bind$2 = moonbitlang$core$builtin$$Iter2$next$227$(_it$4);
        if (_bind$2 === undefined) {
          break;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _symbol = _x._0;
          const _state = _x._1;
          if (_symbol.$tag === 1) {
            const _NT = _symbol;
            const _nonterm = _NT._0;
            moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$add_symbol_decision$124$184(decision_groups, new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$NT(_nonterm), new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Shift(_state));
          }
          continue;
        }
      }
      const _self = [];
      moonbitlang$core$array$$Array$push_iter$73$(_self, moonbitlang$core$sorted_map$$SortedMap$keys_as_iter$243$(decision_groups));
      const _bind$2 = moonbitlang$core$array$$Array$at$73$(_self, 0);
      let no_lookahead_needed;
      switch (_bind$2.$tag) {
        case 3: {
          no_lookahead_needed = true;
          break;
        }
        case 1: {
          no_lookahead_needed = true;
          break;
        }
        default: {
          no_lookahead_needed = false;
        }
      }
      const _it$5 = moonbitlang$core$builtin$$Add$add$225$(moonbitlang$core$builtin$$Add$add$225$(moonbitlang$core$builtin$$Iter$singleton$170$($64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$EOI), moonbitlang$core$builtin$$Iter$map$183$(moonbitlang$core$array$$Array$iter$55$(grammar.terminals), (t) => new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$T(t))), moonbitlang$core$builtin$$Iter$map$184$(moonbitlang$core$array$$Array$iter$53$(grammar.nonterminals), (nt) => new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$NT(nt)));
      while (true) {
        const _bind$3 = moonbitlang$core$builtin$$Iter$next$170$(_it$5);
        if (_bind$3 === undefined) {
          break;
        } else {
          const _Some = _bind$3;
          const _symbol = _Some;
          let decision;
          switch (_symbol.$tag) {
            case 2: {
              decision = moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$to_codegen_decision$124$196(no_lookahead_needed, moonbitlang$core$sorted_map$$SortedMap$get$226$(state.action, $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput));
              break;
            }
            case 0: {
              const _T = _symbol;
              const _t = _T._0;
              decision = moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$to_codegen_decision$124$196(no_lookahead_needed, moonbitlang$core$sorted_map$$SortedMap$get$226$(state.action, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(_t)));
              break;
            }
            default: {
              const _NT = _symbol;
              const _nt = _NT._0;
              const _bind$4 = moonbitlang$core$sorted_map$$SortedMap$get$227$(state.goto, new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$NT(_nt));
              if (_bind$4 === undefined) {
                decision = $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Error;
              } else {
                const _Some$2 = _bind$4;
                const _next_state = _Some$2;
                decision = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenDecision$Shift(_next_state);
              }
            }
          }
          let _tmp$9;
          switch (decision.$tag) {
            case 0: {
              _tmp$9 = 0;
              break;
            }
            case 1: {
              _tmp$9 = 1;
              break;
            }
            case 2: {
              const _Shift = decision;
              const _next_state = _Shift._0;
              _tmp$9 = 2 + _next_state.num | 0;
              break;
            }
            case 3: {
              const _Reduce = decision;
              const _production = _Reduce._0;
              _tmp$9 = (2 + automaton.states.length | 0) + moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$get_used_production_num$124$153(used_productions$2, _production) | 0;
              break;
            }
            default: {
              const _ReduceNoLookahead = decision;
              const _production$2 = _ReduceNoLookahead._0;
              _tmp$9 = ((2 + automaton.states.length | 0) + used_productions$2.length | 0) + moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner$46$get_used_production_num$124$153(used_productions$2, _production$2) | 0;
            }
          }
          moonbitlang$core$array$$Array$push$17$(state_table, _tmp$9);
          continue;
        }
      }
      _tmp$8 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let state_table$2;
  if (compress) {
    let _return_value;
    _L: {
      _L$2: {
        if (state_table.length === 0) {
          const _tmp$9 = [];
          _return_value = _tmp$9;
          break _L$2;
        }
        const output$2 = [];
        let last = moonbitlang$core$array$$Array$at$17$(state_table, 0);
        let count = 1;
        const _arr$5 = moonbitlang$core$array$$Array$sub$46$inner$17$(state_table, 1, undefined);
        const _len$8 = _arr$5.end - _arr$5.start | 0;
        let _tmp$9 = 0;
        while (true) {
          const _i = _tmp$9;
          if (_i < _len$8) {
            const val = _arr$5.buf[_arr$5.start + _i | 0];
            if (val === last) {
              count = count + 1 | 0;
            } else {
              moonbitlang$core$array$$Array$push$17$(output$2, last);
              if (count > 1) {
                moonbitlang$core$array$$Array$push$17$(output$2, -count | 0);
              }
              last = val;
              count = 1;
            }
            _tmp$9 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        state_table$2 = output$2;
        break _L;
      }
      state_table$2 = _return_value;
    }
  } else {
    state_table$2 = state_table;
  }
  if (compress) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "fn yy_decompress(input : FixedArray[Int]) -> FixedArray[Int] {\n  let output = []\n  let mut last = 0\n  for val in input {\n    if val < 0 {\n      let count = -val - 1\n      for _ in 0..<count {\n        output.push(last)\n      }\n    } else {\n      output.push(val)\n      last = val\n    }\n  }\n  FixedArray::from_array(output)\n}\n\nlet yy_state_table : FixedArray[Int] = yy_decompress([");
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "let yy_state_table : FixedArray[Int] = [");
  }
  const _len$8 = state_table$2.length;
  let _tmp$9 = 0;
  while (true) {
    const _i = _tmp$9;
    if (_i < _len$8) {
      const state = state_table$2[_i];
      if (_i > 0) {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, ", ");
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, moonbitlang$core$builtin$$Show$to_string$111$(state));
      _tmp$9 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (compress) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "])\n\n");
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "]\n\n");
  }
  const symbol_cardinality = (1 + grammar.terminals.length | 0) + grammar.nonterminals.length | 0;
  moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn yy_state(state : YYState, symbol : YYSymbol) -> YYDecision {\n  let encoded = yy_state_table[state * ${moonbitlang$core$builtin$$Show$to_string$111$(symbol_cardinality)} + symbol]\n  match encoded {\n    0 => Error\n    1 => Accept\n    2..=${moonbitlang$core$builtin$$Show$to_string$111$((2 + automaton.states.length | 0) - 1 | 0)} => Shift(encoded - 2)\n    ${moonbitlang$core$builtin$$Show$to_string$111$(2 + automaton.states.length | 0)}..=${moonbitlang$core$builtin$$Show$to_string$111$(((2 + automaton.states.length | 0) + used_productions$2.length | 0) - 1 | 0)} =>\n      Reduce(\n        yy_prod_len_table[encoded - ${moonbitlang$core$builtin$$Show$to_string$111$(2 + automaton.states.length | 0)}],\n        yy_prod_lhs_table[encoded - ${moonbitlang$core$builtin$$Show$to_string$111$(2 + automaton.states.length | 0)}],\n        yy_prod_act_table[encoded - ${moonbitlang$core$builtin$$Show$to_string$111$(2 + automaton.states.length | 0)}],\n      )\n    ${moonbitlang$core$builtin$$Show$to_string$111$((2 + automaton.states.length | 0) + used_productions$2.length | 0)}..<_ =>\n      ReduceNoLookahead(\n        yy_prod_len_table[encoded - ${moonbitlang$core$builtin$$Show$to_string$111$((2 + automaton.states.length | 0) + used_productions$2.length | 0)}],\n        yy_prod_lhs_table[encoded - ${moonbitlang$core$builtin$$Show$to_string$111$((2 + automaton.states.length | 0) + used_productions$2.length | 0)}],\n        yy_prod_act_table[encoded - ${moonbitlang$core$builtin$$Show$to_string$111$((2 + automaton.states.length | 0) + used_productions$2.length | 0)}],\n      )\n    _ => panic()\n  }\n}\n\n`);
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn[T] yy_parse(\n  tokens : Array[(Token, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})],\n  start : YYState,\n  return_ : (YYObj) -> T,\n  initial_pos? : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)},\n) -> T raise ParseError {\n  let mut cursor = 0\n  let mut state_stack : @list.List[YYState] = @list.cons(start, @list.empty())\n  let data_stack : Array[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})] = []\n  let mut last_pos = initial_pos.unwrap_or(tokens[0].1)\n  let mut state = start\n  let mut lookahead : Option[(YYSymbol, (YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}), Token?)] = None\n  let mut last_shifted_state_stack = state_stack\n  while true {\n    let decision = match yy_state(state, ${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode($64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$EOI, grammar))}) {\n      ReduceNoLookahead(_) | Accept as t => t\n      _ => {\n        match lookahead {\n          Some(la) => yy_state(state, la.0)\n          None => {\n            if cursor < tokens.length() {\n              let (token, start_pos, end_pos) = tokens[cursor]\n              cursor += 1\n              let (symbol, data) = yy_input(token, start_pos, end_pos)\n              lookahead = Some((symbol, (data, start_pos, end_pos), Some(token)))\n              yy_state(state, symbol)\n            } else {\n              lookahead = Some((${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode($64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$EOI, grammar))}, (YYObj_Void, last_pos, last_pos), None))\n              yy_state(state, ${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode($64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$EOI, grammar))})\n            }\n          }\n        }\n      }\n    }\n    match decision {\n      Accept => return return_(data_stack.unsafe_pop().0)\n      Shift(next_state) => {\n        guard lookahead is Some(la)\n        data_stack.push(la.1)\n        state_stack = @list.cons(next_state, state_stack)\n        last_shifted_state_stack = state_stack\n        state = next_state\n        last_pos = la.1.2\n        lookahead = None\n      }\n      Reduce(count, symbol, action)\n      | ReduceNoLookahead(count, symbol, action) => {\n        loop (count, symbol, action) {\n          _ => {\n            let args = data_stack[data_stack.length() - count:]\n            let data = action(last_pos, args)\n            let (start_pos, end_pos) = if args.length() == 0 {\n              (last_pos, last_pos)\n            } else {\n              (args[0].1, args[args.length() - 1].2)\n            }\n            for i in 0..<count {\n              ignore(data_stack.unsafe_pop())\n              state_stack = state_stack.unsafe_tail()\n            }\n            state = state_stack.unsafe_head()\n            data_stack.push((data, start_pos, end_pos))\n            match yy_state(state, symbol) {\n              Accept => return return_(data_stack.unsafe_pop().0)\n              Shift(next_state) => {\n                state_stack = @list.cons(next_state, state_stack)\n                state = next_state\n              }\n              Reduce(count, symbol, action)\n              | ReduceNoLookahead(count, symbol, action) => continue (count, symbol, action)\n              _ => panic()\n            }\n          }\n        }\n      }\n      Error => {\n        let (_, (_, start_pos, end_pos), token) = lookahead.unwrap()\n        error(last_shifted_state_stack, token, (start_pos, end_pos))\n      }\n    }\n  }\n  panic()\n}\n\n`);
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn[T] yy_parse(\n  read_token : () -> (Token, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}),\n  start_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)},\n  start : YYState,\n  return_ : (YYObj) -> T\n) -> T raise ParseError {\n  let mut state_stack : @list.List[YYState] = @list.cons(start, @list.empty())\n  let data_stack : Array[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})] = []\n  let mut last_pos = start_pos\n  let mut state = start\n  let mut lookahead : Option[(YYSymbol, (YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}), Token)] = None\n  let mut last_shifted_state_stack = state_stack\n  while true {\n    let decision = match yy_state(state, ${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode($64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$EOI, grammar))}) {\n      ReduceNoLookahead(_) | Accept as t => t\n      _ => {\n        match lookahead {\n          Some(la) => yy_state(state, la.0)\n          None => {\n            let (token, start_pos, end_pos) = read_token()\n            let (symbol, data) = yy_input(token, start_pos, end_pos)\n            lookahead = Some((symbol, (data, start_pos, end_pos), token))\n            yy_state(state, symbol)\n          }\n        }\n      }\n    }\n    match decision {\n      Accept => return return_(data_stack.unsafe_pop().0)\n      Shift(next_state) => {\n        guard lookahead is Some(la)\n        data_stack.push(la.1)\n        state_stack = @list.cons(next_state, state_stack)\n        last_shifted_state_stack = state_stack\n        state = next_state\n        last_pos = la.1.2\n        lookahead = None\n      }\n      Reduce(count, symbol, action)\n      | ReduceNoLookahead(count, symbol, action) => {\n        loop (count, symbol, action) {\n          _ => {\n            let args = data_stack[data_stack.length() - count:]\n            let data = action(last_pos, args)\n            let (start_pos, end_pos) = if args.length() == 0 {\n              (last_pos, last_pos)\n            } else {\n              (args[0].1, args[args.length() - 1].2)\n            }\n            for i in 0..<count {\n              ignore(data_stack.unsafe_pop())\n              state_stack = state_stack.unsafe_tail()\n            }\n            state = state_stack.unsafe_head()\n            data_stack.push((data, start_pos, end_pos))\n            match yy_state(state, symbol) {\n              Accept => return return_(data_stack.unsafe_pop().0)\n              Shift(next_state) => {\n                state_stack = @list.cons(next_state, state_stack)\n                state = next_state\n              }\n              Reduce(count, symbol, action)\n              | ReduceNoLookahead(count, symbol, action) => continue (count, symbol, action)\n              _ => panic()\n            }\n          }\n        }\n      }\n      Error => {\n        let (_, (_, start_pos, end_pos), token) = lookahead.unwrap()\n        error(last_shifted_state_stack, token, (start_pos, end_pos))\n      }\n    }\n  }\n  panic()\n}\n\n`);
  }
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn error(stack : @list.List[YYState], token : Token?, loc : (${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})) -> Unit raise ParseError {\n`);
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `fn error(stack : @list.List[YYState], token : Token, loc : (${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})) -> Unit raise ParseError {\n`);
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "  let expected = []\n  fn try_add(symbol : YYSymbol, kind : TokenKind) {\n    fn go(stack : @list.List[YYState]) {\n      match stack {\n        Empty => ()\n        More(state, ..) => {\n          match yy_state(state, symbol) {\n            Accept | Shift(_) => expected.push(kind)\n            Reduce(count, symbol, _) | ReduceNoLookahead(count, symbol, _) => {\n              fn inner_go(stack : @list.List[YYState], count, symbol) {\n                let stack = stack.drop(count)\n                guard stack is More(state, ..)\n                match yy_state(state, symbol) {\n                  Shift(state) => go(@list.cons(state, stack))\n                  Reduce(count, symbol, _) | ReduceNoLookahead(count, symbol, _) => inner_go(stack, count, symbol)\n                  _ => panic()\n                }\n              }\n              inner_go(stack, count, symbol)\n            }\n            Error => ()\n          }\n        }\n      }\n    }\n    go(stack)\n  }\n");
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "  for term in ([");
  const _arr$5 = grammar.terminals;
  const _len$9 = _arr$5.length;
  let _tmp$10 = 0;
  while (true) {
    const _i = _tmp$10;
    if (_i < _len$9) {
      const term = _arr$5[_i];
      if (_i > 0) {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, ", ");
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, `(${moonbitlang$core$builtin$$Show$to_string$111$(moonbitlang$yacc$lib$codegen$gen_mbt_table$$CodegenSymbol$encode(new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt_table$46$CodegenSymbol$T(term), grammar))}, TK_${term.name})`);
      _tmp$10 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "] : Array[(YYSymbol, TokenKind)]) {\n");
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "    try_add(term.0, term.1)\n  }\n");
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "  match token {\n    None => raise UnexpectedEndOfInput(loc.1, expected)\n    Some(token) => raise UnexpectedToken(token, loc, expected)\n  }\n");
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, "  raise UnexpectedToken(token, loc, expected)\n");
  }
  moonbitlang$core$builtin$$Logger$write_string$5$(output, "}\n\n");
  const _arr$6 = automaton.starts;
  const _len$10 = _arr$6.length;
  let _tmp$11 = 0;
  while (true) {
    const _i = _tmp$11;
    if (_i < _len$10) {
      const start = _arr$6[_i];
      const _start_production = start._0;
      const _start_state = start._1;
      const name = _start_production.lhs.name;
      let original_name;
      let _try_err;
      _L: {
        _L$2: {
          const _bind$2 = moonbitlang$core$string$$String$sub$46$inner(name, 0, name.length - "_prime".length | 0);
          let _tmp$12;
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _tmp$12 = _ok._0;
          } else {
            const _err = _bind$2;
            const _tmp$13 = _err._0;
            _try_err = _tmp$13;
            break _L$2;
          }
          original_name = moonbitlang$core$builtin$$Show$to_string$14$(_tmp$12);
          break _L;
        }
        original_name = $panic();
      }
      if (input_mode === 0) {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `pub fn ${original_name}(tokens : Array[(Token, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})], initial_pos? : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}) -> ${moonbitlang$yacc$lib$codegen$gen_mbt_table$$fix_result_type(moonbitlang$core$builtin$$Show$to_string$122$(_nonterminal_meta(name).data_type))} raise ParseError {\n  yy_parse(\n    tokens,\n    ${moonbitlang$core$builtin$$Show$to_string$111$(_start_state.num)},\n    (it) => {\n      guard it is YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(_nonterminal_meta(name).data_type)}(result)\n      result\n    },\n    initial_pos?,\n  )\n}\n`);
      } else {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `pub fn ${original_name}(read_token : () -> (Token, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}), start_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}) -> ${moonbitlang$yacc$lib$codegen$gen_mbt_table$$fix_result_type(moonbitlang$core$builtin$$Show$to_string$122$(_nonterminal_meta(name).data_type))} raise ParseError {\n  yy_parse(\n    read_token,\n    start_pos,\n    ${moonbitlang$core$builtin$$Show$to_string$111$(_start_state.num)},\n    (it) => {\n      guard it is YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt_table$$derive_type_ident(_nonterminal_meta(name).data_type)}(result)\n      result\n    },\n  )\n}\n`);
      }
      _tmp$11 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _it$3 = moonbitlang$core$sorted_set$$SortedSet$iter$13$(used_runtime_funcs);
  while (true) {
    const _bind$2 = moonbitlang$core$builtin$$Iter$next$13$(_it$3);
    if (_bind$2 === undefined) {
      break;
    } else {
      const _Some = _bind$2;
      const _func = _Some;
      if (_func === "_get_symbol_start_pos") {
        moonbitlang$core$builtin$$Logger$write_string$5$(output, `\nfn _get_symbol_start_pos(args : ArrayView[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})], last_pos : ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}) -> ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)} {\n  if args.length() == 0 {\n    last_pos\n  } else {\n    for i = 0; i < args.length(); i = i + 1 {\n      let (_, start_pos, end_pos) = args[i]\n      if start_pos == end_pos {\n        continue\n      }\n      return start_pos\n    }\n    args[args.length() - 1].2\n  }\n}\n`);
      } else {
        $panic();
      }
      continue;
    }
  }
  if (mode === 0) {
  } else {
    moonbitlang$core$builtin$$Logger$write_string$5$(output, `\nfn args_to_json(args : ArrayView[(YYObj, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)}, ${moonbitlang$core$builtin$$Show$to_string$122$(meta.position_data_type)})]) -> Json {\n  Json::array(args.iter().map((it) => {\n    guard it.0 is YYObj_Json(json)\n    json\n  }).to_array())\n}\n`);
  }
  const _it$4 = moonbitlang$core$immut$array$$T$iter$65$(meta.footer);
  while (true) {
    const _bind$2 = moonbitlang$core$builtin$$Iter$next$65$(_it$4);
    if (_bind$2 === undefined) {
      return;
    } else {
      const _Some = _bind$2;
      const _chunk = _Some;
      const _code = _chunk._0;
      const _original_range = _chunk._1;
      if (source_map_builder.$tag === 0) {
      } else {
        if (_original_range === undefined) {
        } else {
          const _Some$2 = source_map_builder;
          const _source_map_builder = _Some$2._0;
          const _Some$3 = _original_range;
          const _x = _Some$3;
          const _original_utf8_pos = _x._0;
          const _utf8_len = _x._1;
          const generated_utf8_pos = output.cursor;
          _source_map_builder.method_table.method_0(_source_map_builder.self, grammar_filename, _original_utf8_pos, generated_utf8_pos, _utf8_len);
        }
      }
      moonbitlang$core$builtin$$Logger$write_string$5$(output, _code);
      continue;
    }
  }
}
function moonbitlang$yacc$lib$codegen$$CodeGenerator$void_type$1$(self) {
  return "Unit";
}
function moonbitlang$yacc$lib$codegen$$CodeGenerator$void_action_code$1$(self) {
  return "()";
}
function moonbitlang$yacc$lib$codegen$$CodeGenerator$codegen_tokens$1$(self, terminals, terminal_meta, output, no_comments, derive_map) {
  moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen_tokens$46$inner(terminals, terminal_meta, output, no_comments, derive_map);
}
function moonbitlang$yacc$lib$codegen$$CodeGenerator$codegen$1$(self, grammar, automaton, meta, output, source_map_builder, grammar_filename, external_tokens, no_comments, mode, input_mode) {
  moonbitlang$yacc$lib$codegen$gen_mbt_table$$codegen$46$inner(grammar, automaton, meta, output, source_map_builder, grammar_filename, external_tokens, no_comments, mode, input_mode, self.compress);
}
function moonbitlang$yacc$lib$desugar$$derive_term_ident(term) {
  switch (term.$tag) {
    case 0: {
      const _Token = term;
      const _token = _Token._0;
      return _token.name;
    }
    case 1: {
      return $panic();
    }
    default: {
      const _RuleCall = term;
      const _rule_name = _RuleCall._0;
      const _x = _RuleCall._1;
      return _x.length === 0 ? _rule_name : `${_rule_name}(${moonbitlang$core$builtin$$Iter$join(moonbitlang$core$builtin$$Iter$map$187$(moonbitlang$core$array$$Array$iter$67$(_x), moonbitlang$yacc$lib$desugar$$derive_term_ident), ",")})`;
    }
  }
}
function moonbitlang$yacc$lib$desugar$$infer_return_type$46$unify$124$68(generic_param_map, t1, t2) {
  let _tmp = t1;
  let _tmp$2 = t2;
  _L: while (true) {
    const t1$2 = _tmp;
    const t2$2 = _tmp$2;
    _L$2: {
      switch (t1$2.$tag) {
        case 1: {
          const _Param = t1$2;
          const _name = _Param._0;
          moonbitlang$core$builtin$$Map$set$220$(generic_param_map, _name, t2$2);
          return;
        }
        case 0: {
          const _Constr = t1$2;
          const _pkg1 = _Constr._0;
          const _name1 = _Constr._1;
          const _args1 = _Constr._2;
          if (t2$2.$tag === 0) {
            const _Constr$2 = t2$2;
            const _pkg2 = _Constr$2._0;
            const _name2 = _Constr$2._1;
            const _args2 = _Constr$2._2;
            if (moonbitlang$core$builtin$$Eq$equal$48$(_pkg1, _pkg2) && (_name1 === _name2 && _args1.length === _args2.length)) {
              const _len = _args1.length;
              let _tmp$3 = 0;
              while (true) {
                const _i = _tmp$3;
                if (_i < _len) {
                  const arg1 = _args1[_i];
                  moonbitlang$yacc$lib$desugar$$infer_return_type$46$unify$124$68(generic_param_map, arg1, moonbitlang$core$array$$Array$at$75$(_args2, _i));
                  _tmp$3 = _i + 1 | 0;
                  continue;
                } else {
                  return;
                }
              }
            } else {
              $panic();
              return;
            }
          } else {
            break _L$2;
          }
        }
        case 2: {
          const _Option = t1$2;
          const _t1 = _Option._0;
          if (t2$2.$tag === 2) {
            const _Option$2 = t2$2;
            const _t2 = _Option$2._0;
            _tmp = _t1;
            _tmp$2 = _t2;
            continue _L;
          } else {
            break _L$2;
          }
        }
        case 3: {
          const _Tuple = t1$2;
          const _types1 = _Tuple._0;
          if (t2$2.$tag === 3) {
            const _Tuple$2 = t2$2;
            const _types2 = _Tuple$2._0;
            if (_types1.length === _types2.length) {
              const _len = _types1.length;
              let _tmp$3 = 0;
              while (true) {
                const _i = _tmp$3;
                if (_i < _len) {
                  const type1 = _types1[_i];
                  moonbitlang$yacc$lib$desugar$$infer_return_type$46$unify$124$68(generic_param_map, type1, moonbitlang$core$array$$Array$at$75$(_types2, _i));
                  _tmp$3 = _i + 1 | 0;
                  continue;
                } else {
                  return;
                }
              }
            } else {
              $panic();
              return;
            }
          } else {
            break _L$2;
          }
        }
        default: {
          const _Arrow = t1$2;
          const _params1 = _Arrow._0;
          const _ret1 = _Arrow._1;
          if (t2$2.$tag === 4) {
            const _Arrow$2 = t2$2;
            const _params2 = _Arrow$2._0;
            const _ret2 = _Arrow$2._1;
            if (_params1.length === _params2.length) {
              const _len = _params1.length;
              let _tmp$3 = 0;
              while (true) {
                const _i = _tmp$3;
                if (_i < _len) {
                  const param1 = _params1[_i];
                  moonbitlang$yacc$lib$desugar$$infer_return_type$46$unify$124$68(generic_param_map, param1, moonbitlang$core$array$$Array$at$75$(_params2, _i));
                  _tmp$3 = _i + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              _tmp = _ret1;
              _tmp$2 = _ret2;
              continue _L;
            } else {
              $panic();
              return;
            }
          } else {
            break _L$2;
          }
        }
      }
    }
    $panic();
    return;
  }
}
function moonbitlang$yacc$lib$desugar$$infer_return_type(parametric_rule, env, json_cst) {
  if (json_cst === 1) {
    return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Json", []);
  }
  const _bind = [];
  const generic_param_map = moonbitlang$core$builtin$$Map$from_array$220$({ buf: _bind, start: 0, end: 0 });
  const _arr = parametric_rule.params;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const param = _arr[_i];
      const _p = moonbitlang$core$immut$sorted_map$$SortedMap$get$241$(env, param._0);
      let arg;
      if (_p === undefined) {
        arg = $panic();
      } else {
        const _p$2 = _p;
        arg = _p$2;
      }
      const _tmp$2 = param._1;
      let _tmp$3;
      switch (arg.$tag) {
        case 0: {
          const _Token = arg;
          const _token = _Token._0;
          _tmp$3 = _token.type_;
          break;
        }
        case 1: {
          const _Param = arg;
          _tmp$3 = _Param._1;
          break;
        }
        default: {
          const _RuleCall = arg;
          _tmp$3 = _RuleCall._2;
        }
      }
      moonbitlang$yacc$lib$desugar$$infer_return_type$46$unify$124$68(generic_param_map, _tmp$2, _tmp$3);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const process_type = (type_) => {
    switch (type_.$tag) {
      case 1: {
        const _Param = type_;
        const _name = _Param._0;
        const _p = moonbitlang$core$builtin$$Map$get$220$(generic_param_map, _name);
        if (_p === undefined) {
          return $panic();
        } else {
          const _p$2 = _p;
          return _p$2;
        }
      }
      case 0: {
        const _Constr = type_;
        const _pkg = _Constr._0;
        const _name$2 = _Constr._1;
        const _args = _Constr._2;
        const _p$2 = new Array(_args.length);
        const _p$3 = _args.length;
        let _tmp$2 = 0;
        while (true) {
          const _p$4 = _tmp$2;
          if (_p$4 < _p$3) {
            const _p$5 = _args[_p$4];
            _p$2[_p$4] = process_type(_p$5);
            _tmp$2 = _p$4 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(_pkg, _name$2, _p$2);
      }
      case 2: {
        const _Option = type_;
        const _type_ = _Option._0;
        return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Option(process_type(_type_));
      }
      case 3: {
        const _Tuple = type_;
        const _types = _Tuple._0;
        const _p$4 = new Array(_types.length);
        const _p$5 = _types.length;
        let _tmp$3 = 0;
        while (true) {
          const _p$6 = _tmp$3;
          if (_p$6 < _p$5) {
            const _p$7 = _types[_p$6];
            _p$4[_p$6] = process_type(_p$7);
            _tmp$3 = _p$6 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Tuple(_p$4);
      }
      default: {
        const _Arrow = type_;
        const _params = _Arrow._0;
        const _ret = _Arrow._1;
        const _p$6 = new Array(_params.length);
        const _p$7 = _params.length;
        let _tmp$4 = 0;
        while (true) {
          const _p$8 = _tmp$4;
          if (_p$8 < _p$7) {
            const _p$9 = _params[_p$8];
            _p$6[_p$8] = process_type(_p$9);
            _tmp$4 = _p$8 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Arrow(_p$6, process_type(_ret));
      }
    }
  };
  return process_type(parametric_rule.type_);
}
function moonbitlang$yacc$lib$desugar$$eliminate_rule_args$46$map_term$124$132(_env, term, env) {
  const json_cst = _env._2;
  const deferred_specialized_rules = _env._1;
  const spec = _env._0;
  switch (term.$tag) {
    case 0: {
      return term;
    }
    case 2: {
      const _RuleCall = term;
      const _rule_name = _RuleCall._0;
      const _x = _RuleCall._1;
      if (_x.length === 0) {
        const _type_ = _RuleCall._2;
        return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$RuleCall(_rule_name, [], _type_);
      } else {
        const _p = moonbitlang$core$builtin$$Map$get$216$(spec.rules, _rule_name);
        let parametric_rule;
        if (_p === undefined) {
          parametric_rule = $panic();
        } else {
          const _p$2 = _p;
          parametric_rule = _p$2;
        }
        const _p$2 = new Array(_x.length);
        const _p$3 = _x.length;
        let _tmp = 0;
        while (true) {
          const _p$4 = _tmp;
          if (_p$4 < _p$3) {
            const _p$5 = _x[_p$4];
            _p$2[_p$4] = moonbitlang$yacc$lib$desugar$$eliminate_rule_args$46$map_term$124$132(_env, _p$5, env);
            _tmp = _p$4 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const args = _p$2;
        let _tmp$2;
        let _tmp$3 = 0;
        let _tmp$4 = env;
        while (true) {
          const _p$4 = _tmp$3;
          const _p$5 = _tmp$4;
          if (_p$4 < args.length) {
            _tmp$3 = _p$4 + 1 | 0;
            const _p$6 = moonbitlang$core$array$$Array$at$67$(args, _p$4);
            const _p$7 = moonbitlang$core$array$$Array$at$71$(parametric_rule.params, _p$4);
            _tmp$4 = moonbitlang$core$immut$sorted_map$$SortedMap$add$241$(_p$5, _p$7._0, _p$6);
            continue;
          } else {
            _tmp$2 = _p$5;
            break;
          }
        }
        const type_ = moonbitlang$yacc$lib$desugar$$infer_return_type(parametric_rule, _tmp$2, json_cst);
        const specialized_rule_name = moonbitlang$yacc$lib$desugar$$derive_term_ident(new $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$RuleCall(_rule_name, args, type_));
        moonbitlang$core$builtin$$Map$set$217$(deferred_specialized_rules.val, specialized_rule_name, { parametric_rule_name: _rule_name, specialized_rule_name: specialized_rule_name, args: args, env: env });
        return new $64$moonbitlang$47$yacc$47$lib$47$elab$46$Term$RuleCall(specialized_rule_name, [], type_);
      }
    }
    default: {
      const _Param = term;
      const _name = _Param._0;
      const _bind = moonbitlang$core$immut$sorted_map$$SortedMap$get$241$(env, _name);
      if (_bind === undefined) {
        return term;
      } else {
        const _Some = _bind;
        return _Some;
      }
    }
  }
}
function moonbitlang$yacc$lib$desugar$$eliminate_rule_args(spec, json_cst) {
  const _bind = [];
  const deferred_specialized_rules = { val: moonbitlang$core$builtin$$Map$from_array$217$({ buf: _bind, start: 0, end: 0 }) };
  const _bind$2 = [];
  const parametric_rules = moonbitlang$core$builtin$$Map$from_array$216$({ buf: _bind$2, start: 0, end: 0 });
  const _bind$3 = [];
  const new_rules = moonbitlang$core$builtin$$Map$from_array$216$({ buf: _bind$3, start: 0, end: 0 });
  const _env = { _0: spec, _1: deferred_specialized_rules, _2: json_cst };
  const _it = moonbitlang$core$builtin$$Map$iter2$216$(spec.rules);
  while (true) {
    const _bind$4 = moonbitlang$core$builtin$$Iter2$next$216$(_it);
    if (_bind$4 === undefined) {
      break;
    } else {
      const _Some = _bind$4;
      const _x = _Some;
      const _rule_name = _x._0;
      const _rule = _x._1;
      const _p = _rule.params;
      if (_p.length === 0) {
        const _tmp = _rule.name;
        const _tmp$2 = _rule.inline;
        const _tmp$3 = _rule.generic_params;
        const _tmp$4 = _rule.params;
        const _tmp$5 = _rule.type_;
        const _p$2 = _rule.clauses;
        const _p$3 = new Array(_p$2.length);
        const _p$4 = _p$2.length;
        let _tmp$6 = 0;
        while (true) {
          const _p$5 = _tmp$6;
          if (_p$5 < _p$4) {
            const _p$6 = _p$2[_p$5];
            const _p$7 = _p$6.items;
            const _p$8 = new Array(_p$7.length);
            const _p$9 = _p$7.length;
            let _tmp$7 = 0;
            while (true) {
              const _p$10 = _tmp$7;
              if (_p$10 < _p$9) {
                const _p$11 = _p$7[_p$10];
                _p$8[_p$10] = { binder: _p$11.binder, term: moonbitlang$yacc$lib$desugar$$eliminate_rule_args$46$map_term$124$132(_env, _p$11.term, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$26$) };
                _tmp$7 = _p$10 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            const _p$10 = _p$8;
            const _p$11 = _p$6.items;
            const _p$12 = new Array(_p$11.length);
            const _p$13 = _p$11.length;
            let _tmp$8 = 0;
            while (true) {
              const _p$14 = _tmp$8;
              if (_p$14 < _p$13) {
                const _p$15 = _p$11[_p$14];
                _p$12[_p$14] = { binder: _p$15.binder, term: moonbitlang$yacc$lib$desugar$$eliminate_rule_args$46$map_term$124$132(_env, _p$15.term, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$SortedMap$Empty$26$) };
                _tmp$8 = _p$14 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            const _tmp$9 = _p$6.prec;
            const _tmp$10 = _p$6.action;
            const _tmp$11 = moonbitlang$yacc$lib$util$stamp$$new();
            const _p$14 = _p$6.action.bindings;
            const _p$15 = new Array(_p$14.length);
            const _p$16 = _p$14.length;
            let _tmp$12 = 0;
            while (true) {
              const _p$17 = _tmp$12;
              if (_p$17 < _p$16) {
                const _p$18 = _p$14[_p$17];
                const _p$19 = _p$18._0;
                const _p$20 = _p$18._1;
                let _p$21;
                if (_p$19.$tag === 0) {
                  const _p$22 = _p$19;
                  const _p$23 = _p$22._0;
                  _p$21 = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$Data(_p$23, moonbitlang$yacc$lib$elab$$Item$type_(moonbitlang$core$array$$Array$at$32$(_p$10, _p$23)));
                } else {
                  _p$21 = _p$19;
                }
                _p$15[_p$17] = { _0: _p$21, _1: _p$20 };
                _tmp$12 = _p$17 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            _p$3[_p$5] = { items: _p$12, prec: _tmp$9, action: { ..._tmp$10, stamp: _tmp$11, bindings: _p$15 } };
            _tmp$6 = _p$5 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        moonbitlang$core$builtin$$Map$set$216$(new_rules, _rule_name, { name: _tmp, inline: _tmp$2, generic_params: _tmp$3, params: _tmp$4, type_: _tmp$5, clauses: _p$3 });
      } else {
        moonbitlang$core$builtin$$Map$set$216$(parametric_rules, _rule_name, _rule);
      }
      continue;
    }
  }
  while (true) {
    const queue = moonbitlang$core$builtin$$Iter$to_array$139$(moonbitlang$core$builtin$$Iter$filter$139$(moonbitlang$core$builtin$$Map$values$217$(deferred_specialized_rules.val), (it) => !moonbitlang$core$builtin$$Map$contains$216$(new_rules, it.specialized_rule_name)));
    const _bind$4 = [];
    deferred_specialized_rules.val = moonbitlang$core$builtin$$Map$from_array$217$({ buf: _bind$4, start: 0, end: 0 });
    if (queue.length === 0) {
      break;
    }
    const _len = queue.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const it = queue[_i];
        const _tmp$2 = it.specialized_rule_name;
        const _parametric_rule_name = it.parametric_rule_name;
        const _specialized_rule_name = it.specialized_rule_name;
        const _args = it.args;
        const _env$2 = it.env;
        const _p = moonbitlang$core$builtin$$Map$get$216$(parametric_rules, _parametric_rule_name);
        let parametric_rule;
        if (_p === undefined) {
          parametric_rule = $panic();
        } else {
          const _p$2 = _p;
          parametric_rule = _p$2;
        }
        const env = { val: _env$2 };
        const _arr = parametric_rule.params;
        const _len$2 = _arr.length;
        let _tmp$3 = 0;
        while (true) {
          const _i$2 = _tmp$3;
          if (_i$2 < _len$2) {
            const param = _arr[_i$2];
            env.val = moonbitlang$core$immut$sorted_map$$SortedMap$add$241$(env.val, param._0, moonbitlang$core$array$$Array$at$67$(_args, _i$2));
            _tmp$3 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const type_ = moonbitlang$yacc$lib$desugar$$infer_return_type(parametric_rule, env.val, json_cst);
        const _bind$5 = moonbitlang$core$set$$Set$new$46$inner$13$(8);
        const _bind$6 = [];
        const _p$2 = parametric_rule.clauses;
        const _p$3 = new Array(_p$2.length);
        const _p$4 = _p$2.length;
        let _tmp$4 = 0;
        while (true) {
          const _p$5 = _tmp$4;
          if (_p$5 < _p$4) {
            const _p$6 = _p$2[_p$5];
            const _p$7 = _p$6.items;
            const _p$8 = new Array(_p$7.length);
            const _p$9 = _p$7.length;
            let _tmp$5 = 0;
            while (true) {
              const _p$10 = _tmp$5;
              if (_p$10 < _p$9) {
                const _p$11 = _p$7[_p$10];
                _p$8[_p$10] = { binder: _p$11.binder, term: moonbitlang$yacc$lib$desugar$$eliminate_rule_args$46$map_term$124$132(_env, _p$11.term, env.val) };
                _tmp$5 = _p$10 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            const _p$10 = _p$8;
            const _tmp$6 = _p$6.prec;
            const _tmp$7 = _p$6.action;
            const _tmp$8 = moonbitlang$yacc$lib$util$stamp$$new();
            const _p$11 = _p$6.action.bindings;
            const _p$12 = new Array(_p$11.length);
            const _p$13 = _p$11.length;
            let _tmp$9 = 0;
            while (true) {
              const _p$14 = _tmp$9;
              if (_p$14 < _p$13) {
                const _p$15 = _p$11[_p$14];
                const _p$16 = _p$15._0;
                const _p$17 = _p$15._1;
                let _p$18;
                if (_p$16.$tag === 0) {
                  const _p$19 = _p$16;
                  const _p$20 = _p$19._0;
                  const _p$21 = moonbitlang$core$array$$Array$at$32$(_p$10, _p$20);
                  _p$18 = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$Data(_p$20, moonbitlang$yacc$lib$elab$$Item$type_(_p$21));
                } else {
                  _p$18 = _p$16;
                }
                _p$12[_p$14] = { _0: _p$18, _1: _p$17 };
                _tmp$9 = _p$14 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            _p$3[_p$5] = { items: _p$10, prec: _tmp$6, action: { ..._tmp$7, stamp: _tmp$8, bindings: _p$12, type_: type_ } };
            _tmp$4 = _p$5 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const _bind$7 = _p$3;
        moonbitlang$core$builtin$$Map$set$216$(new_rules, _tmp$2, { name: _specialized_rule_name, inline: parametric_rule.inline, generic_params: _bind$5, params: _bind$6, type_: type_, clauses: _bind$7 });
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    continue;
  }
  return { ...spec, rules: new_rules };
}
function moonbitlang$yacc$lib$desugar$$find_leaf_inline_rules(rules) {
  const _bind = [];
  const all_inline_rules = moonbitlang$core$builtin$$Map$from_array$216$({ buf: _bind, start: 0, end: 0 });
  const _it = moonbitlang$core$builtin$$Map$iter2$216$(rules);
  while (true) {
    const _bind$2 = moonbitlang$core$builtin$$Iter2$next$216$(_it);
    if (_bind$2 === undefined) {
      break;
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      const _rule_name = _x._0;
      const _rule = _x._1;
      if (_rule.inline) {
        moonbitlang$core$builtin$$Map$set$216$(all_inline_rules, _rule_name, _rule);
      }
      continue;
    }
  }
  return moonbitlang$core$set$$Set$from_iter$13$(moonbitlang$core$builtin$$Iter$map$180$(moonbitlang$core$builtin$$Iter$filter$161$(moonbitlang$core$builtin$$Map$iter$216$(all_inline_rules), (it) => {
    const _rule = it._1;
    const _p = moonbitlang$core$array$$Array$iter$138$(_rule.clauses);
    while (true) {
      const _p$2 = moonbitlang$core$builtin$$Iter$next$138$(_p);
      if (_p$2 === undefined) {
        return true;
      } else {
        const _p$3 = _p$2;
        const _p$4 = _p$3;
        const _p$5 = moonbitlang$core$array$$Array$iter$32$(_p$4.items);
        let _tmp;
        while (true) {
          const _p$6 = moonbitlang$core$builtin$$Iter$next$32$(_p$5);
          if (_p$6 === undefined) {
            _tmp = true;
            break;
          } else {
            const _p$7 = _p$6;
            const _p$8 = _p$7;
            let _tmp$2;
            _L: {
              _L$2: {
                const _p$9 = _p$8.term;
                switch (_p$9.$tag) {
                  case 0: {
                    _tmp$2 = true;
                    break;
                  }
                  case 2: {
                    const _p$10 = _p$9;
                    const _p$11 = _p$10._0;
                    const _p$12 = _p$10._1;
                    if (_p$12.length === 0) {
                      _tmp$2 = !moonbitlang$core$builtin$$Map$contains$216$(all_inline_rules, _p$11);
                    } else {
                      break _L$2;
                    }
                    break;
                  }
                  default: {
                    break _L$2;
                  }
                }
                break _L;
              }
              _tmp$2 = $panic();
            }
            if (_tmp$2) {
            } else {
              _tmp = false;
              break;
            }
            continue;
          }
        }
        if (_tmp) {
        } else {
          return false;
        }
        continue;
      }
    }
  }), (it) => it._0));
}
function moonbitlang$yacc$lib$desugar$$eliminate_inline_rules$46$yield_$124$14(new_clauses, clause) {
  moonbitlang$core$array$$Array$push$138$(new_clauses, clause);
}
function moonbitlang$yacc$lib$desugar$$eliminate_inline_rules$46$cont$124$15(_env, cont_items, cont_bindings, cont_subactions, index) {
  const new_clauses = _env._3;
  const spec = _env._2;
  const clause = _env._1;
  const inline_rules = _env._0;
  let _tmp = cont_items;
  let _tmp$2 = index;
  _L: while (true) {
    const cont_items$2 = _tmp;
    const index$2 = _tmp$2;
    if (index$2 >= clause.items.length) {
      moonbitlang$yacc$lib$desugar$$eliminate_inline_rules$46$yield_$124$14(new_clauses, { items: moonbitlang$core$immut$array$$T$to_array$32$(cont_items$2), prec: clause.prec, action: { ...clause.action, stamp: moonbitlang$yacc$lib$util$stamp$$new(), sub_actions: moonbitlang$core$immut$array$$T$to_array$28$(cont_subactions), bindings: moonbitlang$core$immut$array$$T$to_array$27$(cont_bindings) } });
      return;
    } else {
      const item = moonbitlang$core$array$$Array$at$32$(clause.items, index$2);
      _L$2: {
        _L$3: {
          const _bind = item.term;
          if (_bind.$tag === 2) {
            const _RuleCall = _bind;
            const _rule_name = _RuleCall._0;
            const _x = _RuleCall._1;
            if (_x.length === 0) {
              if (moonbitlang$core$set$$Set$contains$13$(inline_rules, _rule_name)) {
                const _p = moonbitlang$core$builtin$$Map$get$216$(spec.rules, _rule_name);
                let inline_rule;
                if (_p === undefined) {
                  inline_rule = $panic();
                } else {
                  const _p$2 = _p;
                  inline_rule = _p$2;
                }
                const _arr = inline_rule.clauses;
                const _len = _arr.length;
                let _tmp$3 = 0;
                while (true) {
                  const _i = _tmp$3;
                  if (_i < _len) {
                    const inline_clause = _arr[_i];
                    const _bind$2 = inline_clause.items;
                    const next_cont_items = moonbitlang$core$builtin$$Add$add$238$(cont_items$2, moonbitlang$core$immut$array$$T$from_array$32$({ buf: _bind$2, start: 0, end: _bind$2.length }));
                    const start_index = cont_items$2.size;
                    const end_index = start_index + inline_clause.items.length | 0;
                    const subaction_index = cont_subactions.size;
                    const next_cont_subactions = moonbitlang$core$immut$array$$T$push$28$(cont_subactions, { start: start_index, end: end_index, action: inline_clause.action });
                    const index_shift = inline_clause.items.length - 1 | 0;
                    const next_cont_bindings = moonbitlang$core$immut$array$$T$map$198$(cont_bindings, (binding) => {
                      const _subject = binding._0;
                      const _code = binding._1;
                      let new_subject;
                      _L$4: {
                        _L$5: {
                          switch (_subject.$tag) {
                            case 0: {
                              const _Data = _subject;
                              const _data_index = _Data._0;
                              const _type_ = _Data._1;
                              if (_data_index === start_index) {
                                new_subject = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$SubAction(subaction_index, _type_);
                              } else {
                                if (_data_index > start_index) {
                                  new_subject = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$Data(_data_index + index_shift | 0, _type_);
                                } else {
                                  break _L$5;
                                }
                              }
                              break;
                            }
                            case 1: {
                              const _StartPosOf = _subject;
                              const _data_index$2 = _StartPosOf._0;
                              if (_data_index$2 > start_index) {
                                new_subject = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$StartPosOf(_data_index$2 + index_shift | 0);
                              } else {
                                break _L$5;
                              }
                              break;
                            }
                            case 2: {
                              const _EndPosOf = _subject;
                              const _data_index$3 = _EndPosOf._0;
                              if (_data_index$3 > start_index) {
                                new_subject = new $64$moonbitlang$47$yacc$47$lib$47$elab$46$BindingSubject$EndPosOf(_data_index$3 + index_shift | 0);
                              } else {
                                break _L$5;
                              }
                              break;
                            }
                            default: {
                              break _L$5;
                            }
                          }
                          break _L$4;
                        }
                        new_subject = _subject;
                      }
                      return { _0: new_subject, _1: _code };
                    });
                    moonbitlang$yacc$lib$desugar$$eliminate_inline_rules$46$cont$124$15(_env, next_cont_items, next_cont_bindings, next_cont_subactions, index$2 + 1 | 0);
                    _tmp$3 = _i + 1 | 0;
                    continue;
                  } else {
                    return;
                  }
                }
              } else {
                break _L$2;
              }
            } else {
              break _L$3;
            }
          } else {
            break _L$3;
          }
        }
        break _L$2;
      }
      _tmp = moonbitlang$core$immut$array$$T$push$32$(cont_items$2, item);
      _tmp$2 = index$2 + 1 | 0;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$desugar$$eliminate_inline_rules(spec, inline_rules) {
  const _bind = [];
  const new_rules = moonbitlang$core$builtin$$Map$from_array$216$({ buf: _bind, start: 0, end: 0 });
  const _it = moonbitlang$core$builtin$$Map$iter2$216$(spec.rules);
  while (true) {
    const _bind$2 = moonbitlang$core$builtin$$Iter2$next$216$(_it);
    if (_bind$2 === undefined) {
      break;
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      const _rule_name = _x._0;
      const _rule = _x._1;
      if (!moonbitlang$core$set$$Set$contains$13$(inline_rules, _rule_name)) {
        const new_clauses = [];
        const _arr = _rule.clauses;
        const _len = _arr.length;
        let _tmp = 0;
        while (true) {
          const _i = _tmp;
          if (_i < _len) {
            const clause = _arr[_i];
            const items = clause.items;
            const _p = moonbitlang$core$array$$Array$iter$32$(items);
            let _tmp$2;
            while (true) {
              const _p$2 = moonbitlang$core$builtin$$Iter$next$32$(_p);
              if (_p$2 === undefined) {
                _tmp$2 = false;
                break;
              } else {
                const _p$3 = _p$2;
                const _p$4 = _p$3;
                let _tmp$3;
                _L: {
                  _L$2: {
                    const _p$5 = _p$4.term;
                    switch (_p$5.$tag) {
                      case 0: {
                        _tmp$3 = false;
                        break;
                      }
                      case 2: {
                        const _p$6 = _p$5;
                        const _p$7 = _p$6._0;
                        const _p$8 = _p$6._1;
                        if (_p$8.length === 0) {
                          _tmp$3 = moonbitlang$core$set$$Set$contains$13$(inline_rules, _p$7);
                        } else {
                          break _L$2;
                        }
                        break;
                      }
                      default: {
                        break _L$2;
                      }
                    }
                    break _L;
                  }
                  _tmp$3 = $panic();
                }
                if (_tmp$3) {
                  _tmp$2 = true;
                  break;
                }
                continue;
              }
            }
            if (_tmp$2) {
              const _env = { _0: inline_rules, _1: clause, _2: spec, _3: new_clauses };
              const _tmp$3 = moonbitlang$core$immut$array$$T$new$32$();
              const _bind$3 = clause.action.bindings;
              const _tmp$4 = moonbitlang$core$immut$array$$T$from_array$27$({ buf: _bind$3, start: 0, end: _bind$3.length });
              const _bind$4 = clause.action.sub_actions;
              moonbitlang$yacc$lib$desugar$$eliminate_inline_rules$46$cont$124$15(_env, _tmp$3, _tmp$4, moonbitlang$core$immut$array$$T$from_array$28$({ buf: _bind$4, start: 0, end: _bind$4.length }), 0);
            } else {
              moonbitlang$core$array$$Array$push$138$(new_clauses, clause);
            }
            _tmp = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        const new_rule = { name: _rule.name, inline: _rule.inline, generic_params: _rule.generic_params, params: _rule.params, type_: _rule.type_, clauses: new_clauses };
        moonbitlang$core$builtin$$Map$set$216$(new_rules, _rule_name, new_rule);
      } else {
        continue;
      }
      continue;
    }
  }
  return { ...spec, rules: new_rules };
}
function moonbitlang$yacc$lib$desugar$$eliminate_inline(spec) {
  let spec$2 = spec;
  while (true) {
    const inline_rules = moonbitlang$yacc$lib$desugar$$find_leaf_inline_rules(spec$2.rules);
    if (inline_rules.size === 0) {
      break;
    } else {
      spec$2 = moonbitlang$yacc$lib$desugar$$eliminate_inline_rules(spec$2, inline_rules);
    }
    continue;
  }
  return spec$2;
}
function moonbitlang$yacc$lib$driver$util$$exit$262$(code) {
  moonbitlang$yacc$lib$driver$util$$ffi_exit(code);
  return $panic();
}
function moonbitlang$yacc$lib$driver$util$$exit$15$(code) {
  moonbitlang$yacc$lib$driver$util$$ffi_exit(code);
  $panic();
}
function moonbitlang$yacc$lib$driver$util$$exit$263$(code) {
  moonbitlang$yacc$lib$driver$util$$ffi_exit(code);
  return $panic();
}
function moonbitlang$yacc$lib$driver$util$$exit$248$(code) {
  moonbitlang$yacc$lib$driver$util$$ffi_exit(code);
  return $panic();
}
function moonbitlang$yacc$lib$driver$util$$exit$264$(code) {
  moonbitlang$yacc$lib$driver$util$$ffi_exit(code);
  return $panic();
}
function moonbitlang$yacc$lib$driver$util$$path_basename(path) {
  const _bind = moonbitlang$core$string$$String$rev_find(path, { str: moonbitlang$yacc$lib$driver$util$$path_basename$46$42$bind$124$17, start: 0, end: moonbitlang$yacc$lib$driver$util$$path_basename$46$42$bind$124$17.length });
  if (_bind === undefined) {
    const _bind$2 = moonbitlang$core$string$$String$rev_find(path, { str: moonbitlang$yacc$lib$driver$util$$path_basename$46$42$bind$124$11, start: 0, end: moonbitlang$yacc$lib$driver$util$$path_basename$46$42$bind$124$11.length });
    if (_bind$2 === undefined) {
      return path;
    } else {
      const _Some = _bind$2;
      const _lastBackslashIndex = _Some;
      let _try_err;
      _L: {
        const _bind$3 = moonbitlang$core$string$$String$sub$46$inner(path, _lastBackslashIndex + 1 | 0, undefined);
        let _tmp;
        if (_bind$3.$tag === 1) {
          const _ok = _bind$3;
          _tmp = _ok._0;
        } else {
          const _err = _bind$3;
          const _tmp$2 = _err._0;
          _try_err = _tmp$2;
          break _L;
        }
        return moonbitlang$core$builtin$$Show$to_string$14$(_tmp);
      }
      return $panic();
    }
  } else {
    const _Some = _bind;
    const _lastSlashIndex = _Some;
    let _try_err;
    _L: {
      const _bind$2 = moonbitlang$core$string$$String$sub$46$inner(path, _lastSlashIndex + 1 | 0, undefined);
      let _tmp;
      if (_bind$2.$tag === 1) {
        const _ok = _bind$2;
        _tmp = _ok._0;
      } else {
        const _err = _bind$2;
        const _tmp$2 = _err._0;
        _try_err = _tmp$2;
        break _L;
      }
      return moonbitlang$core$builtin$$Show$to_string$14$(_tmp);
    }
    return $panic();
  }
}
function moonbitlang$yacc$lib$driver$$offset_to_line_column(content, offset) {
  let line = 1;
  let column = 1;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < offset) {
      $bound_check(content, i);
      const _p = content.charCodeAt(i);
      const _p$2 = 10;
      if (_p === _p$2) {
        line = line + 1 | 0;
        column = 1;
      } else {
        column = column + 1 | 0;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: line, _1: column };
}
function moonbitlang$yacc$lib$driver$$array_to_or_list(arr) {
  if ((arr.end - arr.start | 0) === 0) {
    return $panic();
  } else {
    if ((arr.end - arr.start | 0) === 1) {
      return arr.buf[arr.start];
    } else {
      const _x = arr.buf[arr.start + ((arr.end - arr.start | 0) - 1 | 0) | 0];
      const _x$2 = { buf: arr.buf, start: arr.start, end: ((arr.end - arr.start | 0) - 1 | 0) + arr.start | 0 };
      const _self = [];
      moonbitlang$core$array$$Array$push_iter$13$(_self, moonbitlang$core$array$$ArrayView$iter$13$(_x$2));
      const left = moonbitlang$core$array$$Array$join$13$(_self, { str: moonbitlang$yacc$lib$driver$$array_to_or_list$46$42$bind$124$150, start: 0, end: moonbitlang$yacc$lib$driver$$array_to_or_list$46$42$bind$124$150.length });
      return `${left} or ${_x}`;
    }
  }
}
function moonbitlang$yacc$lib$driver$$loc_to_string(filename, content, loc) {
  const _bind = moonbitlang$yacc$lib$driver$$offset_to_line_column(content, loc._0);
  const _start_line = _bind._0;
  const _start_column = _bind._1;
  const _bind$2 = moonbitlang$yacc$lib$driver$$offset_to_line_column(content, loc._1);
  const _end_line = _bind$2._0;
  const _end_column = _bind$2._1;
  return _start_line === _end_line ? `${filename}:${moonbitlang$core$builtin$$Show$to_string$111$(_start_line)}:${moonbitlang$core$builtin$$Show$to_string$111$(_start_column)}-${moonbitlang$core$builtin$$Show$to_string$111$(_end_column)}` : `${filename}:${moonbitlang$core$builtin$$Show$to_string$111$(_start_line)}:${moonbitlang$core$builtin$$Show$to_string$111$(_start_column)}-${moonbitlang$core$builtin$$Show$to_string$111$(_end_line)}:${moonbitlang$core$builtin$$Show$to_string$111$(_end_column)}`;
}
function moonbitlang$yacc$lib$driver$$pos_to_string(filename, content, pos) {
  const _bind = moonbitlang$yacc$lib$driver$$offset_to_line_column(content, pos);
  const _line = _bind._0;
  const _column = _bind._1;
  return `${filename}:${moonbitlang$core$builtin$$Show$to_string$111$(_line)}:${moonbitlang$core$builtin$$Show$to_string$111$(_column)}0`;
}
function moonbitlang$yacc$lib$driver$$print(parser_spec_str, filename, out) {
  const lexer = moonbitlang$yacc$lib$parser$$new_lexer(parser_spec_str);
  const token = () => {
    let _try_err;
    _L: {
      const _bind = moonbitlang$yacc$lib$parser$$Lexer$next_token(lexer);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        return _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err = _tmp;
        break _L;
      }
    }
    if (_try_err.$tag === 42) {
      const _Unrecognized = _try_err;
      const _x = _Unrecognized._0;
      const _pos = _Unrecognized._1;
      const pos_str = moonbitlang$yacc$lib$driver$$pos_to_string(filename, parser_spec_str, _pos);
      const _self = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
      moonbitlang$core$builtin$$Logger$write_char$3$(_self, _x);
      const _p = _self;
      moonbitlang$yacc$lib$driver$util$$println_to_stderr(`SyntaxError: Unrecognized character ${moonbitlang$core$string$$String$escape(_p.val)}, at ${pos_str}`);
      return moonbitlang$yacc$lib$driver$util$$exit$263$(1);
    } else {
      moonbitlang$yacc$lib$driver$util$$println_to_stderr("SyntaxError: Unexpected end of file");
      return moonbitlang$yacc$lib$driver$util$$exit$263$(1);
    }
  };
  let spec;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$yacc$lib$parser$$spec(token, 0);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        spec = _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err = _tmp;
        break _L$2;
      }
      break _L;
    }
    const _UnexpectedToken = _try_err;
    const _token = _UnexpectedToken._0;
    const _loc = _UnexpectedToken._1;
    const _expected = _UnexpectedToken._2;
    const loc_str = moonbitlang$yacc$lib$driver$$loc_to_string(filename, parser_spec_str, _loc);
    const _p = new Array(_expected.length);
    const _p$2 = _expected.length;
    let _tmp = 0;
    while (true) {
      const _p$3 = _tmp;
      if (_p$3 < _p$2) {
        const _p$4 = _expected[_p$3];
        _p[_p$3] = moonbitlang$core$builtin$$Show$to_string$118$(_p$4);
        _tmp = _p$3 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _bind = _p;
    const expected_str = moonbitlang$yacc$lib$driver$$array_to_or_list({ buf: _bind, start: 0, end: _bind.length });
    moonbitlang$yacc$lib$driver$util$$println_to_stderr(`SyntaxError: Unexpected token ${moonbitlang$core$builtin$$Show$to_string$118$(moonbitlang$yacc$lib$parser$$Token$kind(_token))}, expected ${expected_str}.\n  at ${loc_str}`);
    spec = moonbitlang$yacc$lib$driver$util$$exit$248$(1);
  }
  moonbitlang$yacc$lib$ast$$print_spec$46$inner(spec, out, false);
  moonbitlang$core$builtin$$println$13$(out.val);
}
function moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_terminal_by_name$124$49(terminal_by_name, name) {
  const _p = moonbitlang$core$builtin$$Map$get$211$(terminal_by_name, name);
  if (_p === undefined) {
    return $panic();
  } else {
    const _p$2 = _p;
    return _p$2;
  }
}
function moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_nonterminal_by_name$124$50(nonterminal_by_name, name) {
  const _p = moonbitlang$core$builtin$$Map$get$212$(nonterminal_by_name, name);
  if (_p === undefined) {
    return $panic();
  } else {
    const _p$2 = _p;
    return _p$2;
  }
}
function moonbitlang$yacc$lib$driver$$compile$46$inner(parser_spec_str, mode, input_mode, filename, external_tokens, no_comments, no_std, token_payload_rewrite, force_int_position, source_map_builder, generator) {
  const lexer = moonbitlang$yacc$lib$parser$$new_lexer(parser_spec_str);
  const token = () => {
    let _try_err;
    _L: {
      const _bind = moonbitlang$yacc$lib$parser$$Lexer$next_token(lexer);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        return _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err = _tmp;
        break _L;
      }
    }
    if (_try_err.$tag === 42) {
      const _Unrecognized = _try_err;
      const _x = _Unrecognized._0;
      const _pos = _Unrecognized._1;
      const pos_str = moonbitlang$yacc$lib$driver$$pos_to_string(filename, parser_spec_str, _pos);
      const _self = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
      moonbitlang$core$builtin$$Logger$write_char$3$(_self, _x);
      const _p = _self;
      moonbitlang$yacc$lib$driver$util$$println_to_stderr(`SyntaxError: Unrecognized character ${moonbitlang$core$string$$String$escape(_p.val)}, at ${pos_str}`);
      return moonbitlang$yacc$lib$driver$util$$exit$263$(1);
    } else {
      moonbitlang$yacc$lib$driver$util$$println_to_stderr("SyntaxError: Unexpected end of file");
      return moonbitlang$yacc$lib$driver$util$$exit$263$(1);
    }
  };
  let spec;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$yacc$lib$parser$$spec(token, 0);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        spec = _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err = _tmp;
        break _L$2;
      }
      break _L;
    }
    const _UnexpectedToken = _try_err;
    const _token = _UnexpectedToken._0;
    const _loc = _UnexpectedToken._1;
    const _expected = _UnexpectedToken._2;
    const loc_str = moonbitlang$yacc$lib$driver$$loc_to_string(filename, parser_spec_str, _loc);
    const _p = new Array(_expected.length);
    const _p$2 = _expected.length;
    let _tmp = 0;
    while (true) {
      const _p$3 = _tmp;
      if (_p$3 < _p$2) {
        const _p$4 = _expected[_p$3];
        _p[_p$3] = moonbitlang$core$builtin$$Show$to_string$118$(_p$4);
        _tmp = _p$3 + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _bind = _p;
    const expected_str = moonbitlang$yacc$lib$driver$$array_to_or_list({ buf: _bind, start: 0, end: _bind.length });
    moonbitlang$yacc$lib$driver$util$$println_to_stderr(`SyntaxError: Unexpected token ${moonbitlang$core$builtin$$Show$to_string$118$(moonbitlang$yacc$lib$parser$$Token$kind(_token))}, expected ${expected_str}.\n  at ${loc_str}`);
    spec = moonbitlang$yacc$lib$driver$util$$exit$248$(1);
  }
  let spec$2;
  let _try_err$2;
  _L$2: {
    _L$3: {
      const _tmp = moonbitlang$yacc$lib$driver$util$$path_basename(filename);
      let _tmp$2;
      _L$4: {
        _L$5: {
          switch (mode) {
            case 1: {
              _tmp$2 = 1;
              break;
            }
            case 0: {
              break _L$5;
            }
            default: {
              break _L$5;
            }
          }
          break _L$4;
        }
        _tmp$2 = 0;
      }
      const _tmp$3 = _tmp$2;
      let _tmp$4;
      switch (token_payload_rewrite) {
        case 2: {
          _tmp$4 = 2;
          break;
        }
        case 1: {
          _tmp$4 = 1;
          break;
        }
        default: {
          _tmp$4 = 0;
        }
      }
      const _bind = moonbitlang$yacc$lib$elab$$elaborate_with_stdlib_rules(spec, parser_spec_str, _tmp, _tmp$3, no_std, _tmp$4, force_int_position);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        spec$2 = _ok._0;
      } else {
        const _err = _bind;
        const _tmp$5 = _err._0;
        _try_err$2 = _tmp$5;
        break _L$3;
      }
      break _L$2;
    }
    switch (_try_err$2.$tag) {
      case 51: {
        const _UnresolvedSymbol = _try_err$2;
        const _symbol = _UnresolvedSymbol._0;
        const _loc = _UnresolvedSymbol._1;
        const loc_str = moonbitlang$yacc$lib$driver$$loc_to_string(filename, parser_spec_str, _loc);
        moonbitlang$yacc$lib$driver$util$$println_to_stderr(`Unresolved symbol ${_symbol}, at ${loc_str}`);
        spec$2 = moonbitlang$yacc$lib$driver$util$$exit$264$(1);
        break;
      }
      case 50: {
        const _FailedToParseTypeExpr = _try_err$2;
        const _type_expr = _FailedToParseTypeExpr._0;
        const type_expr_str = _type_expr;
        moonbitlang$yacc$lib$driver$util$$println_to_stderr(`Failed to parse type expression ${type_expr_str}`);
        spec$2 = moonbitlang$yacc$lib$driver$util$$exit$264$(1);
        break;
      }
      default: {
        const _OutOfBoundsAccess = _try_err$2;
        const _index = _OutOfBoundsAccess._0;
        const _loc$2 = _OutOfBoundsAccess._1;
        const loc_str$2 = moonbitlang$yacc$lib$driver$$loc_to_string(filename, parser_spec_str, _loc$2);
        moonbitlang$yacc$lib$driver$util$$println_to_stderr(`Out of bounds access ${moonbitlang$core$builtin$$Show$to_string$111$(_index)}, at ${loc_str$2}`);
        spec$2 = moonbitlang$yacc$lib$driver$util$$exit$264$(1);
      }
    }
  }
  let _tmp;
  _L$3: {
    _L$4: {
      switch (mode) {
        case 1: {
          _tmp = 1;
          break;
        }
        case 0: {
          break _L$4;
        }
        default: {
          break _L$4;
        }
      }
      break _L$3;
    }
    _tmp = 0;
  }
  const spec$3 = moonbitlang$yacc$lib$desugar$$eliminate_rule_args(spec$2, _tmp);
  const spec$4 = moonbitlang$yacc$lib$desugar$$eliminate_inline(spec$3);
  const terminals = [];
  const nonterminals = [];
  const _bind = [];
  const terminal_by_name = moonbitlang$core$builtin$$Map$from_array$211$({ buf: _bind, start: 0, end: 0 });
  const _bind$2 = [];
  const nonterminal_by_name = moonbitlang$core$builtin$$Map$from_array$212$({ buf: _bind$2, start: 0, end: 0 });
  const _arr = spec$4.tokens;
  const _len = _arr.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len) {
      const token$2 = _arr[_i];
      const _bind$3 = token$2.name;
      const _bind$4 = terminals.length;
      const _bind$5 = token$2.prec;
      let _bind$6;
      if (_bind$5 === undefined) {
        _bind$6 = undefined;
      } else {
        const _Some = _bind$5;
        const _x = _Some;
        const _prec = _x._0;
        const _x$2 = _x._1;
        switch (_x$2) {
          case 2: {
            _bind$6 = { _0: _prec, _1: 2 };
            break;
          }
          case 0: {
            _bind$6 = { _0: _prec, _1: 0 };
            break;
          }
          default: {
            _bind$6 = { _0: _prec, _1: 1 };
          }
        }
      }
      const terminal = { num: _bind$4, name: _bind$3, prec: _bind$6 };
      moonbitlang$core$builtin$$Map$set$211$(terminal_by_name, token$2.name, terminal);
      moonbitlang$core$array$$Array$push$55$(terminals, terminal);
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _it = moonbitlang$core$builtin$$Map$iter2$216$(spec$4.rules);
  while (true) {
    const _bind$3 = moonbitlang$core$builtin$$Iter2$next$216$(_it);
    if (_bind$3 === undefined) {
      break;
    } else {
      const _Some = _bind$3;
      const _x = _Some;
      const _rule_name = _x._0;
      const _rule = _x._1;
      const _bind$4 = nonterminals.length;
      const _bind$5 = [];
      const nonterminal = { num: _bind$4, name: _rule_name, productions: _bind$5 };
      moonbitlang$core$builtin$$Map$set$212$(nonterminal_by_name, _rule.name, nonterminal);
      moonbitlang$core$array$$Array$push$53$(nonterminals, nonterminal);
      continue;
    }
  }
  const _bind$3 = [];
  const production_meta_map = moonbitlang$core$builtin$$Map$from_array$213$({ buf: _bind$3, start: 0, end: 0 });
  const _bind$4 = [];
  const terminal_meta_map = moonbitlang$core$builtin$$Map$from_array$214$({ buf: _bind$4, start: 0, end: 0 });
  const _bind$5 = [];
  const nonterminal_meta_map = moonbitlang$core$builtin$$Map$from_array$215$({ buf: _bind$5, start: 0, end: 0 });
  const productions = [];
  const starts = spec$4.start_rules;
  const position_data_type = spec$4.position_type;
  const derive_map = spec$4.derive_map;
  const _arr$2 = spec$4.tokens;
  const _len$2 = _arr$2.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$2) {
      const token$2 = _arr$2[_i];
      const terminal = moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_terminal_by_name$124$49(terminal_by_name, token$2.name);
      moonbitlang$core$builtin$$Map$set$214$(terminal_meta_map, terminal.num, { data_type: token$2.type_, image: token$2.image });
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (mode === 2) {
    const output = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
    generator.method_table.method_2(generator.self, terminals, (name) => moonbitlang$core$builtin$$Map$get_or_init$214$(terminal_meta_map, moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_terminal_by_name$124$49(terminal_by_name, name).num, () => ({ data_type: new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Unit", []), image: undefined })), { self: output, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger }, no_comments, spec$4.derive_map);
    return output.val;
  }
  const _it$2 = moonbitlang$core$builtin$$Map$iter2$216$(spec$4.rules);
  while (true) {
    const _bind$6 = moonbitlang$core$builtin$$Iter2$next$216$(_it$2);
    if (_bind$6 === undefined) {
      break;
    } else {
      const _Some = _bind$6;
      const _x = _Some;
      const _rule_name = _x._0;
      const _rule = _x._1;
      const lhs = moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_nonterminal_by_name$124$50(nonterminal_by_name, _rule_name);
      moonbitlang$core$builtin$$Map$set$215$(nonterminal_meta_map, lhs.num, { data_type: _rule.type_ });
      const _arr$3 = _rule.clauses;
      const _len$3 = _arr$3.length;
      let _tmp$4 = 0;
      while (true) {
        const _i = _tmp$4;
        if (_i < _len$3) {
          const clause = _arr$3[_i];
          const production_num = productions.length;
          const _p = clause.items;
          const _p$2 = new Array(_p.length);
          const _p$3 = _p.length;
          let _tmp$5 = 0;
          while (true) {
            const _p$4 = _tmp$5;
            if (_p$4 < _p$3) {
              const _p$5 = _p[_p$4];
              let _tmp$6;
              _L$4: {
                _L$5: {
                  const _p$6 = _p$5.term;
                  switch (_p$6.$tag) {
                    case 0: {
                      const _p$7 = _p$6;
                      const _p$8 = _p$7._0;
                      _tmp$6 = new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$T(moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_terminal_by_name$124$49(terminal_by_name, _p$8.name));
                      break;
                    }
                    case 2: {
                      const _p$9 = _p$6;
                      const _p$10 = _p$9._0;
                      const _p$11 = _p$9._1;
                      if (_p$11.length === 0) {
                        _tmp$6 = new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$NT(moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_nonterminal_by_name$124$50(nonterminal_by_name, _p$10));
                      } else {
                        break _L$5;
                      }
                      break;
                    }
                    default: {
                      break _L$5;
                    }
                  }
                  break _L$4;
                }
                _tmp$6 = $panic();
              }
              _p$2[_p$4] = _tmp$6;
              _tmp$5 = _p$4 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          const production = { num: production_num, lhs: lhs, rhs: _p$2, prec: clause.prec };
          moonbitlang$core$array$$Array$push$34$(productions, production);
          moonbitlang$core$array$$Array$push$34$(lhs.productions, production);
          moonbitlang$core$builtin$$Map$set$213$(production_meta_map, production_num, { action: clause.action });
          _tmp$4 = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      continue;
    }
  }
  const _p = new Array(starts.length);
  const _p$2 = starts.length;
  let _tmp$4 = 0;
  while (true) {
    const _p$3 = _tmp$4;
    if (_p$3 < _p$2) {
      const _p$4 = starts[_p$3];
      const _p$5 = moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_nonterminal_by_name$124$50(nonterminal_by_name, _p$4);
      const _p$6 = { num: nonterminals.length, name: `${_p$4}_prime`, productions: [] };
      moonbitlang$core$builtin$$Map$set$212$(nonterminal_by_name, _p$6.name, _p$6);
      moonbitlang$core$array$$Array$push$53$(nonterminals, _p$6);
      const _tmp$5 = _p$6.num;
      const _p$7 = moonbitlang$core$builtin$$Map$get$215$(nonterminal_meta_map, _p$5.num);
      let _tmp$6;
      if (_p$7 === undefined) {
        _tmp$6 = $panic();
      } else {
        const _p$8 = _p$7;
        _tmp$6 = _p$8;
      }
      moonbitlang$core$builtin$$Map$set$215$(nonterminal_meta_map, _tmp$5, _tmp$6);
      const _p$8 = { num: productions.length, lhs: _p$6, rhs: [new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$NT(_p$5)], prec: undefined };
      moonbitlang$core$array$$Array$push$34$(productions, _p$8);
      moonbitlang$core$array$$Array$push$34$(_p$6.productions, _p$8);
      _p[_p$3] = _p$8;
      _tmp$4 = _p$3 + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const starts$2 = _p;
  const _len$3 = productions.length;
  let _tmp$5 = 0;
  while (true) {
    const _i = _tmp$5;
    if (_i < _len$3) {
      const prod = productions[_i];
      const _bind$6 = prod.prec;
      if (_bind$6 === undefined) {
        const rightmost_term = moonbitlang$core$builtin$$Iter$find_first$54$(moonbitlang$core$array$$Array$rev_iter$54$(prod.rhs), (x) => {
          if (x.$tag === 0) {
            return true;
          } else {
            return false;
          }
        });
        if (rightmost_term === undefined) {
        } else {
          const _Some = rightmost_term;
          const _x = _Some;
          if (_x.$tag === 0) {
            const _T = _x;
            const _terminal = _T._0;
            const term = moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_terminal_by_name$124$49(terminal_by_name, _terminal.name);
            const _bind$7 = term.prec;
            let _tmp$6;
            if (_bind$7 === undefined) {
              _tmp$6 = undefined;
            } else {
              const _Some$2 = _bind$7;
              const _x$2 = _Some$2;
              const _prec = _x$2._0;
              _tmp$6 = _prec;
            }
            prod.prec = _tmp$6;
          } else {
            $panic();
          }
        }
      }
      _tmp$5 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const grammar = { starts: starts$2, terminals: terminals, nonterminals: nonterminals, productions: productions };
  let _tmp$6;
  if (input_mode === 1) {
    _tmp$6 = true;
  } else {
    _tmp$6 = false;
  }
  const automaton = moonbitlang$yacc$lib$lr1$$Automaton$build(grammar, _tmp$6);
  const errors = moonbitlang$yacc$lib$lr1$$resolve_conflicts(automaton.conflicts);
  const _len$4 = errors.length;
  let _tmp$7 = 0;
  while (true) {
    const _i = _tmp$7;
    if (_i < _len$4) {
      const error = errors[_i];
      switch (error.$tag) {
        case 0: {
          moonbitlang$yacc$lib$driver$util$$println_to_stderr("Reduce conflict resolved by presentation order");
          break;
        }
        case 1: {
          moonbitlang$yacc$lib$driver$util$$println_to_stderr("Shift-reduce conflict resolved without precedence");
          break;
        }
        default: {
          moonbitlang$yacc$lib$driver$util$$println_to_stderr("Shift-reduce conflict not resolved because of non-associativity");
        }
      }
      _tmp$7 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const meta = { header: spec$4.header, footer: spec$4.trailer, position_data_type: position_data_type, terminal_meta: (name) => moonbitlang$core$builtin$$Map$get_or_init$214$(terminal_meta_map, moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_terminal_by_name$124$49(terminal_by_name, name).num, () => ({ data_type: new $64$moonbitlang$47$yacc$47$lib$47$elab$46$TypeExpr$Constr(undefined, "Unit", []), image: undefined })), nonterminal_meta: (name) => {
    const _p$3 = moonbitlang$core$builtin$$Map$get$215$(nonterminal_meta_map, moonbitlang$yacc$lib$driver$$compile$46$inner$46$get_nonterminal_by_name$124$50(nonterminal_by_name, name).num);
    if (_p$3 === undefined) {
      return $panic();
    } else {
      const _p$4 = _p$3;
      return _p$4;
    }
  }, production_meta: (num) => {
    const _p$3 = moonbitlang$core$builtin$$Map$get$213$(production_meta_map, num);
    if (_p$3 === undefined) {
      return $panic();
    } else {
      const _p$4 = _p$3;
      return _p$4;
    }
  }, derive_map: derive_map };
  const output_buffer = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
  const output = moonbitlang$yacc$lib$util$logger_with_cursor$$new$46$inner({ self: output_buffer, method_table: $$$64$moonbitlang$47$core$47$builtin$46$StringBuilder$36$as$36$64$moonbitlang$47$core$47$builtin$46$Logger }, 0);
  const _tmp$8 = moonbitlang$yacc$lib$driver$util$$path_basename(filename);
  let _tmp$9;
  switch (mode) {
    case 2: {
      _tmp$9 = $panic();
      break;
    }
    case 0: {
      _tmp$9 = 0;
      break;
    }
    default: {
      _tmp$9 = 1;
    }
  }
  const _tmp$10 = _tmp$9;
  let _tmp$11;
  if (input_mode === 0) {
    _tmp$11 = 0;
  } else {
    _tmp$11 = 1;
  }
  generator.method_table.method_3(generator.self, grammar, automaton, meta, output, source_map_builder, _tmp$8, external_tokens, no_comments, _tmp$10, _tmp$11);
  return output_buffer.val;
}
function moonbitlang$yacc$main$$_init$42$46$write_map_file$124$26(source_map, file) {
  return moonbitlang$x$fs$$write_string_to_file$46$inner(file, moonbitlang$core$json$$Json$stringify$46$inner(moonbitlang$core$builtin$$ToJson$to_json$0$(source_map), false, 2, undefined), "utf8");
}
(() => {
  const output_file = { val: "" };
  const output_map_file = { val: undefined };
  const input_file = { val: "" };
  const mode = { val: 0 };
  const input_mode = { val: 0 };
  const external_tokens = { val: false };
  const no_comments = { val: false };
  const no_std = { val: false };
  const table = { val: false };
  const compress = { val: false };
  const token_payload_rewrite = { val: 2 };
  const force_int_position = { val: false };
  const print_as_mly_without_actions = { val: false };
  let _try_err;
  _L: {
    _L$2: {
      const _bind = Yoorkin$ArgParser$$parse([{ _0: "--output-file", _1: "-o", _2: new $64$Yoorkin$47$ArgParser$46$Spec$String((file) => {
        output_file.val = file;
        return new Result$Ok$33$(undefined);
      }), _3: "Output file" }, { _0: "--output-map-file", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$String((file) => {
        output_map_file.val = file;
        return new Result$Ok$33$(undefined);
      }), _3: "Output source map file, if not specified, it will be the output file with .map.json extension" }, { _0: "--mode", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$String((mode_sym) => {
        let _tmp;
        switch (mode_sym) {
          case "default": {
            _tmp = 0;
            break;
          }
          case "json-cst": {
            _tmp = 1;
            break;
          }
          case "only-tokens": {
            _tmp = 2;
            break;
          }
          default: {
            moonbitlang$yacc$lib$driver$util$$println_to_stderr(`Unsupported mode: ${mode_sym}`);
            _tmp = moonbitlang$yacc$lib$driver$util$$exit$262$(1);
          }
        }
        mode.val = _tmp;
        return new Result$Ok$33$(undefined);
      }), _3: "Specify mode (default, json-cst)" }, { _0: "--input-mode", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$String((input_mode_sym) => {
        switch (input_mode_sym) {
          case "array": {
            input_mode.val = 0;
            break;
          }
          case "pull": {
            input_mode.val = 1;
            break;
          }
          default: {
            moonbitlang$yacc$lib$driver$util$$println_to_stderr(`Unsupported input mode: ${input_mode_sym}`);
            moonbitlang$yacc$lib$driver$util$$exit$15$(1);
          }
        }
        return new Result$Ok$33$(undefined);
      }), _3: "Specify input mode (array, pull). Default is array" }, { _0: "--external-tokens", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        external_tokens.val = true;
        return new Result$Ok$33$(undefined);
      }), _3: "Use external tokens" }, { _0: "--no-comments", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        no_comments.val = true;
        return new Result$Ok$33$(undefined);
      }), _3: "Do not include comments in the output" }, { _0: "--no-std", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        no_std.val = true;
        return new Result$Ok$33$(undefined);
      }), _3: "Do not include standard library" }, { _0: "--table", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        table.val = true;
        return new Result$Ok$33$(undefined);
      }), _3: "Use table engine" }, { _0: "--compress-table", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        compress.val = true;
        table.val = true;
        return new Result$Ok$33$(undefined);
      }), _3: "Use table engine with compression" }, { _0: "--version", _1: "-v", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        moonbitlang$core$builtin$$println$13$("moonyacc 0.1.0");
        return new Result$Ok$33$(moonbitlang$yacc$lib$driver$util$$exit$15$(0));
      }), _3: "Show version" }, { _0: "--print-as-mly-without-actions", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        print_as_mly_without_actions.val = true;
        return new Result$Ok$33$(undefined);
      }), _3: "Print as mly without actions" }, { _0: "--force-token-json-payload", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        token_payload_rewrite.val = 1;
        return new Result$Ok$33$(undefined);
      }), _3: "Force token to use JSON payload" }, { _0: "--force-token-no-payload", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        token_payload_rewrite.val = 0;
        return new Result$Ok$33$(undefined);
      }), _3: "Force token to not use payload" }, { _0: "--force-int-position", _1: "", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
        force_int_position.val = true;
        return new Result$Ok$33$(undefined);
      }), _3: "Overwrite the position type to int" }], (rest) => {
        input_file.val = rest;
        return new Result$Ok$33$(undefined);
      }, moonbitlang$yacc$main$$_init$42$46$usage$124$1, moonbitlang$x$sys$$get_cli_args());
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err = _tmp;
        break _L$2;
      }
      break _L;
    }
    moonbitlang$yacc$lib$driver$util$$println_to_stderr(moonbitlang$core$builtin$$Show$to_string$114$(_try_err));
  }
  const _p = input_file.val;
  const _p$2 = "";
  if (!(_p === _p$2)) {
    let parser_spec_src;
    let _try_err$2;
    _L$2: {
      _L$3: {
        const _bind = moonbitlang$x$fs$$read_file_to_string$46$inner(input_file.val, "utf8");
        if (_bind.$tag === 1) {
          const _ok = _bind;
          parser_spec_src = _ok._0;
        } else {
          const _err = _bind;
          const _tmp = _err._0;
          _try_err$2 = _tmp;
          break _L$3;
        }
        break _L$2;
      }
      parser_spec_src = moonbitlang$core$builtin$$abort$13$(moonbitlang$core$builtin$$Show$to_string$10$(_try_err$2), "@moonbitlang/yacc/main:main.mbt:153:12-153:39");
    }
    if (print_as_mly_without_actions.val) {
      const out = moonbitlang$core$builtin$$StringBuilder$new$46$inner(0);
      moonbitlang$yacc$lib$driver$$print(parser_spec_src, input_file.val, out);
      moonbitlang$yacc$lib$driver$util$$exit$15$(0);
    }
    const source_map = moonbitlang$yacc$lib$codegen$$SourceMap$new();
    const output = moonbitlang$yacc$lib$driver$$compile$46$inner(parser_spec_src, mode.val, input_mode.val, input_file.val, external_tokens.val, no_comments.val, no_std.val, token_payload_rewrite.val, force_int_position.val, new Option$Some$57$({ self: source_map, method_table: $$$64$moonbitlang$47$yacc$47$lib$47$codegen$46$SourceMap$36$as$36$64$moonbitlang$47$yacc$47$lib$47$codegen$46$SourceMapBuilder }), table.val ? (compress.val ? moonbitlang$yacc$lib$codegen$gen_mbt_table$$compress_generator : moonbitlang$yacc$lib$codegen$gen_mbt_table$$generator) : moonbitlang$yacc$lib$codegen$gen_mbt$$generator);
    if (output_file.val === "") {
      moonbitlang$core$builtin$$println$13$(output);
      const _bind = output_map_file.val;
      if (_bind === undefined) {
        return;
      } else {
        const _Some = _bind;
        const _file = _Some;
        let _try_err$3;
        _L$3: {
          const _bind$2 = moonbitlang$yacc$main$$_init$42$46$write_map_file$124$26(source_map, _file);
          if (_bind$2.$tag === 1) {
            const _ok = _bind$2;
            _ok._0;
            return;
          } else {
            const _err = _bind$2;
            const _tmp = _err._0;
            _try_err$3 = _tmp;
            break _L$3;
          }
        }
        $panic();
        return;
      }
    } else {
      let _try_err$3;
      _L$3: {
        const _bind = moonbitlang$x$fs$$write_string_to_file$46$inner(output_file.val, output, "utf8");
        if (_bind.$tag === 1) {
          const _ok = _bind;
          _ok._0;
        } else {
          const _err = _bind;
          const _tmp = _err._0;
          _try_err$3 = _tmp;
          break _L$3;
        }
        const _p$3 = output_map_file.val;
        const _p$4 = `${output_file.val}.map.json`;
        let _tmp;
        if (_p$3 === undefined) {
          _tmp = _p$4;
        } else {
          const _p$5 = _p$3;
          _tmp = _p$5;
        }
        const _bind$2 = moonbitlang$yacc$main$$_init$42$46$write_map_file$124$26(source_map, _tmp);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          _ok._0;
          return;
        } else {
          const _err = _bind$2;
          const _tmp$2 = _err._0;
          _try_err$3 = _tmp$2;
          break _L$3;
        }
      }
      $panic();
      return;
    }
  } else {
    moonbitlang$yacc$lib$driver$util$$println_to_stderr("Input file is required");
    moonbitlang$yacc$lib$driver$util$$exit$15$(1);
    return;
  }
})();
