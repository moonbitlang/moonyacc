const $1L = { hi: 0, lo: 1 };
const $0L = { hi: 0, lo: 0 };
function Result$Err$0$(param0) {
  this._0 = param0;
}
Result$Err$0$.prototype.$tag = 0;
function Result$Ok$0$(param0) {
  this._0 = param0;
}
Result$Ok$0$.prototype.$tag = 1;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$ParseError$46$UnexpectedToken(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$ParseError$46$UnexpectedToken.prototype.$tag = 22;
const Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void = { $tag: 21 };
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseItemSymbol$46$YYObj_ClauseItemSymbol(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseItemSymbol$46$YYObj_ClauseItemSymbol.prototype.$tag = 20;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseItem$46$YYObj_ClauseItem(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseItem$46$YYObj_ClauseItem.prototype.$tag = 19;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Array_SubstItem__$46$YYObj__String__Int__Array_SubstItem__(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Array_SubstItem__$46$YYObj__String__Int__Array_SubstItem__.prototype.$tag = 18;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseAction$46$YYObj_ClauseAction(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseAction$46$YYObj_ClauseAction.prototype.$tag = 17;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Symbol_$46$YYObj_Symbol_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Symbol_$46$YYObj_Symbol_.prototype.$tag = 16;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_ClauseItem_$46$YYObj__immut_list_T_ClauseItem_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_ClauseItem_$46$YYObj__immut_list_T_ClauseItem_.prototype.$tag = 15;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Clause$46$YYObj_Clause(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Clause$46$YYObj_Clause.prototype.$tag = 14;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Clause_$46$YYObj__immut_list_T_Clause_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Clause_$46$YYObj__immut_list_T_Clause_.prototype.$tag = 13;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Rule$46$YYObj_Rule(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Rule$46$YYObj_Rule.prototype.$tag = 12;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Symbol$46$YYObj_Symbol(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Symbol$46$YYObj_Symbol.prototype.$tag = 11;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Symbol_$46$YYObj__immut_list_T_Symbol_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Symbol_$46$YYObj__immut_list_T_Symbol_.prototype.$tag = 10;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command.prototype.$tag = 9;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String.prototype.$tag = 8;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ParserSpec$46$YYObj_ParserSpec(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ParserSpec$46$YYObj_ParserSpec.prototype.$tag = 7;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Rule_$46$YYObj__immut_list_T_Rule_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Rule_$46$YYObj__immut_list_T_Rule_.prototype.$tag = 6;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Command_$46$YYObj__immut_list_T_Command_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Command_$46$YYObj__immut_list_T_Command_.prototype.$tag = 5;
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_.prototype.$tag = 4;
const Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile = { $tag: 2 };
function Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$Unrecognized(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$Unrecognized.prototype.$tag = 3;
function Error$moonbitlang$47$x$47$fs$46$IOError$46$NotFound(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$x$47$fs$46$IOError$46$NotFound.prototype.$tag = 1;
function Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(param0) {
  this._0 = param0;
}
Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError.prototype.$tag = 0;
const $9223372036854775807L = { hi: 2147483647, lo: -1 };
const $10L = { hi: 0, lo: 10 };
const $16L = { hi: 0, lo: 16 };
const $_9223372036854775808L = { hi: -2147483648, lo: 0 };
function Result$Err$1$(param0) {
  this._0 = param0;
}
Result$Err$1$.prototype.$tag = 0;
function Result$Ok$1$(param0) {
  this._0 = param0;
}
Result$Ok$1$.prototype.$tag = 1;
function Result$Err$2$(param0) {
  this._0 = param0;
}
Result$Err$2$.prototype.$tag = 0;
function Result$Ok$2$(param0) {
  this._0 = param0;
}
Result$Ok$2$.prototype.$tag = 1;
function $compare_int(a, b) {
  return (a >= b) - (a <= b);
}
function $make_array_len_and_init(a, b) {
  const arr = new Array(a);
  for (let i = 0; i < a; i++) {
    arr[i] = b;
  }
  return arr;
}
const moonbitlang$core$array$$JSArray$copy = (arr) => arr.slice(0);
const $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$3$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$3$(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$3$.prototype.$tag = 1;
function $i32_popcnt(a) {
  a = a - ((a >>> 1) & 0x55555555);
  a = (a & 0x33333333) + ((a >>> 2) & 0x33333333);
  a = (a + (a >>> 4)) & 0x0f0f0f0f;
  a = a + (a >>> 8);
  a = a + (a >>> 16);
  return a & 0x3f;
}
const $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Empty$4$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$4$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$4$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$4$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$4$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$4$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$4$.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$4$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$4$.prototype.$tag = 0;
function $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$4$(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$4$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$5$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$5$(param0, param1, param2, param3, param4) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
  this._4 = param4;
}
$64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$5$.prototype.$tag = 1;
class $PanicError extends Error {}
function $panic() {
  throw new $PanicError();
}
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$6$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$6$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$6$.prototype.$tag = 1;
const moonbitlang$core$builtin$$JSArray$push = (arr, val) => { arr.push(val); };
const moonbitlang$core$builtin$$JSArray$pop = (arr) => arr.pop();
const moonbitlang$core$builtin$$JSArray$splice = (arr, idx, cnt) => arr.splice(idx, cnt);
const moonbitlang$core$builtin$$get_int64_wasm_helper = function f() {   if (f._exports) return f._exports;   return f._exports = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports; };
function $64$moonbitlang$47$core$47$builtin$46$Json$Number(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$Number.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$Json$String(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$String.prototype.$tag = 4;
function $64$moonbitlang$47$core$47$builtin$46$Json$Array(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$Array.prototype.$tag = 5;
function $64$moonbitlang$47$core$47$builtin$46$Json$Object(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$Json$Object.prototype.$tag = 6;
const moonbitlang$core$builtin$$MyInt64$compare = (a, b) => {   const ahi = a.hi;   const bhi = b.hi;   if (ahi < bhi) {     return -1;   }   if (ahi > bhi) {     return 1;   }   const alo = a.lo >>> 0;   const blo = b.lo >>> 0;   if (alo < blo) {     return -1;   }   if (alo > blo) {     return 1;   }   return 0; };
const $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$7$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$7$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$7$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$7$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$7$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$7$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$7$.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$7$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$7$.prototype.$tag = 4;
const $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$8$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$8$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$8$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$8$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$8$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$8$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$8$.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$8$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$8$.prototype.$tag = 4;
const moonbitlang$x$fs$internal$ffi$$read_file_to_string_internal = function(path) {   fs = require('fs');   let content = fs.readFileSync(path, 'utf8');   return content;  };
const moonbitlang$x$fs$internal$ffi$$write_string_to_file_internal = function(path, content) {   fs = require('fs');   fs.writeFileSync(path, content, 'utf8');  };
const moonbitlang$x$fs$internal$ffi$$path_exists_internal = function(path) {   fs = require('fs');   return fs.existsSync(path);  };
function Result$Err$9$(param0) {
  this._0 = param0;
}
Result$Err$9$.prototype.$tag = 0;
function Result$Ok$9$(param0) {
  this._0 = param0;
}
Result$Ok$9$.prototype.$tag = 1;
function Result$Err$10$(param0) {
  this._0 = param0;
}
Result$Err$10$.prototype.$tag = 0;
function Result$Ok$10$(param0) {
  this._0 = param0;
}
Result$Ok$10$.prototype.$tag = 1;
const moonbitlang$x$sys$internal$ffi$$get_cli_args_internal = function() {   return process.argv;  };
function $64$Yoorkin$47$ArgParser$46$Spec$Unit(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Unit.prototype.$tag = 0;
function $64$Yoorkin$47$ArgParser$46$Spec$String(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$String.prototype.$tag = 1;
function $64$Yoorkin$47$ArgParser$46$Spec$Set_string(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Set_string.prototype.$tag = 2;
function $64$Yoorkin$47$ArgParser$46$Spec$Set(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Set.prototype.$tag = 3;
function $64$Yoorkin$47$ArgParser$46$Spec$Clear(param0) {
  this._0 = param0;
}
$64$Yoorkin$47$ArgParser$46$Spec$Clear.prototype.$tag = 4;
function Result$Err$11$(param0) {
  this._0 = param0;
}
Result$Err$11$.prototype.$tag = 0;
function Result$Ok$11$(param0) {
  this._0 = param0;
}
Result$Ok$11$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$Dollar(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$Dollar.prototype.$tag = 0;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$StartPos = { $tag: 1 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$EndPos = { $tag: 2 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$Loc = { $tag: 3 };
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$StartPosOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$StartPosOf.prototype.$tag = 4;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$EndPosOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$EndPosOf.prototype.$tag = 5;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$LocOf(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$LocOf.prototype.$tag = 6;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$SymbolStartPos = { $tag: 7 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$Sloc = { $tag: 8 };
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemIdent$Dollar(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemIdent$Dollar.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemIdent$Name(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemIdent$Name.prototype.$tag = 1;
function Result$Err$12$(param0) {
  this._0 = param0;
}
Result$Err$12$.prototype.$tag = 0;
function Result$Ok$12$(param0) {
  this._0 = param0;
}
Result$Ok$12$.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$EOF = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$IDENT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$IDENT.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$STRING(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$STRING.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LANGLE_CODE_RANGLE(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LANGLE_CODE_RANGLE.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LBRACE_CODE_RBRACE(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LBRACE_CODE_RBRACE.prototype.$tag = 4;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LBRACE_CODE_PERCENT_RBRACE(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LBRACE_CODE_PERCENT_RBRACE.prototype.$tag = 5;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$ARROW_CODE(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$ARROW_CODE.prototype.$tag = 6;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT_CODE_EOF(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT_CODE_EOF.prototype.$tag = 7;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT = { $tag: 8 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_START = { $tag: 9 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_TOKEN = { $tag: 10 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_TYPE = { $tag: 11 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_POSITION = { $tag: 12 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LEFT = { $tag: 13 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_RIGHT = { $tag: 14 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_NONASSOC = { $tag: 15 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PREC = { $tag: 16 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_DERIVE = { $tag: 17 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$COLON = { $tag: 18 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$BAR = { $tag: 19 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$EQ = { $tag: 20 };
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$SEMI = { $tag: 21 };
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$13$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$13$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$13$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Start(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Start.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Token(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Token.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Token1(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Token1.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Type(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Type.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Derive(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Derive.prototype.$tag = 4;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Position(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Position.prototype.$tag = 5;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Left(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Left.prototype.$tag = 6;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Right(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Right.prototype.$tag = 7;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Nonassoc(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Nonassoc.prototype.$tag = 8;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$14$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$14$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$14$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$15$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$15$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$15$.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$16$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$16$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$16$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemSymbol$Symbol(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemSymbol$Symbol.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemSymbol$Image(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemSymbol$Image.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$17$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$17$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$17$.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Accept = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead.prototype.$tag = 3;
const $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error = { $tag: 4 };
function Result$Err$18$(param0) {
  this._0 = param0;
}
Result$Err$18$.prototype.$tag = 0;
function Result$Ok$18$(param0) {
  this._0 = param0;
}
Result$Ok$18$.prototype.$tag = 1;
function Result$Err$19$(param0) {
  this._0 = param0;
}
Result$Err$19$.prototype.$tag = 0;
function Result$Ok$19$(param0) {
  this._0 = param0;
}
Result$Ok$19$.prototype.$tag = 1;
function $i32_ctz(a) {
  a >>>= 0;
  if (a === 0) return 32;
  a &= -a;
  return 31 - Math.clz32(a);
}
const $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input.prototype.$tag = 1;
const $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$20$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$20$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$20$.prototype.$tag = 1;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$20$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$20$.prototype.$tag = 2;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$20$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$20$.prototype.$tag = 3;
function $64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$20$(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$20$.prototype.$tag = 4;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$21$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$21$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$21$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Reduce_conflict_resolved_by_presentation_order(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Reduce_conflict_resolved_by_presentation_order.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_resolved_without_precedence(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_resolved_without_precedence.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_not_resolved_because_of_non_assoc(param0, param1, param2, param3) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
  this._3 = param3;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_not_resolved_because_of_non_assoc.prototype.$tag = 2;
function Result$Err$22$(param0) {
  this._0 = param0;
}
Result$Err$22$.prototype.$tag = 0;
function Result$Ok$22$(param0) {
  this._0 = param0;
}
Result$Ok$22$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Accept = { $tag: 2 };
function $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Conflict(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Conflict.prototype.$tag = 3;
const $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$23$ = { $tag: 0 };
function $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$23$(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$23$.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$T(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$T.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$NT(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$NT.prototype.$tag = 1;
const moonbitlang$yacc$lib$driver$util$$ffi_exit = (code) => { process.exit(code); };
const moonbitlang$yacc$lib$driver$util$$println_to_stderr = (msg) => { console.error("%s", msg); };
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$T(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$T.prototype.$tag = 0;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$NT(param0, param1) {
  this._0 = param0;
  this._1 = param1;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$NT.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$EOI = { $tag: 2 };
const $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Accept = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Shift(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Shift.prototype.$tag = 1;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Reduce(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Reduce.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$ReduceNoLookahead(param0, param1, param2) {
  this._0 = param0;
  this._1 = param1;
  this._2 = param2;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$ReduceNoLookahead.prototype.$tag = 3;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$Data(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$Data.prototype.$tag = 0;
const $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$LastPos = { $tag: 1 };
function $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$StartPos(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$StartPos.prototype.$tag = 2;
function $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$EndPos(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$EndPos.prototype.$tag = 3;
const $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$SymbolStartPos = { $tag: 4 };
const $64$moonbitlang$47$yacc$47$lib$47$codegen$46$Mode$Default = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$codegen$46$Mode$JsonCst(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$codegen$46$Mode$JsonCst.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$driver$46$Mode$Default = { $tag: 0 };
function $64$moonbitlang$47$yacc$47$lib$47$driver$46$Mode$JsonCst(param0) {
  this._0 = param0;
}
$64$moonbitlang$47$yacc$47$lib$47$driver$46$Mode$JsonCst.prototype.$tag = 1;
const $64$moonbitlang$47$yacc$47$lib$47$driver$46$Mode$OnlyTokens = { $tag: 2 };
function Error$$to_string(_e) {
  switch (_e.$tag) {
    case 18: {
      return "moonbitlang/yacc/lib/parser.YYObj__String__Int__Array_SubstItem__.YYObj__String__Int__Array_SubstItem__";
    }
    case 8: {
      return "moonbitlang/yacc/lib/parser.YYObj_String.YYObj_String";
    }
    case 20: {
      return "moonbitlang/yacc/lib/parser.YYObj_ClauseItemSymbol.YYObj_ClauseItemSymbol";
    }
    case 16: {
      return "moonbitlang/yacc/lib/parser.YYObj_Symbol_.YYObj_Symbol_";
    }
    case 5: {
      return "moonbitlang/yacc/lib/parser.YYObj__immut_list_T_Command_.YYObj__immut_list_T_Command_";
    }
    case 15: {
      return "moonbitlang/yacc/lib/parser.YYObj__immut_list_T_ClauseItem_.YYObj__immut_list_T_ClauseItem_";
    }
    case 1: {
      return moonbitlang$core$builtin$$Show$to_string$0$(_e);
    }
    case 22: {
      return "moonbitlang/yacc/lib/parser.ParseError.UnexpectedToken";
    }
    case 2: {
      return "moonbitlang/yacc/lib/parser.LexError.UnexpectedEndOfFile";
    }
    case 14: {
      return "moonbitlang/yacc/lib/parser.YYObj_Clause.YYObj_Clause";
    }
    case 7: {
      return "moonbitlang/yacc/lib/parser.YYObj_ParserSpec.YYObj_ParserSpec";
    }
    case 19: {
      return "moonbitlang/yacc/lib/parser.YYObj_ClauseItem.YYObj_ClauseItem";
    }
    case 21: {
      return "moonbitlang/yacc/lib/parser.YYObj_Void.YYObj_Void";
    }
    case 12: {
      return "moonbitlang/yacc/lib/parser.YYObj_Rule.YYObj_Rule";
    }
    case 10: {
      return "moonbitlang/yacc/lib/parser.YYObj__immut_list_T_Symbol_.YYObj__immut_list_T_Symbol_";
    }
    case 17: {
      return "moonbitlang/yacc/lib/parser.YYObj_ClauseAction.YYObj_ClauseAction";
    }
    case 13: {
      return "moonbitlang/yacc/lib/parser.YYObj__immut_list_T_Clause_.YYObj__immut_list_T_Clause_";
    }
    case 9: {
      return "moonbitlang/yacc/lib/parser.YYObj_Command.YYObj_Command";
    }
    case 4: {
      return "moonbitlang/yacc/lib/parser.YYObj_Code_.YYObj_Code_";
    }
    case 0: {
      return moonbitlang$core$builtin$$Show$to_string$1$(_e);
    }
    case 11: {
      return "moonbitlang/yacc/lib/parser.YYObj_Symbol.YYObj_Symbol";
    }
    case 3: {
      return "moonbitlang/yacc/lib/parser.LexError.Unrecognized";
    }
    default: {
      return "moonbitlang/yacc/lib/parser.YYObj__immut_list_T_Rule_.YYObj__immut_list_T_Rule_";
    }
  }
}
const moonbitlang$core$strconv$$base_err_str = "invalid base";
const moonbitlang$core$strconv$$range_err_str = "value out of range";
const moonbitlang$core$strconv$$syntax_err_str = "invalid syntax";
const moonbitlang$core$immut$internal$sparse_array$$empty_bitset = 0;
const moonbitlang$yacc$lib$parser$$token_tag_action_row_0 = [];
const moonbitlang$yacc$lib$parser$$token_tag_action_row_2 = [-1];
const moonbitlang$yacc$lib$parser$$token_tag_action_row_1 = [0];
const moonbitlang$yacc$lib$parser$$token_tag_action_row_3 = [-1, 0];
const moonbitlang$yacc$lib$parser$$code_eof_tag_action_row_0 = [];
const moonbitlang$yacc$lib$parser$$code_eof_tag_action_row_1 = [0];
const moonbitlang$yacc$lib$parser$$code_eof_tag_action_row_2 = [-1];
const moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_row_0 = [];
const moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_row_1 = [0];
const moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_row_2 = [-1];
const moonbitlang$yacc$lib$parser$$code_rangle_tag_action_row_0 = [];
const moonbitlang$yacc$lib$parser$$code_rangle_tag_action_row_1 = [0];
const moonbitlang$yacc$lib$parser$$code_rangle_tag_action_row_2 = [-1];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0 = [];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1 = [0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2 = [-1];
const moonbitlang$yacc$lib$parser$$comment_star_rparen_tag_action_0 = [];
const moonbitlang$yacc$lib$util$stamp$$next_stamp = { val: 0 };
const moonbitlang$yacc$lib$util$small_int_set$$_empty = [0];
const moonbitlang$yacc$lib$driver$$compile$46$y$2$ = "Show";
const moonbitlang$yacc$main$$_init$42$46$usage$3$ = "Usage: moonyacc [options] <input-file>";
const moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_0 = [moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_1 = [moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_row_2];
const moonbitlang$yacc$lib$parser$$__mbtlex_engine_code_percent_rbrace = { graph: [moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_0, moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_1, moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_2, moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_3, moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_4, moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_5], end_nodes: [undefined, undefined, { _0: 1, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }] }, { _0: 1, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }] }, { _0: 2, _1: [] }, { _0: 0, _1: [] }], start_tags: [0], code_blocks_n: 3 };
const moonbitlang$yacc$lib$parser$$token_tag_action_22 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_29 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_30 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_17 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_21 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_23 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_26 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_18 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_33 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_24 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_31 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_15 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_34 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_27 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_0 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2];
const moonbitlang$yacc$lib$parser$$token_tag_action_20 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_13 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_1 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_19 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_12 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_14 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_16 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_28 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_9 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_3 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_2 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_3, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_3, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_7 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_4 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_5 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_11 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_10 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_8 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_6 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_35 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_25 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$token_tag_action_32 = [moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_1, moonbitlang$yacc$lib$parser$$token_tag_action_row_2, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0, moonbitlang$yacc$lib$parser$$token_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$__mbtlex_engine_token = { graph: [moonbitlang$yacc$lib$parser$$token_state_0, moonbitlang$yacc$lib$parser$$token_state_1, moonbitlang$yacc$lib$parser$$token_state_2, moonbitlang$yacc$lib$parser$$token_state_3, moonbitlang$yacc$lib$parser$$token_state_4, moonbitlang$yacc$lib$parser$$token_state_5, moonbitlang$yacc$lib$parser$$token_state_6, moonbitlang$yacc$lib$parser$$token_state_7, moonbitlang$yacc$lib$parser$$token_state_8, moonbitlang$yacc$lib$parser$$token_state_9, moonbitlang$yacc$lib$parser$$token_state_10, moonbitlang$yacc$lib$parser$$token_state_11, moonbitlang$yacc$lib$parser$$token_state_12, moonbitlang$yacc$lib$parser$$token_state_13, moonbitlang$yacc$lib$parser$$token_state_14, moonbitlang$yacc$lib$parser$$token_state_15, moonbitlang$yacc$lib$parser$$token_state_16, moonbitlang$yacc$lib$parser$$token_state_17, moonbitlang$yacc$lib$parser$$token_state_18, moonbitlang$yacc$lib$parser$$token_state_19, moonbitlang$yacc$lib$parser$$token_state_20, moonbitlang$yacc$lib$parser$$token_state_21, moonbitlang$yacc$lib$parser$$token_state_22, moonbitlang$yacc$lib$parser$$token_state_23, moonbitlang$yacc$lib$parser$$token_state_24, moonbitlang$yacc$lib$parser$$token_state_25, moonbitlang$yacc$lib$parser$$token_state_26, moonbitlang$yacc$lib$parser$$token_state_27, moonbitlang$yacc$lib$parser$$token_state_28, moonbitlang$yacc$lib$parser$$token_state_29, moonbitlang$yacc$lib$parser$$token_state_30, moonbitlang$yacc$lib$parser$$token_state_31, moonbitlang$yacc$lib$parser$$token_state_32, moonbitlang$yacc$lib$parser$$token_state_33, moonbitlang$yacc$lib$parser$$token_state_34, moonbitlang$yacc$lib$parser$$token_state_35, moonbitlang$yacc$lib$parser$$token_state_36, moonbitlang$yacc$lib$parser$$token_state_37, moonbitlang$yacc$lib$parser$$token_state_38, moonbitlang$yacc$lib$parser$$token_state_39, moonbitlang$yacc$lib$parser$$token_state_40, moonbitlang$yacc$lib$parser$$token_state_41, moonbitlang$yacc$lib$parser$$token_state_42, moonbitlang$yacc$lib$parser$$token_state_43, moonbitlang$yacc$lib$parser$$token_state_44, moonbitlang$yacc$lib$parser$$token_state_45, moonbitlang$yacc$lib$parser$$token_state_46, moonbitlang$yacc$lib$parser$$token_state_47, moonbitlang$yacc$lib$parser$$token_state_48, moonbitlang$yacc$lib$parser$$token_state_49, moonbitlang$yacc$lib$parser$$token_state_50, moonbitlang$yacc$lib$parser$$token_state_51, moonbitlang$yacc$lib$parser$$token_state_52, moonbitlang$yacc$lib$parser$$token_state_53, moonbitlang$yacc$lib$parser$$token_state_54, moonbitlang$yacc$lib$parser$$token_state_55, moonbitlang$yacc$lib$parser$$token_state_56, moonbitlang$yacc$lib$parser$$token_state_57, moonbitlang$yacc$lib$parser$$token_state_58, moonbitlang$yacc$lib$parser$$token_state_59, moonbitlang$yacc$lib$parser$$token_state_60, moonbitlang$yacc$lib$parser$$token_state_61, moonbitlang$yacc$lib$parser$$token_state_62, moonbitlang$yacc$lib$parser$$token_state_63, moonbitlang$yacc$lib$parser$$token_state_64, moonbitlang$yacc$lib$parser$$token_state_65, moonbitlang$yacc$lib$parser$$token_state_66, moonbitlang$yacc$lib$parser$$token_state_67, moonbitlang$yacc$lib$parser$$token_state_68, moonbitlang$yacc$lib$parser$$token_state_69, moonbitlang$yacc$lib$parser$$token_state_70, moonbitlang$yacc$lib$parser$$token_state_71, moonbitlang$yacc$lib$parser$$token_state_72, moonbitlang$yacc$lib$parser$$token_state_73, moonbitlang$yacc$lib$parser$$token_state_74, moonbitlang$yacc$lib$parser$$token_state_75, moonbitlang$yacc$lib$parser$$token_state_76, moonbitlang$yacc$lib$parser$$token_state_77, moonbitlang$yacc$lib$parser$$token_state_78, moonbitlang$yacc$lib$parser$$token_state_79, moonbitlang$yacc$lib$parser$$token_state_80, moonbitlang$yacc$lib$parser$$token_state_81], end_nodes: [undefined, undefined, { _0: 24, _1: [{ _0: { _0: 42, _1: 0 }, _1: { _0: 43, _1: 0 } }] }, { _0: 16, _1: [{ _0: { _0: 26, _1: 0 }, _1: { _0: 27, _1: 0 } }] }, { _0: 0, _1: [] }, { _0: 22, _1: [{ _0: { _0: 38, _1: 0 }, _1: { _0: 39, _1: 0 } }] }, { _0: 19, _1: [{ _0: { _0: 32, _1: 0 }, _1: { _0: 33, _1: 0 } }] }, { _0: 24, _1: [{ _0: { _0: 42, _1: 0 }, _1: { _0: 43, _1: 0 } }] }, { _0: 24, _1: [{ _0: { _0: 42, _1: 0 }, _1: { _0: 43, _1: 0 } }] }, { _0: 24, _1: [{ _0: { _0: 42, _1: 0 }, _1: { _0: 43, _1: 0 } }] }, { _0: 24, _1: [{ _0: { _0: 42, _1: 0 }, _1: { _0: 43, _1: 0 } }] }, { _0: 24, _1: [{ _0: { _0: 42, _1: 0 }, _1: { _0: 43, _1: 0 } }] }, { _0: 21, _1: [{ _0: { _0: 36, _1: 0 }, _1: { _0: 37, _1: 0 } }] }, { _0: 18, _1: [{ _0: { _0: 30, _1: 0 }, _1: { _0: 31, _1: 0 } }] }, { _0: 4, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }] }, { _0: 17, _1: [{ _0: { _0: 28, _1: 0 }, _1: { _0: 29, _1: 0 } }] }, { _0: 25, _1: [{ _0: { _0: 44, _1: 0 }, _1: { _0: 45, _1: 0 } }] }, undefined, undefined, undefined, undefined, { _0: 14, _1: [{ _0: { _0: 20, _1: 0 }, _1: { _0: 21, _1: 0 } }] }, { _0: 20, _1: [{ _0: { _0: 34, _1: 0 }, _1: { _0: 35, _1: 0 } }] }, undefined, undefined, undefined, undefined, { _0: 2, _1: [] }, undefined, undefined, { _0: 4, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }] }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, { _0: 23, _1: [{ _0: { _0: 40, _1: 0 }, _1: { _0: 41, _1: 0 } }] }, { _0: 1, _1: [] }, undefined, undefined, undefined, undefined, { _0: 15, _1: [{ _0: { _0: 22, _1: 0 }, _1: { _0: 23, _1: 0 } }, { _0: { _0: 24, _1: 0 }, _1: { _0: 25, _1: 0 } }] }, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, { _0: 3, _1: [] }, undefined, undefined, undefined, { _0: 12, _1: [{ _0: { _0: 16, _1: 0 }, _1: { _0: 17, _1: 0 } }] }, undefined, { _0: 9, _1: [{ _0: { _0: 10, _1: 0 }, _1: { _0: 11, _1: 0 } }] }, undefined, undefined, { _0: 7, _1: [{ _0: { _0: 6, _1: 0 }, _1: { _0: 7, _1: 0 } }] }, undefined, undefined, { _0: 15, _1: [{ _0: { _0: 22, _1: 0 }, _1: { _0: 23, _1: 0 } }, { _0: { _0: 24, _1: 0 }, _1: { _0: 25, _1: 0 } }] }, { _0: 10, _1: [{ _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, undefined, { _0: 5, _1: [{ _0: { _0: 2, _1: 0 }, _1: { _0: 3, _1: 0 } }] }, undefined, { _0: 6, _1: [{ _0: { _0: 4, _1: 0 }, _1: { _0: 5, _1: 0 } }] }, undefined, undefined, { _0: 13, _1: [{ _0: { _0: 18, _1: 0 }, _1: { _0: 19, _1: 0 } }] }, undefined, undefined, undefined, { _0: 8, _1: [{ _0: { _0: 8, _1: 0 }, _1: { _0: 9, _1: 0 } }] }, { _0: 11, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }], start_tags: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44], code_blocks_n: 26 };
const moonbitlang$yacc$lib$parser$$code_eof_tag_action_0 = [moonbitlang$yacc$lib$parser$$code_eof_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_eof_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_eof_tag_action_1 = [moonbitlang$yacc$lib$parser$$code_eof_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_eof_tag_action_row_2];
const moonbitlang$yacc$lib$parser$$__mbtlex_engine_code_eof = { graph: [moonbitlang$yacc$lib$parser$$code_eof_state_0, moonbitlang$yacc$lib$parser$$code_eof_state_1, moonbitlang$yacc$lib$parser$$code_eof_state_2, moonbitlang$yacc$lib$parser$$code_eof_state_3], end_nodes: [undefined, undefined, { _0: 0, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }] }, { _0: 1, _1: [] }], start_tags: [0], code_blocks_n: 2 };
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_8 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_10 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_7 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_9 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_3 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_12 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_13 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_2 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_0 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_1 = [moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_row_2];
const moonbitlang$yacc$lib$parser$$__mbtlex_engine_code_rbrace = { graph: [moonbitlang$yacc$lib$parser$$code_rbrace_state_0, moonbitlang$yacc$lib$parser$$code_rbrace_state_1, moonbitlang$yacc$lib$parser$$code_rbrace_state_2, moonbitlang$yacc$lib$parser$$code_rbrace_state_3, moonbitlang$yacc$lib$parser$$code_rbrace_state_4, moonbitlang$yacc$lib$parser$$code_rbrace_state_5, moonbitlang$yacc$lib$parser$$code_rbrace_state_6, moonbitlang$yacc$lib$parser$$code_rbrace_state_7, moonbitlang$yacc$lib$parser$$code_rbrace_state_8, moonbitlang$yacc$lib$parser$$code_rbrace_state_9, moonbitlang$yacc$lib$parser$$code_rbrace_state_10, moonbitlang$yacc$lib$parser$$code_rbrace_state_11, moonbitlang$yacc$lib$parser$$code_rbrace_state_12, moonbitlang$yacc$lib$parser$$code_rbrace_state_13, moonbitlang$yacc$lib$parser$$code_rbrace_state_14, moonbitlang$yacc$lib$parser$$code_rbrace_state_15, moonbitlang$yacc$lib$parser$$code_rbrace_state_16, moonbitlang$yacc$lib$parser$$code_rbrace_state_17, moonbitlang$yacc$lib$parser$$code_rbrace_state_18, moonbitlang$yacc$lib$parser$$code_rbrace_state_19, moonbitlang$yacc$lib$parser$$code_rbrace_state_20, moonbitlang$yacc$lib$parser$$code_rbrace_state_21, moonbitlang$yacc$lib$parser$$code_rbrace_state_22, moonbitlang$yacc$lib$parser$$code_rbrace_state_23, moonbitlang$yacc$lib$parser$$code_rbrace_state_24, moonbitlang$yacc$lib$parser$$code_rbrace_state_25, moonbitlang$yacc$lib$parser$$code_rbrace_state_26, moonbitlang$yacc$lib$parser$$code_rbrace_state_27, moonbitlang$yacc$lib$parser$$code_rbrace_state_28, moonbitlang$yacc$lib$parser$$code_rbrace_state_29, moonbitlang$yacc$lib$parser$$code_rbrace_state_30, moonbitlang$yacc$lib$parser$$code_rbrace_state_31, moonbitlang$yacc$lib$parser$$code_rbrace_state_32, moonbitlang$yacc$lib$parser$$code_rbrace_state_33, moonbitlang$yacc$lib$parser$$code_rbrace_state_34, moonbitlang$yacc$lib$parser$$code_rbrace_state_35, moonbitlang$yacc$lib$parser$$code_rbrace_state_36, moonbitlang$yacc$lib$parser$$code_rbrace_state_37, moonbitlang$yacc$lib$parser$$code_rbrace_state_38, moonbitlang$yacc$lib$parser$$code_rbrace_state_39, moonbitlang$yacc$lib$parser$$code_rbrace_state_40, moonbitlang$yacc$lib$parser$$code_rbrace_state_41, moonbitlang$yacc$lib$parser$$code_rbrace_state_42, moonbitlang$yacc$lib$parser$$code_rbrace_state_43, moonbitlang$yacc$lib$parser$$code_rbrace_state_44, moonbitlang$yacc$lib$parser$$code_rbrace_state_45, moonbitlang$yacc$lib$parser$$code_rbrace_state_46, moonbitlang$yacc$lib$parser$$code_rbrace_state_47, moonbitlang$yacc$lib$parser$$code_rbrace_state_48, moonbitlang$yacc$lib$parser$$code_rbrace_state_49, moonbitlang$yacc$lib$parser$$code_rbrace_state_50], end_nodes: [undefined, undefined, { _0: 6, _1: [{ _0: { _0: 16, _1: 0 }, _1: { _0: 17, _1: 0 } }] }, { _0: 0, _1: [] }, { _0: 1, _1: [] }, { _0: 7, _1: [] }, { _0: 6, _1: [{ _0: { _0: 16, _1: 0 }, _1: { _0: 17, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 2, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }, { _0: { _0: 2, _1: 0 }, _1: { _0: 3, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 4, _1: [{ _0: { _0: 10, _1: 0 }, _1: { _0: 11, _1: 0 } }, { _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, undefined, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 4, _1: [{ _0: { _0: 10, _1: 0 }, _1: { _0: 11, _1: 0 } }, { _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, undefined, undefined, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 4, _1: [{ _0: { _0: 10, _1: 0 }, _1: { _0: 11, _1: 0 } }, { _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, undefined, undefined, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 3, _1: [{ _0: { _0: 4, _1: 0 }, _1: { _0: 5, _1: 0 } }, { _0: { _0: 6, _1: 0 }, _1: { _0: 7, _1: 0 } }, { _0: { _0: 8, _1: 0 }, _1: { _0: 9, _1: 0 } }] }, undefined, undefined, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 4, _1: [{ _0: { _0: 10, _1: 0 }, _1: { _0: 11, _1: 0 } }, { _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 5, _1: [{ _0: { _0: 14, _1: 0 }, _1: { _0: 15, _1: 0 } }] }, { _0: 4, _1: [{ _0: { _0: 10, _1: 0 }, _1: { _0: 11, _1: 0 } }, { _0: { _0: 12, _1: 0 }, _1: { _0: 13, _1: 0 } }] }], start_tags: [0, 4, 10, 14, 16], code_blocks_n: 8 };
const moonbitlang$yacc$lib$parser$$code_rangle_tag_action_0 = [moonbitlang$yacc$lib$parser$$code_rangle_tag_action_row_0, moonbitlang$yacc$lib$parser$$code_rangle_tag_action_row_0];
const moonbitlang$yacc$lib$parser$$code_rangle_tag_action_1 = [moonbitlang$yacc$lib$parser$$code_rangle_tag_action_row_1, moonbitlang$yacc$lib$parser$$code_rangle_tag_action_row_2];
const moonbitlang$yacc$lib$parser$$__mbtlex_engine_code_rangle = { graph: [moonbitlang$yacc$lib$parser$$code_rangle_state_0, moonbitlang$yacc$lib$parser$$code_rangle_state_1, moonbitlang$yacc$lib$parser$$code_rangle_state_2, moonbitlang$yacc$lib$parser$$code_rangle_state_3, moonbitlang$yacc$lib$parser$$code_rangle_state_4], end_nodes: [undefined, undefined, { _0: 1, _1: [{ _0: { _0: 0, _1: 0 }, _1: { _0: 1, _1: 0 } }] }, { _0: 0, _1: [] }, { _0: 2, _1: [] }], start_tags: [0], code_blocks_n: 3 };
const moonbitlang$yacc$lib$parser$$__mbtlex_engine_comment_star_rparen = { graph: [moonbitlang$yacc$lib$parser$$comment_star_rparen_state_0, moonbitlang$yacc$lib$parser$$comment_star_rparen_state_1, moonbitlang$yacc$lib$parser$$comment_star_rparen_state_2, moonbitlang$yacc$lib$parser$$comment_star_rparen_state_3, moonbitlang$yacc$lib$parser$$comment_star_rparen_state_4, moonbitlang$yacc$lib$parser$$comment_star_rparen_state_5, moonbitlang$yacc$lib$parser$$comment_star_rparen_state_6, moonbitlang$yacc$lib$parser$$comment_star_rparen_state_7], end_nodes: [undefined, undefined, { _0: 2, _1: [] }, { _0: 2, _1: [] }, { _0: 2, _1: [] }, { _0: 3, _1: [] }, { _0: 0, _1: [] }, { _0: 1, _1: [] }], start_tags: [], code_blocks_n: 4 };
const moonbitlang$yacc$lib$util$stamp$$initial_stamp = moonbitlang$yacc$lib$util$stamp$$new();
const moonbitlang$yacc$lib$lr1$$_empty = { concrete_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$empty(), vars: moonbitlang$yacc$lib$util$small_int_set$$empty() };
function moonbitlang$core$strconv$$base_err$4$() {
  return new Result$Err$0$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$base_err_str));
}
function moonbitlang$core$strconv$$check_underscore(str) {
  let s = str;
  let last_char = 33;
  if (s.length > 1 && (s.charCodeAt(0) === 45 || s.charCodeAt(0) === 43)) {
    s = moonbitlang$core$string$$String$substring(s, 1, undefined);
  }
  let hex = false;
  if (s.length >= 2 && (s.charCodeAt(0) === 48 && (s.charCodeAt(1) === 98 || (s.charCodeAt(1) === 66 || (s.charCodeAt(1) === 111 || (s.charCodeAt(1) === 79 || (s.charCodeAt(1) === 120 || s.charCodeAt(1) === 88))))))) {
    last_char = 48;
    hex = s.charCodeAt(1) === 120 || s.charCodeAt(1) === 88;
    s = moonbitlang$core$string$$String$substring(s, 2, undefined);
  }
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < s.length) {
      _L: {
        if (48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {
          last_char = 48;
          break _L;
        }
        if (hex && (97 <= s.charCodeAt(i) && s.charCodeAt(i) <= 102) || 65 <= s.charCodeAt(i) && s.charCodeAt(i) <= 70) {
          last_char = 48;
          break _L;
        }
        if (s.charCodeAt(i) === 95) {
          if (last_char !== 48) {
            return false;
          }
          last_char = 95;
          break _L;
        }
        if (last_char === 95) {
          return false;
        }
        last_char = 33;
        break _L;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return last_char !== 95;
}
function moonbitlang$core$strconv$$determine_base(s) {
  if (s.length < 2) {
    return 10;
  }
  const _bind = moonbitlang$core$string$$String$substring(s, moonbitlang$core$string$$String$substring$46$start$46$default(), 2);
  switch (_bind) {
    case "0x": {
      return 16;
    }
    case "0X": {
      return 16;
    }
    case "0o": {
      return 8;
    }
    case "0O": {
      return 8;
    }
    case "0b": {
      return 2;
    }
    case "0B": {
      return 2;
    }
    default: {
      return 10;
    }
  }
}
function moonbitlang$core$strconv$$overflow_threshold(base, neg) {
  return !neg ? (base === 10 ? moonbitlang$core$int64$$Int64$op_add(moonbitlang$core$int64$$Int64$op_div($9223372036854775807L, $10L), $1L) : base === 16 ? moonbitlang$core$int64$$Int64$op_add(moonbitlang$core$int64$$Int64$op_div($9223372036854775807L, $16L), $1L) : moonbitlang$core$int64$$Int64$op_add(moonbitlang$core$int64$$Int64$op_div($9223372036854775807L, moonbitlang$core$int$$Int$to_int64(base)), $1L)) : base === 10 ? moonbitlang$core$int64$$Int64$op_div($_9223372036854775808L, $10L) : base === 16 ? moonbitlang$core$int64$$Int64$op_div($_9223372036854775808L, $16L) : moonbitlang$core$int64$$Int64$op_div($_9223372036854775808L, moonbitlang$core$int$$Int$to_int64(base));
}
function moonbitlang$core$strconv$$range_err$4$() {
  return new Result$Err$0$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$range_err_str));
}
function moonbitlang$core$strconv$$syntax_err$4$() {
  return new Result$Err$0$(new Error$moonbitlang$47$core$47$strconv$46$StrConvError$46$StrConvError(moonbitlang$core$strconv$$syntax_err_str));
}
function moonbitlang$core$strconv$$parse_int64(str, base) {
  if (str === "") {
    const _bind = moonbitlang$core$strconv$$syntax_err$4$();
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  if (!moonbitlang$core$strconv$$check_underscore(str)) {
    const _bind = moonbitlang$core$strconv$$syntax_err$4$();
    if (_bind.$tag === 1) {
      const _ok = _bind;
      _ok._0;
    } else {
      return _bind;
    }
  }
  let s = str;
  let neg = false;
  if (s.charCodeAt(0) === 43 || s.charCodeAt(0) === 45) {
    neg = s.charCodeAt(0) === 45;
    s = moonbitlang$core$string$$String$substring(s, 1, undefined);
  }
  let num_base = 10;
  if (base === 0) {
    num_base = moonbitlang$core$strconv$$determine_base(s);
    if (num_base !== 10) {
      s = moonbitlang$core$string$$String$substring(s, 2, undefined);
    }
  } else {
    if (2 <= base && base <= 36) {
      num_base = base;
    } else {
      const _bind = moonbitlang$core$strconv$$base_err$4$();
      if (_bind.$tag === 1) {
        const _ok = _bind;
        _ok._0;
      } else {
        return _bind;
      }
    }
  }
  const overflow_threshold = moonbitlang$core$strconv$$overflow_threshold(num_base, neg);
  let n = $0L;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < s.length) {
      _L: {
        const c = s.charCodeAt(i);
        let d = 0;
        if (c === 95) {
          break _L;
        } else {
          if (48 <= c && c <= 57) {
            d = moonbitlang$core$char$$Char$op_sub(c, 48);
          } else {
            if (97 <= c && c <= 122) {
              d = moonbitlang$core$char$$Char$op_sub(c, 97) + 10 | 0;
            } else {
              if (65 <= c && c <= 90) {
                d = moonbitlang$core$char$$Char$op_sub(c, 65) + 10 | 0;
              } else {
                const _bind = moonbitlang$core$strconv$$syntax_err$4$();
                if (_bind.$tag === 1) {
                  const _ok = _bind;
                  _ok._0;
                } else {
                  return _bind;
                }
              }
            }
          }
        }
        if (d >= num_base) {
          const _bind = moonbitlang$core$strconv$$syntax_err$4$();
          if (_bind.$tag === 1) {
            const _ok = _bind;
            _ok._0;
          } else {
            return _bind;
          }
        }
        if (neg && moonbitlang$core$builtin$$op_lt$5$(n, overflow_threshold) || !neg && moonbitlang$core$builtin$$op_ge$5$(n, overflow_threshold)) {
          const _bind = moonbitlang$core$strconv$$range_err$4$();
          if (_bind.$tag === 1) {
            const _ok = _bind;
            _ok._0;
          } else {
            return _bind;
          }
        }
        n = moonbitlang$core$int64$$Int64$op_mul(n, moonbitlang$core$int$$Int$to_int64(num_base));
        if (neg) {
          const n1 = moonbitlang$core$int64$$Int64$op_sub(n, moonbitlang$core$int$$Int$to_int64(d));
          if (moonbitlang$core$builtin$$op_gt$5$(n1, n)) {
            const _bind = moonbitlang$core$strconv$$range_err$4$();
            if (_bind.$tag === 1) {
              const _ok = _bind;
              _ok._0;
            } else {
              return _bind;
            }
          }
          n = n1;
        } else {
          const n1 = moonbitlang$core$int64$$Int64$op_add(n, moonbitlang$core$int$$Int$to_int64(d));
          if (moonbitlang$core$builtin$$op_lt$5$(n1, n)) {
            const _bind = moonbitlang$core$strconv$$range_err$4$();
            if (_bind.$tag === 1) {
              const _ok = _bind;
              _ok._0;
            } else {
              return _bind;
            }
          }
          n = n1;
        }
        break _L;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Ok$1$(n);
}
function moonbitlang$core$strconv$$parse_int(str, base) {
  const _bind = moonbitlang$core$strconv$$parse_int64(str, base);
  let n;
  if (_bind.$tag === 1) {
    const _ok = _bind;
    n = _ok._0;
  } else {
    return _bind;
  }
  if (moonbitlang$core$builtin$$op_lt$5$(n, moonbitlang$core$int$$Int$to_int64(-2147483648)) || moonbitlang$core$builtin$$op_gt$5$(n, moonbitlang$core$int$$Int$to_int64(2147483647))) {
    const _bind$2 = moonbitlang$core$strconv$$range_err$4$();
    if (_bind$2.$tag === 1) {
      const _ok = _bind$2;
      _ok._0;
    } else {
      return _bind$2;
    }
  }
  return new Result$Ok$2$(moonbitlang$core$int64$$Int64$to_int(n));
}
function moonbitlang$core$builtin$$Show$output$6$(self, logger) {
  const _StrConvError = self;
  const _x = _StrConvError._0;
  logger.method_0(logger.self, _x);
}
function moonbitlang$core$string$$is_leading_surrogate(c) {
  return 55296 <= c && c <= 56319;
}
function moonbitlang$core$string$$is_trailing_surrogate(c) {
  return 56320 <= c && c <= 57343;
}
function moonbitlang$core$string$$code_point_of_surrogate_pair(leading, trailing) {
  return (((Math.imul(leading - 55296 | 0, 1024) | 0) + trailing | 0) - 56320 | 0) + 65536 | 0;
}
function moonbitlang$core$string$$String$concat(strings, separator) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  if (separator === "") {
    const _len = strings.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const s = strings[_i];
        moonbitlang$core$builtin$$StringBuilder$write_string(buf, s);
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
  } else {
    if (strings.length === 0) {
    } else {
      const _x = moonbitlang$core$array$$Array$op_get$7$(strings, 0);
      const _x$2 = moonbitlang$core$array$$Array$op_as_view$7$(strings, 1, strings.length - 0 | 0);
      moonbitlang$core$builtin$$StringBuilder$write_string(buf, _x);
      const _len = moonbitlang$core$array$$ArrayView$length$7$(_x$2);
      let _tmp = 0;
      while (true) {
        const _i = _tmp;
        if (_i < _len) {
          const s = _x$2.buf[_x$2.start + _i | 0];
          moonbitlang$core$builtin$$StringBuilder$write_string(buf, separator);
          moonbitlang$core$builtin$$StringBuilder$write_string(buf, s);
          _tmp = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
    }
  }
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$string$$String$compare(self, other) {
  const len = self.length;
  const _bind = $compare_int(len, other.length);
  if (_bind === 0) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const order = $compare_int(self.charCodeAt(i), other.charCodeAt(i));
        if (order !== 0) {
          return order;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return 0;
  } else {
    return _bind;
  }
}
function moonbitlang$core$string$$String$default() {
  return "";
}
function moonbitlang$core$string$$String$iter(self) {
  return moonbitlang$core$builtin$$Iter$new$8$((yield_) => {
    const len = self.length;
    let _tmp = 0;
    while (true) {
      const index = _tmp;
      if (index < len) {
        const c1 = self.charCodeAt(index);
        if (moonbitlang$core$string$$is_leading_surrogate(c1) && (index + 1 | 0) < len) {
          const c2 = self.charCodeAt(index + 1 | 0);
          if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
            const c = moonbitlang$core$string$$code_point_of_surrogate_pair(c1, c2);
            const _bind = yield_(c);
            if (_bind === 1) {
              _tmp = index + 2 | 0;
              continue;
            } else {
              return _bind;
            }
          }
        }
        const _bind = yield_(c1);
        if (_bind === 1) {
        } else {
          return _bind;
        }
        _tmp = index + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$string$$String$to_array(self) {
  const _bind = moonbitlang$core$string$$String$iter(self);
  const _bind$2 = moonbitlang$core$array$$Array$new$8$(self.length);
  const _acc = { val: _bind$2 };
  _bind((_p) => {
    const rv = _acc.val;
    moonbitlang$core$array$$Array$push$8$(rv, _p);
    _acc.val = rv;
    return 1;
  });
  return _acc.val;
}
function moonbitlang$core$string$$String$contains_char(self, c) {
  return moonbitlang$core$builtin$$Iter$any$8$(moonbitlang$core$string$$String$iter(self), (ch) => ch === c);
}
function moonbitlang$core$string$$String$trim_end(self, trim_set) {
  const len = self.length;
  let _tmp = len - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      const c2 = self.charCodeAt(i);
      if (moonbitlang$core$string$$is_trailing_surrogate(c2) && (i - 1 | 0) >= 0) {
        const c1 = self.charCodeAt(i - 1 | 0);
        if (moonbitlang$core$string$$is_leading_surrogate(c1)) {
          const ch = moonbitlang$core$string$$code_point_of_surrogate_pair(c1, c2);
          if (moonbitlang$core$string$$String$contains_char(trim_set, ch)) {
            _tmp = i - 2 | 0;
            continue;
          } else {
            return moonbitlang$core$string$$String$substring(self, moonbitlang$core$string$$String$substring$46$start$46$default(), i + 1 | 0);
          }
        }
      }
      if (!moonbitlang$core$string$$String$contains_char(trim_set, self.charCodeAt(i))) {
        return moonbitlang$core$string$$String$substring(self, moonbitlang$core$string$$String$substring$46$start$46$default(), i + 1 | 0);
      }
      _tmp = i - 1 | 0;
      continue;
    } else {
      return "";
    }
  }
}
function moonbitlang$core$string$$String$trim_start(self, trim_set) {
  const len = self.length;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      const c1 = self.charCodeAt(i);
      if (moonbitlang$core$string$$is_leading_surrogate(c1) && (i + 1 | 0) < len) {
        const c2 = self.charCodeAt(i + 1 | 0);
        if (moonbitlang$core$string$$is_trailing_surrogate(c2)) {
          const ch = moonbitlang$core$string$$code_point_of_surrogate_pair(c1, c2);
          if (moonbitlang$core$string$$String$contains_char(trim_set, ch)) {
            _tmp = i + 2 | 0;
            continue;
          } else {
            return moonbitlang$core$string$$String$substring(self, i, undefined);
          }
        }
      }
      if (!moonbitlang$core$string$$String$contains_char(trim_set, self.charCodeAt(i))) {
        return moonbitlang$core$string$$String$substring(self, i, undefined);
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return "";
    }
  }
}
function moonbitlang$core$string$$String$trim(self, trim_set) {
  return self === "" || trim_set === "" ? self : moonbitlang$core$string$$String$trim_end(moonbitlang$core$string$$String$trim_start(self, trim_set), trim_set);
}
function moonbitlang$core$string$$String$index_of(self, str, from) {
  const from$2 = from < 0 ? 0 : from >= self.length ? self.length - 1 | 0 : from;
  const len = self.length;
  const sub_len = str.length;
  const max_idx = len - sub_len | 0;
  if (sub_len === 0) {
    return 0;
  }
  if (sub_len > len) {
    return -1;
  }
  const first = str.charCodeAt(0);
  let i = from$2;
  while (true) {
    if (i <= max_idx) {
      while (true) {
        if (i < len && self.charCodeAt(i) !== first) {
          i = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (i <= max_idx) {
        let j = i + 1 | 0;
        let k = 1;
        const end = (j + sub_len | 0) - 1 | 0;
        while (true) {
          if (j < end && self.charCodeAt(j) === str.charCodeAt(k)) {
            j = j + 1 | 0;
            k = k + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        if (j === end) {
          return i;
        }
      }
      i = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return -1;
}
function moonbitlang$core$string$$String$index_of$46$from$46$default() {
  return 0;
}
function moonbitlang$core$string$$String$starts_with(self, str) {
  return str.length > self.length ? false : moonbitlang$core$string$$String$index_of(self, str, moonbitlang$core$string$$String$index_of$46$from$46$default()) === 0;
}
function moonbitlang$core$string$$String$split(self, seperator) {
  const len = self.length;
  const sep_len = seperator.length;
  if (sep_len === 0) {
    const _bind = moonbitlang$core$string$$String$iter(self);
    return (_p) => _bind((_p$2) => _p(String.fromCodePoint(_p$2)));
  }
  return moonbitlang$core$builtin$$Iter$new$7$((yield_) => {
    let start = 0;
    while (true) {
      if (start < len) {
        const end = moonbitlang$core$string$$String$index_of(self, seperator, start);
        if (end < 0) {
          if (moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(moonbitlang$core$string$$String$substring(self, start, undefined)), 0)) {
            return 0;
          }
          return 1;
        }
        if (moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(moonbitlang$core$string$$String$substring(self, start, end)), 0)) {
          return 0;
        }
        start = end + sep_len | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$string$$String$replace_all(self, old, new_) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  const len = self.length;
  const old_len = old.length;
  if (old_len === 0) {
    moonbitlang$core$builtin$$StringBuilder$write_string(buf, new_);
    const _bind = moonbitlang$core$string$$String$iter(self);
    _bind((_p) => {
      moonbitlang$core$builtin$$StringBuilder$write_char(buf, _p);
      moonbitlang$core$builtin$$StringBuilder$write_string(buf, new_);
      return 1;
    });
  } else {
    let start = 0;
    while (true) {
      if (start < len) {
        const end = moonbitlang$core$string$$String$index_of(self, old, start);
        if (end < 0) {
          moonbitlang$core$builtin$$StringBuilder$write_string(buf, moonbitlang$core$string$$String$substring(self, start, undefined));
          break;
        }
        moonbitlang$core$builtin$$StringBuilder$write_string(buf, moonbitlang$core$string$$String$substring(self, start, end));
        moonbitlang$core$builtin$$StringBuilder$write_string(buf, new_);
        start = end + old_len | 0;
        continue;
      } else {
        break;
      }
    }
  }
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$string$$String$repeat(self, n) {
  if (n <= 0) {
    return "";
  }
  if (n === 1) {
    return self;
  }
  const len = self.length;
  const buf = moonbitlang$core$builtin$$StringBuilder$new(Math.imul(len, n) | 0);
  let _tmp = 0;
  while (true) {
    const _ = _tmp;
    if (_ < n) {
      moonbitlang$core$builtin$$StringBuilder$write_string(buf, self);
      _tmp = _ + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$result$$Result$unwrap$10$(self) {
  if (self.$tag === 1) {
    const _Ok = self;
    const _x = _Ok._0;
    return _x;
  } else {
    return moonbitlang$core$builtin$$abort$11$("called `Result::unwrap()` on an `Err` value");
  }
}
function moonbitlang$core$ref$$new$12$(x) {
  return { val: x };
}
function moonbitlang$core$ref$$new$13$(x) {
  return { val: x };
}
function moonbitlang$core$ref$$new$14$(x) {
  return { val: x };
}
function moonbitlang$core$ref$$new$15$(x) {
  return { val: x };
}
function moonbitlang$core$ref$$new$16$(x) {
  return { val: x };
}
function moonbitlang$core$ref$$new$7$(x) {
  return { val: x };
}
function moonbitlang$core$sorted_set$$new$17$() {
  return { root: undefined, size: $0L };
}
function moonbitlang$core$sorted_set$$new$7$() {
  return { root: undefined, size: $0L };
}
function moonbitlang$core$sorted_set$$new$18$() {
  return { root: undefined, size: $0L };
}
function moonbitlang$core$sorted_set$$height$7$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_set$$height$18$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_set$$height$17$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_set$$height_ge$7$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_set$$height_ge$18$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_set$$height_ge$17$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_set$$max(x, y) {
  return x > y ? x : y;
}
function moonbitlang$core$sorted_set$$Node$update_height$7$(self) {
  self.height = 1 + moonbitlang$core$sorted_set$$max(moonbitlang$core$sorted_set$$height$7$(self.left), moonbitlang$core$sorted_set$$height$7$(self.right)) | 0;
}
function moonbitlang$core$sorted_set$$Node$update_height$18$(self) {
  self.height = 1 + moonbitlang$core$sorted_set$$max(moonbitlang$core$sorted_set$$height$18$(self.left), moonbitlang$core$sorted_set$$height$18$(self.right)) | 0;
}
function moonbitlang$core$sorted_set$$Node$update_height$17$(self) {
  self.height = 1 + moonbitlang$core$sorted_set$$max(moonbitlang$core$sorted_set$$height$17$(self.left), moonbitlang$core$sorted_set$$height$17$(self.right)) | 0;
}
function moonbitlang$core$sorted_set$$rotate_l$7$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$19$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_set$$Node$update_height$7$(n);
  moonbitlang$core$sorted_set$$Node$update_height$7$(r);
  return r;
}
function moonbitlang$core$sorted_set$$rotate_l$18$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$20$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_set$$Node$update_height$18$(n);
  moonbitlang$core$sorted_set$$Node$update_height$18$(r);
  return r;
}
function moonbitlang$core$sorted_set$$rotate_l$17$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$21$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_set$$Node$update_height$17$(n);
  moonbitlang$core$sorted_set$$Node$update_height$17$(r);
  return r;
}
function moonbitlang$core$sorted_set$$rotate_r$7$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$19$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_set$$Node$update_height$7$(n);
  moonbitlang$core$sorted_set$$Node$update_height$7$(l);
  return l;
}
function moonbitlang$core$sorted_set$$rotate_r$18$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$20$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_set$$Node$update_height$18$(n);
  moonbitlang$core$sorted_set$$Node$update_height$18$(l);
  return l;
}
function moonbitlang$core$sorted_set$$rotate_r$17$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$21$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_set$$Node$update_height$17$(n);
  moonbitlang$core$sorted_set$$Node$update_height$17$(l);
  return l;
}
function moonbitlang$core$sorted_set$$rotate_lr$7$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$19$(n.left);
  const v = moonbitlang$core$sorted_set$$rotate_l$7$(l);
  n.left = v;
  return moonbitlang$core$sorted_set$$rotate_r$7$(n);
}
function moonbitlang$core$sorted_set$$rotate_lr$18$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$20$(n.left);
  const v = moonbitlang$core$sorted_set$$rotate_l$18$(l);
  n.left = v;
  return moonbitlang$core$sorted_set$$rotate_r$18$(n);
}
function moonbitlang$core$sorted_set$$rotate_lr$17$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$21$(n.left);
  const v = moonbitlang$core$sorted_set$$rotate_l$17$(l);
  n.left = v;
  return moonbitlang$core$sorted_set$$rotate_r$17$(n);
}
function moonbitlang$core$sorted_set$$rotate_rl$7$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$19$(n.right);
  const v = moonbitlang$core$sorted_set$$rotate_r$7$(r);
  n.right = v;
  return moonbitlang$core$sorted_set$$rotate_l$7$(n);
}
function moonbitlang$core$sorted_set$$rotate_rl$18$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$20$(n.right);
  const v = moonbitlang$core$sorted_set$$rotate_r$18$(r);
  n.right = v;
  return moonbitlang$core$sorted_set$$rotate_l$18$(n);
}
function moonbitlang$core$sorted_set$$rotate_rl$17$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$21$(n.right);
  const v = moonbitlang$core$sorted_set$$rotate_r$17$(r);
  n.right = v;
  return moonbitlang$core$sorted_set$$rotate_l$17$(n);
}
function moonbitlang$core$sorted_set$$balance$18$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_set$$height$18$(l);
  const hr = moonbitlang$core$sorted_set$$height$18$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$20$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_set$$height_ge$18$(_x, _x$2) ? moonbitlang$core$sorted_set$$rotate_r$18$(root) : moonbitlang$core$sorted_set$$rotate_lr$18$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$20$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_set$$height_ge$18$(_x$2, _x) ? moonbitlang$core$sorted_set$$rotate_l$18$(root) : moonbitlang$core$sorted_set$$rotate_rl$18$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_set$$Node$update_height$18$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_set$$balance$7$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_set$$height$7$(l);
  const hr = moonbitlang$core$sorted_set$$height$7$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$19$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_set$$height_ge$7$(_x, _x$2) ? moonbitlang$core$sorted_set$$rotate_r$7$(root) : moonbitlang$core$sorted_set$$rotate_lr$7$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$19$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_set$$height_ge$7$(_x$2, _x) ? moonbitlang$core$sorted_set$$rotate_l$7$(root) : moonbitlang$core$sorted_set$$rotate_rl$7$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_set$$Node$update_height$7$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_set$$balance$17$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_set$$height$17$(l);
  const hr = moonbitlang$core$sorted_set$$height$17$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$21$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_set$$height_ge$17$(_x, _x$2) ? moonbitlang$core$sorted_set$$rotate_r$17$(root) : moonbitlang$core$sorted_set$$rotate_lr$17$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$21$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_set$$height_ge$17$(_x$2, _x) ? moonbitlang$core$sorted_set$$rotate_l$17$(root) : moonbitlang$core$sorted_set$$rotate_rl$17$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_set$$Node$update_height$17$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_set$$new_node$17$(value, left, right, height) {
  return { value: value, left: left, right: right, height: height };
}
function moonbitlang$core$sorted_set$$new_node$18$(value, left, right, height) {
  return { value: value, left: left, right: right, height: height };
}
function moonbitlang$core$sorted_set$$new_node$7$(value, left, right, height) {
  return { value: value, left: left, right: right, height: height };
}
function moonbitlang$core$sorted_set$$new_node$46$left$46$default$17$() {
  return undefined;
}
function moonbitlang$core$sorted_set$$new_node$46$left$46$default$18$() {
  return undefined;
}
function moonbitlang$core$sorted_set$$new_node$46$left$46$default$7$() {
  return undefined;
}
function moonbitlang$core$sorted_set$$new_node$46$right$46$default$17$() {
  return undefined;
}
function moonbitlang$core$sorted_set$$new_node$46$right$46$default$18$() {
  return undefined;
}
function moonbitlang$core$sorted_set$$new_node$46$right$46$default$7$() {
  return undefined;
}
function moonbitlang$core$sorted_set$$new_node$46$height$46$default$17$() {
  return 1;
}
function moonbitlang$core$sorted_set$$new_node$46$height$46$default$18$() {
  return 1;
}
function moonbitlang$core$sorted_set$$new_node$46$height$46$default$7$() {
  return 1;
}
function moonbitlang$core$sorted_set$$add_node$7$(root, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_set$$new_node$7$(value, moonbitlang$core$sorted_set$$new_node$46$left$46$default$7$(), moonbitlang$core$sorted_set$$new_node$46$right$46$default$7$(), moonbitlang$core$sorted_set$$new_node$46$height$46$default$7$()), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    const comp = moonbitlang$core$string$$String$compare(value, _x.value);
    if (comp === 0) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (comp < 0) {
        const _bind = moonbitlang$core$sorted_set$$add_node$7$(l, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$7$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_set$$add_node$7$(r, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$7$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_set$$add_node$18$(root, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_set$$new_node$18$(value, moonbitlang$core$sorted_set$$new_node$46$left$46$default$18$(), moonbitlang$core$sorted_set$$new_node$46$right$46$default$18$(), moonbitlang$core$sorted_set$$new_node$46$height$46$default$18$()), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    const comp = moonbitlang$core$builtin$$Compare$compare$18$(value, _x.value);
    if (comp === 0) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (comp < 0) {
        const _bind = moonbitlang$core$sorted_set$$add_node$18$(l, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$18$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_set$$add_node$18$(r, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$18$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_set$$add_node$17$(root, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_set$$new_node$17$(value, moonbitlang$core$sorted_set$$new_node$46$left$46$default$17$(), moonbitlang$core$sorted_set$$new_node$46$right$46$default$17$(), moonbitlang$core$sorted_set$$new_node$46$height$46$default$17$()), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    const comp = moonbitlang$yacc$lib$grm$$Nonterminal$compare(value, _x.value);
    if (comp === 0) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (comp < 0) {
        const _bind = moonbitlang$core$sorted_set$$add_node$17$(l, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$17$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_set$$add_node$17$(r, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$17$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_set$$T$add$17$(self, value) {
  const _bind = moonbitlang$core$sorted_set$$add_node$17$(self.root, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$22$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = moonbitlang$core$int64$$Int64$op_add(self.size, $1L);
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_set$$T$add$18$(self, value) {
  const _bind = moonbitlang$core$sorted_set$$add_node$18$(self.root, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$23$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = moonbitlang$core$int64$$Int64$op_add(self.size, $1L);
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_set$$T$add$7$(self, value) {
  const _bind = moonbitlang$core$sorted_set$$add_node$7$(self.root, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$24$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = moonbitlang$core$int64$$Int64$op_add(self.size, $1L);
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_set$$replace_root_with_min$17$(root, node) {
  const l = node.left;
  const r = node.right;
  if (l === undefined) {
    root.value = node.value;
    return r;
  } else {
    const _Some = l;
    const _x = _Some;
    node.left = moonbitlang$core$sorted_set$$replace_root_with_min$17$(root, _x);
    return moonbitlang$core$sorted_set$$balance$17$(node);
  }
}
function moonbitlang$core$sorted_set$$delete_node$17$(root, value) {
  const comp = moonbitlang$yacc$lib$grm$$Nonterminal$compare(value, root.value);
  if (comp === 0) {
    const l = root.left;
    const r = root.right;
    let n;
    _L: {
      _L$2: {
        if (l === undefined) {
          if (r === undefined) {
            break _L$2;
          } else {
            n = r;
          }
        } else {
          if (r === undefined) {
            break _L$2;
          } else {
            const _Some = r;
            const _x = _Some;
            root.right = moonbitlang$core$sorted_set$$replace_root_with_min$17$(root, _x);
            n = moonbitlang$core$sorted_set$$balance$17$(root);
          }
        }
        break _L;
      }
      n = l;
    }
    return { _0: n, _1: true };
  } else {
    if (comp < 0) {
      const _bind = root.left;
      if (_bind === undefined) {
        return { _0: root, _1: false };
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _bind$2 = moonbitlang$core$sorted_set$$delete_node$17$(_x, value);
        const _x$2 = _bind$2._0;
        const _x$3 = _bind$2._1;
        root.left = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$17$(root), _1: _x$3 };
      }
    } else {
      const _bind = root.right;
      if (_bind === undefined) {
        return { _0: root, _1: false };
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _bind$2 = moonbitlang$core$sorted_set$$delete_node$17$(_x, value);
        const _x$2 = _bind$2._0;
        const _x$3 = _bind$2._1;
        root.right = _x$2;
        return { _0: moonbitlang$core$sorted_set$$balance$17$(root), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_set$$T$remove$17$(self, value) {
  const _bind = self.root;
  if (_bind === undefined) {
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    const _bind$2 = moonbitlang$core$sorted_set$$delete_node$17$(_x, value);
    const _x$2 = _bind$2._0;
    const _x$3 = _bind$2._1;
    if (moonbitlang$core$builtin$$op_notequal$22$(self.root, _x$2)) {
      self.root = _x$2;
    }
    if (_x$3) {
      self.size = moonbitlang$core$int64$$Int64$op_sub(self.size, $1L);
      return;
    } else {
      return;
    }
  }
}
function moonbitlang$core$sorted_set$$T$contains$18$(self, value) {
  let _tmp = self.root;
  let _tmp$2 = value;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (_param === undefined) {
      return false;
    } else {
      const _Some = _param;
      const _x = _Some;
      const compare_result = moonbitlang$core$builtin$$Compare$compare$18$(_param$2, _x.value);
      if (compare_result === 0) {
        return true;
      } else {
        if (compare_result < 0) {
          _tmp = _x.left;
          continue;
        } else {
          _tmp = _x.right;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_set$$Node$iter$7$(self) {
  return moonbitlang$core$builtin$$Iter$new$7$((yield_) => {
    const _x = self.left;
    const _x$2 = self.value;
    const _x$3 = self.right;
    let res;
    if (_x === undefined) {
      res = 1;
    } else {
      const _Some = _x;
      const _x$4 = _Some;
      res = moonbitlang$core$builtin$$Iter$run$7$(moonbitlang$core$sorted_set$$Node$iter$7$(_x$4), yield_);
    }
    if (moonbitlang$core$builtin$$Eq$op_equal$9$(res, 0)) {
      return 0;
    } else {
      if (moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x$2), 0)) {
        return 0;
      } else {
        if (_x$3 === undefined) {
          return 1;
        } else {
          const _Some = _x$3;
          const _x$4 = _Some;
          return moonbitlang$core$builtin$$Iter$run$7$(moonbitlang$core$sorted_set$$Node$iter$7$(_x$4), yield_);
        }
      }
    }
  });
}
function moonbitlang$core$sorted_set$$Node$iter$17$(self) {
  return moonbitlang$core$builtin$$Iter$new$17$((yield_) => {
    const _x = self.left;
    const _x$2 = self.value;
    const _x$3 = self.right;
    let res;
    if (_x === undefined) {
      res = 1;
    } else {
      const _Some = _x;
      const _x$4 = _Some;
      res = moonbitlang$core$builtin$$Iter$run$17$(moonbitlang$core$sorted_set$$Node$iter$17$(_x$4), yield_);
    }
    if (moonbitlang$core$builtin$$Eq$op_equal$9$(res, 0)) {
      return 0;
    } else {
      if (moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x$2), 0)) {
        return 0;
      } else {
        if (_x$3 === undefined) {
          return 1;
        } else {
          const _Some = _x$3;
          const _x$4 = _Some;
          return moonbitlang$core$builtin$$Iter$run$17$(moonbitlang$core$sorted_set$$Node$iter$17$(_x$4), yield_);
        }
      }
    }
  });
}
function moonbitlang$core$sorted_set$$T$iter$7$(self) {
  return moonbitlang$core$builtin$$Iter$new$7$((yield_) => {
    const _bind = self.root;
    if (_bind === undefined) {
      return 1;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return moonbitlang$core$builtin$$Iter$run$7$(moonbitlang$core$sorted_set$$Node$iter$7$(_x), yield_);
    }
  });
}
function moonbitlang$core$sorted_set$$T$iter$17$(self) {
  return moonbitlang$core$builtin$$Iter$new$17$((yield_) => {
    const _bind = self.root;
    if (_bind === undefined) {
      return 1;
    } else {
      const _Some = _bind;
      const _x = _Some;
      return moonbitlang$core$builtin$$Iter$run$17$(moonbitlang$core$sorted_set$$Node$iter$17$(_x), yield_);
    }
  });
}
function moonbitlang$core$sorted_set$$from_iter$17$(iter) {
  const s = moonbitlang$core$sorted_set$$new$17$();
  iter((_p) => {
    moonbitlang$core$sorted_set$$T$add$17$(s, _p);
    return 1;
  });
  return s;
}
function moonbitlang$core$sorted_set$$Node$op_equal$7$(self, other) {
  return self.value === other.value;
}
function moonbitlang$core$sorted_set$$Node$op_equal$18$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$18$(self.value, other.value);
}
function moonbitlang$core$sorted_set$$Node$op_equal$17$(self, other) {
  return moonbitlang$yacc$lib$grm$$Nonterminal$op_equal(self.value, other.value);
}
function moonbitlang$core$array$$get_limit(len) {
  let len$2 = len;
  let limit = 0;
  while (true) {
    if (len$2 > 0) {
      len$2 = len$2 / 2 | 0;
      limit = limit + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return limit;
}
function moonbitlang$core$array$$ArrayView$rev_inplace$25$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$25$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$25$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$25$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$ArrayView$rev_inplace$26$(self) {
  const mid_len = moonbitlang$core$array$$ArrayView$length$26$(self) / 2 | 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < mid_len) {
      const j = (moonbitlang$core$array$$ArrayView$length$26$(self) - i | 0) - 1 | 0;
      moonbitlang$core$array$$ArrayView$swap$26$(self, i, j);
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$minimum(x, y) {
  return x > y ? y : x;
}
function moonbitlang$core$array$$FixedArray$copy$27$(self) {
  const len = self.length;
  if (len === 0) {
    return [];
  } else {
    const arr = $make_array_len_and_init(len, self[0]);
    moonbitlang$core$array$$FixedArray$unsafe_blit$27$(arr, 0, self, 0, len);
    return arr;
  }
}
function moonbitlang$core$array$$Array$copy$28$(self) {
  return moonbitlang$core$array$$JSArray$copy(self);
}
function moonbitlang$core$array$$FixedArray$makei$29$(length, value) {
  if (length <= 0) {
    return [];
  } else {
    const array = $make_array_len_and_init(length, value(0));
    let _tmp = 1;
    while (true) {
      const i = _tmp;
      if (i < length) {
        array[i] = value(i);
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return array;
  }
}
function moonbitlang$core$array$$bubble_sort_by$25$(arr, cmp) {
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < moonbitlang$core$array$$ArrayView$length$25$(arr)) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$25$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$25$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$25$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$bubble_sort_by$26$(arr, cmp) {
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < moonbitlang$core$array$$ArrayView$length$26$(arr)) {
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$26$(arr, j)) > 0) {
          moonbitlang$core$array$$ArrayView$swap$26$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$choose_pivot_by$25$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$25$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: cmp, _1: arr, _2: swaps };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$432(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$432(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$432(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$432(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$25$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$431(_env, a, b) {
  const swaps = _env._2;
  const arr = _env._1;
  const cmp = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$25$(arr, a), moonbitlang$core$array$$ArrayView$op_get$25$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$25$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$432(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$431(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$431(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$431(_env, a, b);
}
function moonbitlang$core$array$$choose_pivot_by$26$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$26$(arr);
  const swaps = { val: 0 };
  const b = Math.imul(len / 4 | 0, 2) | 0;
  if (len >= 8) {
    const a = Math.imul(len / 4 | 0, 1) | 0;
    const c = Math.imul(len / 4 | 0, 3) | 0;
    const _env = { _0: cmp, _1: arr, _2: swaps };
    if (len > 50) {
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$452(_env, a - 1 | 0, a, a + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$452(_env, b - 1 | 0, b, b + 1 | 0);
      moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$452(_env, c - 1 | 0, c, c + 1 | 0);
    }
    moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$452(_env, a, b, c);
  }
  if (swaps.val === 12) {
    moonbitlang$core$array$$ArrayView$rev_inplace$26$(arr);
    return { _0: (len - b | 0) - 1 | 0, _1: true };
  } else {
    return { _0: b, _1: swaps.val === 0 };
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$451(_env, a, b) {
  const swaps = _env._2;
  const arr = _env._1;
  const cmp = _env._0;
  if (cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, a), moonbitlang$core$array$$ArrayView$op_get$26$(arr, b)) > 0) {
    moonbitlang$core$array$$ArrayView$swap$26$(arr, a, b);
    swaps.val = swaps.val + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$array$$choose_pivot_by$46$sort_3$47$452(_env, a, b, c) {
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$451(_env, a, b);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$451(_env, b, c);
  moonbitlang$core$array$$choose_pivot_by$46$sort_2$47$451(_env, a, b);
}
function moonbitlang$core$array$$sift_down_by$25$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$25$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$25$(arr, child), moonbitlang$core$array$$ArrayView$op_get$25$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$25$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$25$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$25$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$sift_down_by$26$(arr, index, cmp) {
  let index$2 = index;
  const len = moonbitlang$core$array$$ArrayView$length$26$(arr);
  let child = (Math.imul(index$2, 2) | 0) + 1 | 0;
  while (true) {
    if (child < len) {
      if ((child + 1 | 0) < len && cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, child), moonbitlang$core$array$$ArrayView$op_get$26$(arr, child + 1 | 0)) < 0) {
        child = child + 1 | 0;
      }
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, index$2), moonbitlang$core$array$$ArrayView$op_get$26$(arr, child)) >= 0) {
        return undefined;
      }
      moonbitlang$core$array$$ArrayView$swap$26$(arr, index$2, child);
      index$2 = child;
      child = (Math.imul(index$2, 2) | 0) + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$25$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$25$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$25$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$25$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$25$(moonbitlang$core$array$$ArrayView$op_as_view$25$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$heap_sort_by$26$(arr, cmp) {
  const len = moonbitlang$core$array$$ArrayView$length$26$(arr);
  let _tmp = (len / 2 | 0) - 1 | 0;
  while (true) {
    const i = _tmp;
    if (i >= 0) {
      moonbitlang$core$array$$sift_down_by$26$(arr, i, cmp);
      _tmp = i - 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$2 = len - 1 | 0;
  while (true) {
    const i = _tmp$2;
    if (i > 0) {
      moonbitlang$core$array$$ArrayView$swap$26$(arr, 0, i);
      moonbitlang$core$array$$sift_down_by$26$(moonbitlang$core$array$$ArrayView$op_as_view$26$(arr, 0, i), 0, cmp);
      _tmp$2 = i - 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$partition_by$25$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$25$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$25$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$25$(arr, moonbitlang$core$array$$ArrayView$length$25$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < (moonbitlang$core$array$$ArrayView$length$25$(arr) - 1 | 0)) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$25$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$25$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$25$(arr, i, moonbitlang$core$array$$ArrayView$length$25$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$partition_by$26$(arr, cmp, pivot_index) {
  moonbitlang$core$array$$ArrayView$swap$26$(arr, pivot_index, moonbitlang$core$array$$ArrayView$length$26$(arr) - 1 | 0);
  const pivot = moonbitlang$core$array$$ArrayView$op_get$26$(arr, moonbitlang$core$array$$ArrayView$length$26$(arr) - 1 | 0);
  let i = 0;
  let partitioned = true;
  let _tmp = 0;
  while (true) {
    const j = _tmp;
    if (j < (moonbitlang$core$array$$ArrayView$length$26$(arr) - 1 | 0)) {
      if (cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, j), pivot) < 0) {
        if (i !== j) {
          moonbitlang$core$array$$ArrayView$swap$26$(arr, i, j);
          partitioned = false;
        }
        i = i + 1 | 0;
      }
      _tmp = j + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$array$$ArrayView$swap$26$(arr, i, moonbitlang$core$array$$ArrayView$length$26$(arr) - 1 | 0);
  return { _0: i, _1: partitioned };
}
function moonbitlang$core$array$$try_bubble_sort_by$25$(arr, cmp) {
  let tries = 0;
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < moonbitlang$core$array$$ArrayView$length$25$(arr)) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$25$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$25$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$25$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$try_bubble_sort_by$26$(arr, cmp) {
  let tries = 0;
  let _tmp = 1;
  while (true) {
    const i = _tmp;
    if (i < moonbitlang$core$array$$ArrayView$length$26$(arr)) {
      let sorted = true;
      let _tmp$2 = i;
      while (true) {
        const j = _tmp$2;
        if (j > 0 && cmp(moonbitlang$core$array$$ArrayView$op_get$26$(arr, j - 1 | 0), moonbitlang$core$array$$ArrayView$op_get$26$(arr, j)) > 0) {
          sorted = false;
          moonbitlang$core$array$$ArrayView$swap$26$(arr, j, j - 1 | 0);
          _tmp$2 = j - 1 | 0;
          continue;
        } else {
          break;
        }
      }
      if (!sorted) {
        tries = tries + 1 | 0;
        if (tries > 8) {
          return false;
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return true;
}
function moonbitlang$core$array$$quick_sort_by$25$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$25$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$25$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$25$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$25$(arr$2, cmp);
    const _x = _bind._0;
    const _x$2 = _bind._1;
    if (was_partitioned && (balanced && _x$2)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$25$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$25$(arr$2, cmp, _x);
    const _x$3 = _bind$2._0;
    const _x$4 = _bind$2._1;
    was_partitioned = _x$4;
    balanced = moonbitlang$core$array$$minimum(_x$3, len - _x$3 | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _x$5 = _Some;
      if (cmp(_x$5, moonbitlang$core$array$$ArrayView$op_get$25$(arr$2, _x$3)) === 0) {
        let i = _x$3;
        while (true) {
          if (i < len && cmp(_x$5, moonbitlang$core$array$$ArrayView$op_get$25$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$25$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$25$(arr$2, 0, _x$3);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$25$(arr$2, _x$3 + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$25$(left) < moonbitlang$core$array$$ArrayView$length$25$(right)) {
      moonbitlang$core$array$$quick_sort_by$25$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$25$(arr$2, _x$3);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$25$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$25$(arr$2, _x$3), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$quick_sort_by$26$(arr, cmp, pred, limit) {
  let limit$2 = limit;
  let arr$2 = arr;
  let pred$2 = pred;
  let was_partitioned = true;
  let balanced = true;
  while (true) {
    const len = moonbitlang$core$array$$ArrayView$length$26$(arr$2);
    if (len <= 16) {
      if (len >= 2) {
        moonbitlang$core$array$$bubble_sort_by$26$(arr$2, cmp);
      }
      return undefined;
    }
    if (limit$2 === 0) {
      moonbitlang$core$array$$heap_sort_by$26$(arr$2, cmp);
      return undefined;
    }
    const _bind = moonbitlang$core$array$$choose_pivot_by$26$(arr$2, cmp);
    const _x = _bind._0;
    const _x$2 = _bind._1;
    if (was_partitioned && (balanced && _x$2)) {
      if (moonbitlang$core$array$$try_bubble_sort_by$26$(arr$2, cmp)) {
        return undefined;
      }
    }
    const _bind$2 = moonbitlang$core$array$$partition_by$26$(arr$2, cmp, _x);
    const _x$3 = _bind$2._0;
    const _x$4 = _bind$2._1;
    was_partitioned = _x$4;
    balanced = moonbitlang$core$array$$minimum(_x$3, len - _x$3 | 0) >= (len / 8 | 0);
    if (!balanced) {
      limit$2 = limit$2 - 1 | 0;
    }
    const _bind$3 = pred$2;
    if (_bind$3 === undefined) {
    } else {
      const _Some = _bind$3;
      const _x$5 = _Some;
      if (cmp(_x$5, moonbitlang$core$array$$ArrayView$op_get$26$(arr$2, _x$3)) === 0) {
        let i = _x$3;
        while (true) {
          if (i < len && cmp(_x$5, moonbitlang$core$array$$ArrayView$op_get$26$(arr$2, i)) === 0) {
            i = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        arr$2 = moonbitlang$core$array$$ArrayView$op_as_view$26$(arr$2, i, len);
        continue;
      }
    }
    const left = moonbitlang$core$array$$ArrayView$op_as_view$26$(arr$2, 0, _x$3);
    const right = moonbitlang$core$array$$ArrayView$op_as_view$26$(arr$2, _x$3 + 1 | 0, len);
    if (moonbitlang$core$array$$ArrayView$length$26$(left) < moonbitlang$core$array$$ArrayView$length$26$(right)) {
      moonbitlang$core$array$$quick_sort_by$26$(left, cmp, pred$2, limit$2);
      pred$2 = moonbitlang$core$array$$ArrayView$op_get$26$(arr$2, _x$3);
      arr$2 = right;
    } else {
      moonbitlang$core$array$$quick_sort_by$26$(right, cmp, moonbitlang$core$array$$ArrayView$op_get$26$(arr$2, _x$3), limit$2);
      arr$2 = left;
    }
    continue;
  }
}
function moonbitlang$core$array$$Array$sort_by_key$30$(self, map) {
  moonbitlang$core$array$$quick_sort_by$25$({ buf: self, start: 0, len: self.length }, (a, b) => moonbitlang$core$builtin$$Compare$compare$31$(map(a), map(b)), undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$sort_by_key$32$(self, map) {
  moonbitlang$core$array$$quick_sort_by$26$({ buf: self, start: 0, len: self.length }, (a, b) => $compare_int(map(a), map(b)), undefined, moonbitlang$core$array$$get_limit(self.length));
}
function moonbitlang$core$array$$Array$push_iter$7$(self, iter) {
  iter((x) => {
    moonbitlang$core$array$$Array$push$7$(self, x);
    return 1;
  });
}
function moonbitlang$core$immut$sorted_set$$new$33$() {
  return $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$3$;
}
function moonbitlang$core$immut$sorted_set$$T$size$33$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Node = self;
    const _x = _Node._2;
    return _x;
  }
}
function moonbitlang$core$immut$sorted_set$$create$33$(left, value, right) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$3$(left, right, (moonbitlang$core$immut$sorted_set$$T$size$33$(left) + moonbitlang$core$immut$sorted_set$$T$size$33$(right) | 0) + 1 | 0, value);
}
function moonbitlang$core$immut$sorted_set$$balance$33$(left, value, right) {
  const left_size = moonbitlang$core$immut$sorted_set$$T$size$33$(left);
  const right_size = moonbitlang$core$immut$sorted_set$$T$size$33$(right);
  if ((left_size + right_size | 0) < 2) {
    return moonbitlang$core$immut$sorted_set$$create$33$(left, value, right);
  } else {
    if (left_size > (Math.imul(right_size, 5) | 0)) {
      if (left.$tag === 0) {
        return moonbitlang$core$builtin$$abort$34$("balance: left is empty.");
      } else {
        const _Node = left;
        const _x = _Node._0;
        const _x$2 = _Node._3;
        const _x$3 = _Node._1;
        if (moonbitlang$core$immut$sorted_set$$T$size$33$(_x) >= moonbitlang$core$immut$sorted_set$$T$size$33$(_x$3)) {
          return moonbitlang$core$immut$sorted_set$$create$33$(_x, _x$2, moonbitlang$core$immut$sorted_set$$create$33$(_x$3, value, right));
        } else {
          if (_x$3.$tag === 0) {
            return moonbitlang$core$builtin$$abort$34$("balance: right left.right is empty.");
          } else {
            const _Node$2 = _x$3;
            const _x$4 = _Node$2._0;
            const _x$5 = _Node$2._3;
            const _x$6 = _Node$2._1;
            return moonbitlang$core$immut$sorted_set$$create$33$(moonbitlang$core$immut$sorted_set$$create$33$(_x, _x$2, _x$4), _x$5, moonbitlang$core$immut$sorted_set$$create$33$(_x$6, value, right));
          }
        }
      }
    } else {
      if (right_size > (Math.imul(left_size, 5) | 0)) {
        if (right.$tag === 0) {
          return moonbitlang$core$builtin$$abort$34$("balance: right is empty");
        } else {
          const _Node = right;
          const _x = _Node._0;
          const _x$2 = _Node._3;
          const _x$3 = _Node._1;
          if (moonbitlang$core$immut$sorted_set$$T$size$33$(_x$3) >= moonbitlang$core$immut$sorted_set$$T$size$33$(_x)) {
            return moonbitlang$core$immut$sorted_set$$create$33$(moonbitlang$core$immut$sorted_set$$create$33$(left, value, _x), _x$2, _x$3);
          } else {
            if (_x.$tag === 0) {
              return moonbitlang$core$builtin$$abort$34$("balance: right.left is empty");
            } else {
              const _Node$2 = _x;
              const _x$4 = _Node$2._0;
              const _x$5 = _Node$2._3;
              const _x$6 = _Node$2._1;
              return moonbitlang$core$immut$sorted_set$$create$33$(moonbitlang$core$immut$sorted_set$$create$33$(left, value, _x$4), _x$5, moonbitlang$core$immut$sorted_set$$create$33$(_x$6, _x$2, _x$3));
            }
          }
        }
      } else {
        return moonbitlang$core$immut$sorted_set$$create$33$(left, value, right);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$add$33$(self, value) {
  if (self.$tag === 0) {
    return new $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Node$3$($64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$3$, $64$moonbitlang$47$core$47$immut$47$sorted_set$46$T$Empty$3$, 1, value);
  } else {
    const _Node = self;
    const _x = _Node._0;
    const _x$2 = _Node._1;
    const _x$3 = _Node._3;
    const compare_result = moonbitlang$core$builtin$$Compare$compare$33$(value, _x$3);
    if (compare_result === 0) {
      return self;
    } else {
      if (compare_result < 0) {
        const ll = moonbitlang$core$immut$sorted_set$$T$add$33$(_x, value);
        return _x === ll ? self : moonbitlang$core$immut$sorted_set$$balance$33$(ll, _x$3, _x$2);
      } else {
        const rr = moonbitlang$core$immut$sorted_set$$T$add$33$(_x$2, value);
        return _x$2 === rr ? self : moonbitlang$core$immut$sorted_set$$balance$33$(_x, _x$3, rr);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_set$$T$iter$33$(self) {
  return moonbitlang$core$builtin$$Iter$new$33$((yield_) => {
    if (self.$tag === 0) {
      return 1;
    } else {
      const _Node = self;
      const _x = _Node._0;
      const _x$2 = _Node._1;
      const _x$3 = _Node._3;
      return moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter$run$33$(moonbitlang$core$immut$sorted_set$$T$iter$33$(_x), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x$3), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter$run$33$(moonbitlang$core$immut$sorted_set$$T$iter$33$(_x$2), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$immut$internal$sparse_array$$Bitset$has(self, idx) {
  return (self & 1 << idx) !== 0;
}
function moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self, idx) {
  return $i32_popcnt(self & ((1 << idx >>> 0) - (1 >>> 0) | 0));
}
function moonbitlang$core$immut$internal$sparse_array$$Bitset$add(self, idx) {
  return self | 1 << idx;
}
function moonbitlang$core$immut$internal$sparse_array$$singleton$27$(idx, value) {
  return { elem_info: moonbitlang$core$immut$internal$sparse_array$$Bitset$add(moonbitlang$core$immut$internal$sparse_array$$empty_bitset, idx), data: [value] };
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$op_get$27$(self, idx) {
  return moonbitlang$core$immut$internal$sparse_array$$Bitset$has(self.elem_info, idx) ? self.data[moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self.elem_info, idx)] : undefined;
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$add$27$(self, idx, value) {
  const old_data = self.data;
  const old_len = old_data.length;
  const new_len = old_len + 1 | 0;
  const pos_of_new_item = moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self.elem_info, idx);
  const new_data = $make_array_len_and_init(new_len, value);
  moonbitlang$core$array$$FixedArray$blit_to$27$(old_data, new_data, pos_of_new_item, moonbitlang$core$array$$FixedArray$blit_to$46$src_offset$46$default$27$(), moonbitlang$core$array$$FixedArray$blit_to$46$dst_offset$46$default$27$());
  moonbitlang$core$array$$FixedArray$blit_to$27$(old_data, new_data, old_len - pos_of_new_item | 0, pos_of_new_item, pos_of_new_item + 1 | 0);
  return { elem_info: moonbitlang$core$immut$internal$sparse_array$$Bitset$add(self.elem_info, idx), data: new_data };
}
function moonbitlang$core$immut$internal$sparse_array$$SparseArray$replace$27$(self, idx, value) {
  const new_data = moonbitlang$core$array$$FixedArray$copy$27$(self.data);
  new_data[moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(self.elem_info, idx)] = value;
  return { elem_info: self.elem_info, data: new_data };
}
function moonbitlang$core$immut$hashmap$$new$35$() {
  return $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Empty$4$;
}
function moonbitlang$core$immut$hashmap$$Bucket$find$35$(self, key) {
  let _tmp = self;
  let _tmp$2 = key;
  while (true) {
    const self$2 = _tmp;
    const key$2 = _tmp$2;
    if (self$2.$tag === 0) {
      const _Just_One = self$2;
      const _x = _Just_One._0;
      const _x$2 = _Just_One._1;
      return moonbitlang$core$builtin$$Eq$op_equal$36$(key$2, _x) ? _x$2 : undefined;
    } else {
      const _More = self$2;
      const _x = _More._0;
      const _x$2 = _More._1;
      const _x$3 = _More._2;
      if (moonbitlang$core$builtin$$Eq$op_equal$36$(key$2, _x)) {
        return _x$2;
      } else {
        _tmp = _x$3;
        continue;
      }
    }
  }
}
function moonbitlang$core$immut$hashmap$$T$find$35$(self, key) {
  let _tmp = self;
  let _tmp$2 = moonbitlang$core$builtin$$Hash$hash$37$(key);
  _L: while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    switch (_param.$tag) {
      case 0: {
        return undefined;
      }
      case 1: {
        const _Leaf = _param;
        const _x = _Leaf._0;
        const _x$2 = _Leaf._1;
        return moonbitlang$core$builtin$$Eq$op_equal$36$(key, _x) ? _x$2 : undefined;
      }
      case 2: {
        const _Collision = _param;
        const _x$3 = _Collision._0;
        return moonbitlang$core$immut$hashmap$$Bucket$find$35$(_x$3, key);
      }
      default: {
        const _Branch = _param;
        const _x$4 = _Branch._0;
        const idx = _param$2 & 31;
        if (moonbitlang$core$immut$internal$sparse_array$$Bitset$has(_x$4.elem_info, idx)) {
          const child = _x$4.data[moonbitlang$core$immut$internal$sparse_array$$Bitset$index_of(_x$4.elem_info, idx)];
          const _tmp$3 = _param$2 >>> 5 | 0;
          _tmp = child;
          _tmp$2 = _tmp$3;
          continue _L;
        }
        return undefined;
      }
    }
  }
}
function moonbitlang$core$immut$hashmap$$T$op_get$35$(self, key) {
  return moonbitlang$core$immut$hashmap$$T$find$35$(self, key);
}
function moonbitlang$core$immut$hashmap$$Bucket$add$35$(self, key, value) {
  if (self.$tag === 0) {
    const _Just_One = self;
    const _x = _Just_One._0;
    return moonbitlang$core$builtin$$Eq$op_equal$36$(key, _x) ? new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$4$(key, value) : new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$4$(key, value, self);
  } else {
    const _More = self;
    const _x = _More._0;
    const _x$2 = _More._1;
    const _x$3 = _More._2;
    return moonbitlang$core$builtin$$Eq$op_equal$36$(key, _x) ? new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$4$(key, value, _x$3) : new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$4$(_x, _x$2, moonbitlang$core$immut$hashmap$$Bucket$add$35$(_x$3, key, value));
  }
}
function moonbitlang$core$immut$hashmap$$T$add_with_hash$35$(self, key, depth, hash, value) {
  switch (self.$tag) {
    case 0: {
      return moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$691(depth, key, hash, value);
    }
    case 1: {
      const _Leaf = self;
      const _x = _Leaf._0;
      const _x$2 = _Leaf._1;
      return moonbitlang$core$builtin$$Eq$op_equal$36$(key, _x) ? new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$4$(key, value) : new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$4$(new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$More$4$(key, value, new $64$moonbitlang$47$core$47$immut$47$hashmap$46$Bucket$Just_One$4$(_x, _x$2)));
    }
    case 2: {
      const _Collision = self;
      const _x$3 = _Collision._0;
      return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Collision$4$(moonbitlang$core$immut$hashmap$$Bucket$add$35$(_x$3, key, value));
    }
    default: {
      const _Branch = self;
      const _x$4 = _Branch._0;
      const idx = hash & 31;
      const _bind = moonbitlang$core$immut$internal$sparse_array$$SparseArray$op_get$27$(_x$4, idx);
      if (_bind === undefined) {
        const child = moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$691(depth + 5 | 0, key, hash >>> 5 | 0, value);
        return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$4$(moonbitlang$core$immut$internal$sparse_array$$SparseArray$add$27$(_x$4, idx, child));
      } else {
        const _Some = _bind;
        const _x$5 = _Some;
        const child = moonbitlang$core$immut$hashmap$$T$add_with_hash$35$(_x$5, key, depth + 5 | 0, hash >>> 5 | 0, value);
        return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$4$(moonbitlang$core$immut$internal$sparse_array$$SparseArray$replace$27$(_x$4, idx, child));
      }
    }
  }
}
function moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$691(depth, key, hash, value) {
  if (depth >= 32) {
    return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Leaf$4$(key, value);
  } else {
    const idx = hash & 31;
    const child = moonbitlang$core$immut$hashmap$$add_with_hash$46$make_leaf$47$691(depth + 5 | 0, key, hash >>> 5 | 0, value);
    return new $64$moonbitlang$47$core$47$immut$47$hashmap$46$T$Branch$4$(moonbitlang$core$immut$internal$sparse_array$$singleton$27$(idx, child));
  }
}
function moonbitlang$core$immut$hashmap$$T$add$35$(self, key, value) {
  return moonbitlang$core$immut$hashmap$$T$add_with_hash$35$(self, key, 0, moonbitlang$core$builtin$$Hash$hash$37$(key), value);
}
function moonbitlang$core$immut$sorted_map$$T$size$38$(self) {
  if (self.$tag === 0) {
    return 0;
  } else {
    const _Tree = self;
    return _Tree._2;
  }
}
function moonbitlang$core$immut$sorted_map$$make_tree$38$(key, value, l, r) {
  const size = (moonbitlang$core$immut$sorted_map$$T$size$38$(l) + moonbitlang$core$immut$sorted_map$$T$size$38$(r) | 0) + 1 | 0;
  return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$5$(key, value, size, l, r);
}
function moonbitlang$core$immut$sorted_map$$balance$38$(key, value, l, r) {
  const ln = moonbitlang$core$immut$sorted_map$$T$size$38$(l);
  const rn = moonbitlang$core$immut$sorted_map$$T$size$38$(r);
  if ((ln + rn | 0) < 2) {
    return moonbitlang$core$immut$sorted_map$$make_tree$38$(key, value, l, r);
  } else {
    if (rn > (Math.imul(5, ln) | 0)) {
      if (r.$tag === 1) {
        const _Tree = r;
        const _x = _Tree._3;
        const _x$2 = _Tree._4;
        const rln = moonbitlang$core$immut$sorted_map$$T$size$38$(_x);
        const rrn = moonbitlang$core$immut$sorted_map$$T$size$38$(_x$2);
        if (rln < rrn) {
          if (r.$tag === 1) {
            const _Tree$2 = r;
            const _x$3 = _Tree$2._0;
            const _x$4 = _Tree$2._1;
            const _x$5 = _Tree$2._3;
            const _x$6 = _Tree$2._4;
            return moonbitlang$core$immut$sorted_map$$make_tree$38$(_x$3, _x$4, moonbitlang$core$immut$sorted_map$$make_tree$38$(key, value, l, _x$5), _x$6);
          } else {
            return $panic();
          }
        } else {
          if (r.$tag === 1) {
            const _Tree$2 = r;
            const _x$3 = _Tree$2._0;
            const _x$4 = _Tree$2._1;
            const _x$5 = _Tree$2._3;
            if (_x$5.$tag === 1) {
              const _Tree$3 = _x$5;
              const _x$6 = _Tree$3._0;
              const _x$7 = _Tree$3._1;
              const _x$8 = _Tree$3._3;
              const _x$9 = _Tree$3._4;
              const _x$10 = _Tree$2._4;
              return moonbitlang$core$immut$sorted_map$$make_tree$38$(_x$6, _x$7, moonbitlang$core$immut$sorted_map$$make_tree$38$(key, value, l, _x$8), moonbitlang$core$immut$sorted_map$$make_tree$38$(_x$3, _x$4, _x$9, _x$10));
            } else {
              return $panic();
            }
          } else {
            return $panic();
          }
        }
      } else {
        return $panic();
      }
    } else {
      if (ln > (Math.imul(5, rn) | 0)) {
        if (l.$tag === 1) {
          const _Tree = l;
          const _x = _Tree._3;
          const _x$2 = _Tree._4;
          const lln = moonbitlang$core$immut$sorted_map$$T$size$38$(_x);
          const lrn = moonbitlang$core$immut$sorted_map$$T$size$38$(_x$2);
          if (lrn < lln) {
            if (l.$tag === 1) {
              const _Tree$2 = l;
              const _x$3 = _Tree$2._0;
              const _x$4 = _Tree$2._1;
              const _x$5 = _Tree$2._3;
              const _x$6 = _Tree$2._4;
              return moonbitlang$core$immut$sorted_map$$make_tree$38$(_x$3, _x$4, _x$5, moonbitlang$core$immut$sorted_map$$make_tree$38$(key, value, _x$6, r));
            } else {
              return $panic();
            }
          } else {
            if (l.$tag === 1) {
              const _Tree$2 = l;
              const _x$3 = _Tree$2._0;
              const _x$4 = _Tree$2._1;
              const _x$5 = _Tree$2._3;
              const _x$6 = _Tree$2._4;
              if (_x$6.$tag === 1) {
                const _Tree$3 = _x$6;
                const _x$7 = _Tree$3._0;
                const _x$8 = _Tree$3._1;
                const _x$9 = _Tree$3._3;
                const _x$10 = _Tree$3._4;
                return moonbitlang$core$immut$sorted_map$$make_tree$38$(_x$7, _x$8, moonbitlang$core$immut$sorted_map$$make_tree$38$(_x$3, _x$4, _x$5, _x$9), moonbitlang$core$immut$sorted_map$$make_tree$38$(key, value, _x$10, r));
              } else {
                return $panic();
              }
            } else {
              return $panic();
            }
          }
        } else {
          return $panic();
        }
      } else {
        return moonbitlang$core$immut$sorted_map$$make_tree$38$(key, value, l, r);
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$singleton$38$(key, value) {
  return new $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Tree$5$(key, value, 1, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$5$, $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$5$);
}
function moonbitlang$core$immut$sorted_map$$T$add$38$(self, key, value) {
  if (self.$tag === 0) {
    return moonbitlang$core$immut$sorted_map$$singleton$38$(key, value);
  } else {
    const _Tree = self;
    const _x = _Tree._0;
    const _x$2 = _Tree._1;
    const _x$3 = _Tree._3;
    const _x$4 = _Tree._4;
    const c = $compare_int(key, _x);
    return c === 0 ? moonbitlang$core$immut$sorted_map$$make_tree$38$(_x, value, _x$3, _x$4) : c < 0 ? moonbitlang$core$immut$sorted_map$$balance$38$(_x, _x$2, moonbitlang$core$immut$sorted_map$$T$add$38$(_x$3, key, value), _x$4) : moonbitlang$core$immut$sorted_map$$balance$38$(_x, _x$2, _x$3, moonbitlang$core$immut$sorted_map$$T$add$38$(_x$4, key, value));
  }
}
function moonbitlang$core$immut$sorted_map$$new$38$() {
  return $64$moonbitlang$47$core$47$immut$47$sorted_map$46$T$Empty$5$;
}
function moonbitlang$core$immut$sorted_map$$T$lookup$38$(self, key) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (_param.$tag === 0) {
      return undefined;
    } else {
      const _Tree = _param;
      const _x = _Tree._0;
      const _x$2 = _Tree._1;
      const _x$3 = _Tree._3;
      const _x$4 = _Tree._4;
      const c = $compare_int(key, _x);
      if (c === 0) {
        return _x$2;
      } else {
        if (c < 0) {
          _tmp = _x$3;
          continue;
        } else {
          _tmp = _x$4;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$immut$sorted_map$$T$op_get$38$(self, key) {
  return moonbitlang$core$immut$sorted_map$$T$lookup$38$(self, key);
}
function moonbitlang$core$sorted_map$$new_node$39$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$sorted_map$$new_node$40$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$sorted_map$$new_node$41$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$sorted_map$$new_node$42$(key, value) {
  return { key: key, value: value, left: undefined, right: undefined, height: 1 };
}
function moonbitlang$core$sorted_map$$Node$op_equal$39$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$43$(self.key, other.key);
}
function moonbitlang$core$sorted_map$$Node$op_equal$41$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$44$(self.key, other.key);
}
function moonbitlang$core$sorted_map$$Node$op_equal$40$(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$45$(self.key, other.key);
}
function moonbitlang$core$sorted_map$$Node$op_equal$42$(self, other) {
  return self.key === other.key;
}
function moonbitlang$core$sorted_map$$max(x, y) {
  return x > y ? x : y;
}
function moonbitlang$core$sorted_map$$height$39$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_map$$height$41$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_map$$height$40$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_map$$height$42$(node) {
  if (node === undefined) {
    return 0;
  } else {
    const _Some = node;
    const _x = _Some;
    return _x.height;
  }
}
function moonbitlang$core$sorted_map$$new$41$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$new$40$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$new$39$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$new$42$() {
  return { root: undefined, size: 0 };
}
function moonbitlang$core$sorted_map$$height_ge$39$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_map$$height_ge$41$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_map$$height_ge$40$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_map$$height_ge$42$(x1, x2) {
  if (x2 === undefined) {
    return true;
  } else {
    const _Some = x2;
    const _x = _Some;
    if (x1 === undefined) {
      return false;
    } else {
      const _Some$2 = x1;
      const _x$2 = _Some$2;
      return _x$2.height >= _x.height;
    }
  }
}
function moonbitlang$core$sorted_map$$Node$update_height$39$(self) {
  self.height = 1 + moonbitlang$core$sorted_map$$max(moonbitlang$core$sorted_map$$height$39$(self.left), moonbitlang$core$sorted_map$$height$39$(self.right)) | 0;
}
function moonbitlang$core$sorted_map$$Node$update_height$41$(self) {
  self.height = 1 + moonbitlang$core$sorted_map$$max(moonbitlang$core$sorted_map$$height$41$(self.left), moonbitlang$core$sorted_map$$height$41$(self.right)) | 0;
}
function moonbitlang$core$sorted_map$$Node$update_height$40$(self) {
  self.height = 1 + moonbitlang$core$sorted_map$$max(moonbitlang$core$sorted_map$$height$40$(self.left), moonbitlang$core$sorted_map$$height$40$(self.right)) | 0;
}
function moonbitlang$core$sorted_map$$Node$update_height$42$(self) {
  self.height = 1 + moonbitlang$core$sorted_map$$max(moonbitlang$core$sorted_map$$height$42$(self.left), moonbitlang$core$sorted_map$$height$42$(self.right)) | 0;
}
function moonbitlang$core$sorted_map$$rotate_l$39$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$46$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$39$(n);
  moonbitlang$core$sorted_map$$Node$update_height$39$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_l$41$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$47$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$41$(n);
  moonbitlang$core$sorted_map$$Node$update_height$41$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_l$40$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$48$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$40$(n);
  moonbitlang$core$sorted_map$$Node$update_height$40$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_l$42$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$49$(n.right);
  n.right = r.left;
  r.left = n;
  moonbitlang$core$sorted_map$$Node$update_height$42$(n);
  moonbitlang$core$sorted_map$$Node$update_height$42$(r);
  return r;
}
function moonbitlang$core$sorted_map$$rotate_r$39$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$46$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$39$(n);
  moonbitlang$core$sorted_map$$Node$update_height$39$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_r$41$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$47$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$41$(n);
  moonbitlang$core$sorted_map$$Node$update_height$41$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_r$40$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$48$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$40$(n);
  moonbitlang$core$sorted_map$$Node$update_height$40$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_r$42$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$49$(n.left);
  n.left = l.right;
  l.right = n;
  moonbitlang$core$sorted_map$$Node$update_height$42$(n);
  moonbitlang$core$sorted_map$$Node$update_height$42$(l);
  return l;
}
function moonbitlang$core$sorted_map$$rotate_lr$39$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$46$(n.left);
  const v = moonbitlang$core$sorted_map$$rotate_l$39$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$39$(n);
}
function moonbitlang$core$sorted_map$$rotate_lr$41$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$47$(n.left);
  const v = moonbitlang$core$sorted_map$$rotate_l$41$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$41$(n);
}
function moonbitlang$core$sorted_map$$rotate_lr$40$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$48$(n.left);
  const v = moonbitlang$core$sorted_map$$rotate_l$40$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$40$(n);
}
function moonbitlang$core$sorted_map$$rotate_lr$42$(n) {
  const l = moonbitlang$core$option$$Option$unwrap$49$(n.left);
  const v = moonbitlang$core$sorted_map$$rotate_l$42$(l);
  n.left = v;
  return moonbitlang$core$sorted_map$$rotate_r$42$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$39$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$46$(n.right);
  const v = moonbitlang$core$sorted_map$$rotate_r$39$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$39$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$41$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$47$(n.right);
  const v = moonbitlang$core$sorted_map$$rotate_r$41$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$41$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$40$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$48$(n.right);
  const v = moonbitlang$core$sorted_map$$rotate_r$40$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$40$(n);
}
function moonbitlang$core$sorted_map$$rotate_rl$42$(n) {
  const r = moonbitlang$core$option$$Option$unwrap$49$(n.right);
  const v = moonbitlang$core$sorted_map$$rotate_r$42$(r);
  n.right = v;
  return moonbitlang$core$sorted_map$$rotate_l$42$(n);
}
function moonbitlang$core$sorted_map$$balance$39$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_map$$height$39$(l);
  const hr = moonbitlang$core$sorted_map$$height$39$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$46$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$39$(_x, _x$2) ? moonbitlang$core$sorted_map$$rotate_r$39$(root) : moonbitlang$core$sorted_map$$rotate_lr$39$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$46$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$39$(_x$2, _x) ? moonbitlang$core$sorted_map$$rotate_l$39$(root) : moonbitlang$core$sorted_map$$rotate_rl$39$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$39$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$balance$40$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_map$$height$40$(l);
  const hr = moonbitlang$core$sorted_map$$height$40$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$48$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$40$(_x, _x$2) ? moonbitlang$core$sorted_map$$rotate_r$40$(root) : moonbitlang$core$sorted_map$$rotate_lr$40$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$48$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$40$(_x$2, _x) ? moonbitlang$core$sorted_map$$rotate_l$40$(root) : moonbitlang$core$sorted_map$$rotate_rl$40$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$40$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$balance$41$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_map$$height$41$(l);
  const hr = moonbitlang$core$sorted_map$$height$41$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$47$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$41$(_x, _x$2) ? moonbitlang$core$sorted_map$$rotate_r$41$(root) : moonbitlang$core$sorted_map$$rotate_lr$41$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$47$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$41$(_x$2, _x) ? moonbitlang$core$sorted_map$$rotate_l$41$(root) : moonbitlang$core$sorted_map$$rotate_rl$41$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$41$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$balance$42$(root) {
  const l = root.left;
  const r = root.right;
  const hl = moonbitlang$core$sorted_map$$height$42$(l);
  const hr = moonbitlang$core$sorted_map$$height$42$(r);
  let new_root;
  if (hl > (hr + 1 | 0)) {
    const _bind = moonbitlang$core$option$$Option$unwrap$49$(l);
    const _x = _bind.left;
    const _x$2 = _bind.right;
    new_root = moonbitlang$core$sorted_map$$height_ge$42$(_x, _x$2) ? moonbitlang$core$sorted_map$$rotate_r$42$(root) : moonbitlang$core$sorted_map$$rotate_lr$42$(root);
  } else {
    if (hr > (hl + 1 | 0)) {
      const _bind = moonbitlang$core$option$$Option$unwrap$49$(r);
      const _x = _bind.left;
      const _x$2 = _bind.right;
      new_root = moonbitlang$core$sorted_map$$height_ge$42$(_x$2, _x) ? moonbitlang$core$sorted_map$$rotate_l$42$(root) : moonbitlang$core$sorted_map$$rotate_rl$42$(root);
    } else {
      new_root = root;
    }
  }
  moonbitlang$core$sorted_map$$Node$update_height$42$(new_root);
  return new_root;
}
function moonbitlang$core$sorted_map$$add_node$39$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$39$(key, value), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    if (moonbitlang$core$builtin$$Eq$op_equal$43$(key, _x.key)) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (moonbitlang$core$builtin$$op_lt$43$(key, _x.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$39$(l, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$39$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$39$(r, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$39$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$add_node$41$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$41$(key, value), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    if (moonbitlang$core$builtin$$Eq$op_equal$44$(key, _x.key)) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (moonbitlang$core$builtin$$op_lt$44$(key, _x.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$41$(l, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$41$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$41$(r, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$41$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$add_node$40$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$40$(key, value), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    if (moonbitlang$core$builtin$$Eq$op_equal$45$(key, _x.key)) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (moonbitlang$core$builtin$$op_lt$45$(key, _x.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$40$(l, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$40$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$40$(r, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$40$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$add_node$42$(root, key, value) {
  if (root === undefined) {
    return { _0: moonbitlang$core$sorted_map$$new_node$42$(key, value), _1: true };
  } else {
    const _Some = root;
    const _x = _Some;
    if (key === _x.key) {
      _x.value = value;
      return { _0: _x, _1: false };
    } else {
      const l = _x.left;
      const r = _x.right;
      if (moonbitlang$core$builtin$$op_lt$7$(key, _x.key)) {
        const _bind = moonbitlang$core$sorted_map$$add_node$42$(l, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.left = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$42$(_x), _1: _x$3 };
      } else {
        const _bind = moonbitlang$core$sorted_map$$add_node$42$(r, key, value);
        const _x$2 = _bind._0;
        const _x$3 = _bind._1;
        _x.right = _x$2;
        return { _0: moonbitlang$core$sorted_map$$balance$42$(_x), _1: _x$3 };
      }
    }
  }
}
function moonbitlang$core$sorted_map$$T$add$39$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$39$(self.root, key, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$50$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$T$add$40$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$40$(self.root, key, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$51$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$T$add$41$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$41$(self.root, key, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$52$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$T$add$42$(self, key, value) {
  const _bind = moonbitlang$core$sorted_map$$add_node$42$(self.root, key, value);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  if (moonbitlang$core$builtin$$op_notequal$53$(self.root, _x)) {
    self.root = _x;
  }
  if (_x$2) {
    self.size = self.size + 1 | 0;
    return;
  } else {
    return;
  }
}
function moonbitlang$core$sorted_map$$T$op_set$39$(self, key, value) {
  moonbitlang$core$sorted_map$$T$add$39$(self, key, value);
}
function moonbitlang$core$sorted_map$$T$op_set$41$(self, key, value) {
  moonbitlang$core$sorted_map$$T$add$41$(self, key, value);
}
function moonbitlang$core$sorted_map$$T$op_set$40$(self, key, value) {
  moonbitlang$core$sorted_map$$T$add$40$(self, key, value);
}
function moonbitlang$core$sorted_map$$T$op_set$42$(self, key, value) {
  moonbitlang$core$sorted_map$$T$add$42$(self, key, value);
}
function moonbitlang$core$sorted_map$$T$get$39$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _x = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$43$(key, _x.key);
      if (cmp === 0) {
        return _x.value;
      } else {
        if (cmp > 0) {
          _tmp = _x.right;
          continue;
        } else {
          _tmp = _x.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$T$get$41$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _x = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$44$(key, _x.key);
      if (cmp === 0) {
        return _x.value;
      } else {
        if (cmp > 0) {
          _tmp = _x.right;
          continue;
        } else {
          _tmp = _x.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$T$get$40$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _x = _Some;
      const cmp = moonbitlang$core$builtin$$Compare$compare$45$(key, _x.key);
      if (cmp === 0) {
        return _x.value;
      } else {
        if (cmp > 0) {
          _tmp = _x.right;
          continue;
        } else {
          _tmp = _x.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$T$get$42$(self, key) {
  let _tmp = self.root;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return undefined;
    } else {
      const _Some = _param;
      const _x = _Some;
      const cmp = moonbitlang$core$string$$String$compare(key, _x.key);
      if (cmp === 0) {
        return _x.value;
      } else {
        if (cmp > 0) {
          _tmp = _x.right;
          continue;
        } else {
          _tmp = _x.left;
          continue;
        }
      }
    }
  }
}
function moonbitlang$core$sorted_map$$T$op_get$41$(self, key) {
  return moonbitlang$core$sorted_map$$T$get$41$(self, key);
}
function moonbitlang$core$sorted_map$$T$op_get$39$(self, key) {
  return moonbitlang$core$sorted_map$$T$get$39$(self, key);
}
function moonbitlang$core$sorted_map$$T$op_get$40$(self, key) {
  return moonbitlang$core$sorted_map$$T$get$40$(self, key);
}
function moonbitlang$core$sorted_map$$T$op_get$42$(self, key) {
  return moonbitlang$core$sorted_map$$T$get$42$(self, key);
}
function moonbitlang$core$sorted_map$$T$each$39$(self, f) {
  const s = [];
  let p = self.root;
  while (true) {
    if (!moonbitlang$core$option$$Option$is_empty$46$(p) || !moonbitlang$core$array$$Array$is_empty$50$(s)) {
      while (true) {
        if (!moonbitlang$core$option$$Option$is_empty$46$(p)) {
          moonbitlang$core$array$$Array$push$50$(s, p);
          p = moonbitlang$core$option$$Option$unwrap$46$(p).left;
          continue;
        } else {
          break;
        }
      }
      if (!moonbitlang$core$array$$Array$is_empty$50$(s)) {
        p = moonbitlang$core$array$$Array$unsafe_pop$50$(s);
        f(moonbitlang$core$option$$Option$unwrap$46$(p).key, moonbitlang$core$option$$Option$unwrap$46$(p).value);
        p = moonbitlang$core$option$$Option$unwrap$46$(p).right;
      }
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$sorted_map$$T$size$39$(self) {
  return self.size;
}
function moonbitlang$core$sorted_map$$T$keys$39$(self) {
  const keys = [];
  moonbitlang$core$sorted_map$$T$each$39$(self, (k, _v) => {
    moonbitlang$core$array$$Array$push$43$(keys, k);
  });
  return keys;
}
function moonbitlang$core$sorted_map$$iter_aux2$41$(node) {
  return moonbitlang$core$builtin$$Iter2$new$41$((yield_) => {
    if (node === undefined) {
      return 1;
    } else {
      const _Some = node;
      const _x = _Some;
      return moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter2$run$41$(moonbitlang$core$sorted_map$$iter_aux2$41$(_x.left), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x.key, _x.value), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter2$run$41$(moonbitlang$core$sorted_map$$iter_aux2$41$(_x.right), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$sorted_map$$iter_aux2$40$(node) {
  return moonbitlang$core$builtin$$Iter2$new$40$((yield_) => {
    if (node === undefined) {
      return 1;
    } else {
      const _Some = node;
      const _x = _Some;
      return moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter2$run$40$(moonbitlang$core$sorted_map$$iter_aux2$40$(_x.left), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x.key, _x.value), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter2$run$40$(moonbitlang$core$sorted_map$$iter_aux2$40$(_x.right), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$sorted_map$$iter_aux2$39$(node) {
  return moonbitlang$core$builtin$$Iter2$new$39$((yield_) => {
    if (node === undefined) {
      return 1;
    } else {
      const _Some = node;
      const _x = _Some;
      return moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter2$run$39$(moonbitlang$core$sorted_map$$iter_aux2$39$(_x.left), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x.key, _x.value), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter2$run$39$(moonbitlang$core$sorted_map$$iter_aux2$39$(_x.right), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$sorted_map$$iter_aux2$42$(node) {
  return moonbitlang$core$builtin$$Iter2$new$42$((yield_) => {
    if (node === undefined) {
      return 1;
    } else {
      const _Some = node;
      const _x = _Some;
      return moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter2$run$42$(moonbitlang$core$sorted_map$$iter_aux2$42$(_x.left), yield_), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x.key, _x.value), 0) ? 0 : moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter2$run$42$(moonbitlang$core$sorted_map$$iter_aux2$42$(_x.right), yield_), 0) ? 0 : 1;
    }
  });
}
function moonbitlang$core$sorted_map$$T$iter2$39$(self) {
  return moonbitlang$core$sorted_map$$iter_aux2$39$(self.root);
}
function moonbitlang$core$sorted_map$$T$iter2$40$(self) {
  return moonbitlang$core$sorted_map$$iter_aux2$40$(self.root);
}
function moonbitlang$core$sorted_map$$T$iter2$41$(self) {
  return moonbitlang$core$sorted_map$$iter_aux2$41$(self.root);
}
function moonbitlang$core$sorted_map$$T$iter2$42$(self) {
  return moonbitlang$core$sorted_map$$iter_aux2$42$(self.root);
}
function moonbitlang$core$builtin$$Eq$op_equal$54$(_x_371, _x_372) {
  let _tmp = _x_371;
  let _tmp$2 = _x_372;
  while (true) {
    const _x_371$2 = _tmp;
    const _x_372$2 = _tmp$2;
    if (_x_371$2.$tag === 0) {
      if (_x_372$2.$tag === 0) {
        return true;
      } else {
        return false;
      }
    } else {
      const _Cons = _x_371$2;
      const _x = _Cons._0;
      const _x$2 = _Cons._1;
      if (_x_372$2.$tag === 1) {
        const _Cons$2 = _x_372$2;
        const _x$3 = _Cons$2._0;
        const _x$4 = _Cons$2._1;
        if (moonbitlang$core$builtin$$Eq$op_equal$55$(_x, _x$3)) {
          _tmp = _x$2;
          _tmp$2 = _x$4;
          continue;
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$immut$list$$T$iter$56$(self) {
  return moonbitlang$core$builtin$$Iter$new$56$((yield_) => {
    let _tmp = self;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        return 1;
      } else {
        const _Cons = _param;
        const _x = _Cons._0;
        const _x$2 = _Cons._1;
        if (moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x), 0)) {
          return 0;
        }
        _tmp = _x$2;
        continue;
      }
    }
  });
}
function moonbitlang$core$immut$list$$T$iter$55$(self) {
  return moonbitlang$core$builtin$$Iter$new$55$((yield_) => {
    let _tmp = self;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        return 1;
      } else {
        const _Cons = _param;
        const _x = _Cons._0;
        const _x$2 = _Cons._1;
        if (moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x), 0)) {
          return 0;
        }
        _tmp = _x$2;
        continue;
      }
    }
  });
}
function moonbitlang$core$immut$list$$T$to_array$57$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _x$2 = _Cons._1;
    const arr = [_x];
    let _tmp = _x$2;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$3 = _Cons$2._0;
        const _x$4 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$57$(arr, _x$3);
        _tmp = _x$4;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$immut$list$$T$to_array$58$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _x$2 = _Cons._1;
    const arr = [_x];
    let _tmp = _x$2;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$3 = _Cons$2._0;
        const _x$4 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$58$(arr, _x$3);
        _tmp = _x$4;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$immut$list$$T$to_array$59$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _x$2 = _Cons._1;
    const arr = [_x];
    let _tmp = _x$2;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$3 = _Cons$2._0;
        const _x$4 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$59$(arr, _x$3);
        _tmp = _x$4;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$immut$list$$T$to_array$60$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _x$2 = _Cons._1;
    const arr = [_x];
    let _tmp = _x$2;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$3 = _Cons$2._0;
        const _x$4 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$60$(arr, _x$3);
        _tmp = _x$4;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$immut$list$$T$to_array$7$(self) {
  if (self.$tag === 0) {
    return [];
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    const _x$2 = _Cons._1;
    const arr = [_x];
    let _tmp = _x$2;
    while (true) {
      const _param = _tmp;
      if (_param.$tag === 0) {
        break;
      } else {
        const _Cons$2 = _param;
        const _x$3 = _Cons$2._0;
        const _x$4 = _Cons$2._1;
        moonbitlang$core$array$$Array$push$7$(arr, _x$3);
        _tmp = _x$4;
        continue;
      }
    }
    return arr;
  }
}
function moonbitlang$core$immut$list$$T$tail$61$(self) {
  if (self.$tag === 0) {
    return $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$6$;
  } else {
    const _Cons = self;
    const _x = _Cons._1;
    return _x;
  }
}
function moonbitlang$core$immut$list$$T$unsafe_head$61$(self) {
  if (self.$tag === 0) {
    return moonbitlang$core$builtin$$abort$61$("head of empty list");
  } else {
    const _Cons = self;
    const _x = _Cons._0;
    return _x;
  }
}
function moonbitlang$core$immut$list$$T$contains$55$(self, value) {
  let _tmp = self;
  while (true) {
    const _param = _tmp;
    if (_param.$tag === 0) {
      return false;
    } else {
      const _Cons = _param;
      const _x = _Cons._0;
      const _x$2 = _Cons._1;
      if (moonbitlang$core$builtin$$Eq$op_equal$55$(_x, value)) {
        return true;
      } else {
        _tmp = _x$2;
        continue;
      }
    }
  }
}
function moonbitlang$core$immut$list$$T$drop$61$(self, n) {
  let _param3;
  let _param4;
  _L: {
    if (n <= 0) {
      return self;
    } else {
      _param3 = n;
      _param4 = self;
      break _L;
    }
  }
  let _tmp = _param3;
  let _tmp$2 = _param4;
  while (true) {
    const _param3$2 = _tmp;
    const _param4$2 = _tmp$2;
    if (_param4$2.$tag === 0) {
      return $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$6$;
    } else {
      if (_param3$2 === 1) {
        const _Cons = _param4$2;
        const _x = _Cons._1;
        return _x;
      } else {
        const _Cons = _param4$2;
        const _x = _Cons._1;
        const _tmp$3 = _param3$2 - 1 | 0;
        _tmp = _tmp$3;
        _tmp$2 = _x;
        continue;
      }
    }
  }
}
function moonbitlang$core$option$$Option$map$62$(self, f) {
  if (self === undefined) {
    return undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    return f(_x);
  }
}
function moonbitlang$core$option$$Option$is_empty$46$(self) {
  return self === undefined;
}
function moonbitlang$core$option$$Option$or$34$(self, default_) {
  if (self === undefined) {
    return default_;
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$or$63$(self, default_) {
  if (self === undefined) {
    return default_;
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$or$7$(self, default_) {
  if (self === undefined) {
    return default_;
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$or_default$7$(self) {
  if (self === undefined) {
    return moonbitlang$core$string$$String$default();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$hashmap$$power_2_above(x, n) {
  let _tmp = x;
  while (true) {
    const i = _tmp;
    if (i >= n) {
      return i;
    }
    const next = i << 1;
    if (next < 0) {
      return i;
    }
    _tmp = next;
    continue;
  }
}
function moonbitlang$core$hashmap$$new$64$(capacity) {
  const capacity$2 = moonbitlang$core$hashmap$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), capacity: capacity$2, size: 0 };
}
function moonbitlang$core$hashmap$$new$46$capacity$46$default$64$() {
  return 8;
}
function moonbitlang$core$hashmap$$T$set_with_hash$64$(self, key, value, hash) {
  if (self.size >= (self.capacity / 2 | 0)) {
    moonbitlang$core$hashmap$$T$grow$64$(self);
  }
  let _tmp = hash & (self.capacity - 1 | 0);
  let _tmp$2 = { psl: 0, hash: hash, key: key, value: value };
  while (true) {
    const idx = _tmp;
    const entry = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      self.entries[idx] = entry;
      self.size = self.size + 1 | 0;
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === entry.hash && moonbitlang$core$builtin$$Eq$op_equal$31$(_x.key, entry.key)) {
        _x.value = entry.value;
        break;
      }
      let curr_entry;
      if (entry.psl > _x.psl) {
        self.entries[idx] = entry;
        curr_entry = _x;
      } else {
        curr_entry = entry;
      }
      curr_entry.psl = curr_entry.psl + 1 | 0;
      const _tmp$3 = idx + 1 & (self.capacity - 1 | 0);
      _tmp = _tmp$3;
      _tmp$2 = curr_entry;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$T$grow$64$(self) {
  const old_entries = self.entries;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.capacity = new_capacity;
  self.size = 0;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < old_entries.length) {
      const _bind = old_entries[i];
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        const _x$2 = _x.key;
        const _x$3 = _x.value;
        const _x$4 = _x.hash;
        moonbitlang$core$hashmap$$T$set_with_hash$64$(self, _x$2, _x$3, _x$4);
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$hashmap$$T$set$64$(self, key, value) {
  moonbitlang$core$hashmap$$T$set_with_hash$64$(self, key, value, moonbitlang$core$builtin$$Hash$hash$65$(key));
}
function moonbitlang$core$hashmap$$T$op_set$64$(self, key, value) {
  moonbitlang$core$hashmap$$T$set$64$(self, key, value);
}
function moonbitlang$core$hashmap$$T$get_with_hash$64$(self, key, hash) {
  let _tmp = 0;
  let _tmp$2 = hash & (self.capacity - 1 | 0);
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$31$(_x.key, key)) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & (self.capacity - 1 | 0);
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$hashmap$$T$get$64$(self, key) {
  return moonbitlang$core$hashmap$$T$get_with_hash$64$(self, key, moonbitlang$core$builtin$$Hash$hash$65$(key));
}
function moonbitlang$core$hashmap$$T$op_get$64$(self, key) {
  return moonbitlang$core$hashmap$$T$get$64$(self, key);
}
function moonbitlang$core$hashmap$$T$iter$64$(self) {
  return moonbitlang$core$builtin$$Iter$new$66$((yield_) => {
    const _arr = self.entries;
    const _len = _arr.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        _L: {
          const entry = _arr[_i];
          if (entry === undefined) {
            break _L;
          } else {
            const _Some = entry;
            const _x = _Some;
            const _x$2 = _x.key;
            const _x$3 = _x.value;
            if (moonbitlang$core$builtin$$Eq$op_equal$9$(yield_({ _0: _x$2, _1: _x$3 }), 0)) {
              return 0;
            }
          }
          break _L;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$json$$indent_str(level, indent) {
  return indent === 0 ? "" : `\n${moonbitlang$core$string$$String$repeat(" ", Math.imul(indent, level) | 0)}`;
}
function moonbitlang$core$json$$escape$46$to_hex_digit$67$(i) {
  return i < 10 ? 48 + i | 0 : 97 + (i - 10 | 0) | 0;
}
function moonbitlang$core$json$$escape(str, escape_slash) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(str.length);
  const _bind = moonbitlang$core$string$$String$iter(str);
  _bind((c) => {
    _L: {
      _L$2: {
        switch (c) {
          case 34: {
            break _L$2;
          }
          case 92: {
            break _L$2;
          }
          case 47: {
            if (escape_slash) {
              moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\/");
            } else {
              moonbitlang$core$builtin$$StringBuilder$write_char(buf, c);
            }
            break;
          }
          case 10: {
            moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\n");
            break;
          }
          case 13: {
            moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\r");
            break;
          }
          case 8: {
            moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\b");
            break;
          }
          case 9: {
            moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\t");
            break;
          }
          default: {
            const code = c;
            if (code === 12) {
              moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\f");
            } else {
              if (code < 32) {
                moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\u00");
                moonbitlang$core$builtin$$StringBuilder$write_char(buf, moonbitlang$core$json$$escape$46$to_hex_digit$67$(code / 16 | 0));
                moonbitlang$core$builtin$$StringBuilder$write_char(buf, moonbitlang$core$json$$escape$46$to_hex_digit$67$(code % 16 | 0));
              } else {
                moonbitlang$core$builtin$$StringBuilder$write_char(buf, c);
              }
            }
          }
        }
        break _L;
      }
      moonbitlang$core$builtin$$StringBuilder$write_string(buf, `\\${String.fromCodePoint(c)}`);
    }
    return 1;
  });
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$json$$stringify$46$stringify_inner$68$(_env, value, level) {
  const indent = _env._1;
  const escape_slash = _env._0;
  switch (value.$tag) {
    case 6: {
      const _Object = value;
      const _x = _Object._0;
      if (moonbitlang$core$builtin$$Map$is_empty$69$(_x)) {
        return "{}";
      }
      const buf = moonbitlang$core$builtin$$StringBuilder$new(0);
      moonbitlang$core$builtin$$StringBuilder$write_char(buf, 123);
      moonbitlang$core$builtin$$StringBuilder$write_string(buf, moonbitlang$core$json$$indent_str(level + 1 | 0, indent));
      const first = { val: true };
      const _bind = moonbitlang$core$builtin$$Map$iter2$69$(_x);
      _bind((k, v) => {
        if (first.val) {
          first.val = false;
        } else {
          moonbitlang$core$builtin$$StringBuilder$write_char(buf, 44);
          moonbitlang$core$builtin$$StringBuilder$write_string(buf, moonbitlang$core$json$$indent_str(level + 1 | 0, indent));
        }
        moonbitlang$core$builtin$$StringBuilder$write_char(buf, 34);
        moonbitlang$core$builtin$$StringBuilder$write_string(buf, moonbitlang$core$json$$escape(k, escape_slash));
        moonbitlang$core$builtin$$StringBuilder$write_char(buf, 34);
        if (indent === 0) {
          moonbitlang$core$builtin$$StringBuilder$write_char(buf, 58);
        } else {
          moonbitlang$core$builtin$$StringBuilder$write_string(buf, ": ");
        }
        moonbitlang$core$builtin$$StringBuilder$write_string(buf, moonbitlang$core$json$$stringify$46$stringify_inner$68$(_env, v, level + 1 | 0));
        return 1;
      });
      moonbitlang$core$builtin$$StringBuilder$write_string(buf, moonbitlang$core$json$$indent_str(level, indent));
      moonbitlang$core$builtin$$StringBuilder$write_char(buf, 125);
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
    }
    case 5: {
      const _Array = value;
      const _x$2 = _Array._0;
      if (moonbitlang$core$array$$Array$is_empty$70$(_x$2)) {
        return "[]";
      }
      const buf$2 = moonbitlang$core$builtin$$StringBuilder$new(0);
      moonbitlang$core$builtin$$StringBuilder$write_char(buf$2, 91);
      moonbitlang$core$builtin$$StringBuilder$write_string(buf$2, moonbitlang$core$json$$indent_str(level + 1 | 0, indent));
      const _len = _x$2.length;
      let _tmp = 0;
      while (true) {
        const _i = _tmp;
        if (_i < _len) {
          const v = _x$2[_i];
          if (_i > 0) {
            moonbitlang$core$builtin$$StringBuilder$write_char(buf$2, 44);
            moonbitlang$core$builtin$$StringBuilder$write_string(buf$2, moonbitlang$core$json$$indent_str(level + 1 | 0, indent));
          }
          moonbitlang$core$builtin$$StringBuilder$write_string(buf$2, moonbitlang$core$json$$stringify$46$stringify_inner$68$(_env, v, level + 1 | 0));
          _tmp = _i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$builtin$$StringBuilder$write_string(buf$2, moonbitlang$core$json$$indent_str(level, indent));
      moonbitlang$core$builtin$$StringBuilder$write_char(buf$2, 93);
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf$2);
    }
    case 4: {
      const _String = value;
      const _x$3 = _String._0;
      const buf$3 = moonbitlang$core$builtin$$StringBuilder$new(0);
      moonbitlang$core$builtin$$StringBuilder$write_char(buf$3, 34);
      moonbitlang$core$builtin$$StringBuilder$write_string(buf$3, moonbitlang$core$json$$escape(_x$3, escape_slash));
      moonbitlang$core$builtin$$StringBuilder$write_char(buf$3, 34);
      return moonbitlang$core$builtin$$StringBuilder$to_string(buf$3);
    }
    case 3: {
      const _Number = value;
      const _x$4 = _Number._0;
      return String(_x$4);
    }
    case 1: {
      return "true";
    }
    case 2: {
      return "false";
    }
    default: {
      return "null";
    }
  }
}
function moonbitlang$core$json$$Json$stringify(self, escape_slash, indent) {
  const _env = { _0: escape_slash, _1: indent };
  return moonbitlang$core$json$$stringify$46$stringify_inner$68$(_env, self, 0);
}
function moonbitlang$core$json$$Json$stringify$46$escape_slash$46$default() {
  return false;
}
function moonbitlang$core$builtin$$abort$71$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$25$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$34$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$72$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$26$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$73$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$61$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$74$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$75$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$76$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$77$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$28$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$4$(msg) {
  $panic();
}
function moonbitlang$core$builtin$$abort$11$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$abort$7$(msg) {
  return $panic();
}
function moonbitlang$core$builtin$$rotl(x, r) {
  return x << r | (x >>> (32 - r | 0) | 0);
}
function moonbitlang$core$builtin$$op_ge$5$(self_, other) {
  return moonbitlang$core$int64$$Int64$compare(self_, other) >= 0;
}
function moonbitlang$core$builtin$$StringBuilder$new(size_hint) {
  return { val: "" };
}
function moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default() {
  return 0;
}
function moonbitlang$core$builtin$$StringBuilder$to_string(self) {
  return self.val;
}
function moonbitlang$core$builtin$$op_notequal$50$(x, y) {
  return !moonbitlang$core$option$$Option$op_equal$46$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$52$(x, y) {
  return !moonbitlang$core$option$$Option$op_equal$47$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$51$(x, y) {
  return !moonbitlang$core$option$$Option$op_equal$48$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$53$(x, y) {
  return !moonbitlang$core$option$$Option$op_equal$49$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$55$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$55$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$24$(x, y) {
  return !moonbitlang$core$option$$Option$op_equal$19$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$23$(x, y) {
  return !moonbitlang$core$option$$Option$op_equal$20$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$9$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$9$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$22$(x, y) {
  return !moonbitlang$core$option$$Option$op_equal$21$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$78$(x, y) {
  return !moonbitlang$core$builtin$$Eq$op_equal$78$(x, y);
}
function moonbitlang$core$builtin$$op_notequal$7$(x, y) {
  return !(x === y);
}
function moonbitlang$core$builtin$$println$7$(input) {
  console.log(moonbitlang$core$builtin$$Show$to_string$7$(input));
}
function moonbitlang$core$string$$String$escape(self) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$7$(self, { self: buf, method_0: moonbitlang$core$builtin$$StringBuilder$write_string, method_1: moonbitlang$core$builtin$$StringBuilder$write_substring, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$79$, method_3: moonbitlang$core$builtin$$StringBuilder$write_char });
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$builtin$$op_lt$43$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$43$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$45$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$45$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$44$(self_, other) {
  return moonbitlang$core$builtin$$Compare$compare$44$(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$5$(self_, other) {
  return moonbitlang$core$int64$$Int64$compare(self_, other) < 0;
}
function moonbitlang$core$builtin$$op_lt$7$(self_, other) {
  return moonbitlang$core$string$$String$compare(self_, other) < 0;
}
function moonbitlang$core$array$$Array$op_get$80$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$81$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$82$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$28$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$83$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$84$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$7$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$85$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$86$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$87$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$88$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$26$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$43$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$45$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$89$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$77$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$array$$Array$op_get$90$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : $panic();
}
function moonbitlang$core$builtin$$StringBuilder$write_char(self, ch) {
  const _bind = self;
  _bind.val = `${_bind.val}${String.fromCodePoint(ch)}`;
}
function moonbitlang$core$builtin$$StringBuilder$write_string(self, str) {
  const _bind = self;
  _bind.val = `${_bind.val}${str}`;
}
function moonbitlang$core$builtin$$Logger$write_object$84$(self, obj) {
  moonbitlang$core$builtin$$Show$output$84$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$45$(self, obj) {
  moonbitlang$core$builtin$$Show$output$45$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$17$(self, obj) {
  moonbitlang$core$builtin$$Show$output$17$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$44$(self, obj) {
  moonbitlang$core$builtin$$Show$output$44$(obj, self);
}
function moonbitlang$core$builtin$$Logger$write_object$28$(self, obj) {
  moonbitlang$core$builtin$$Show$output$28$(obj, self);
}
function moonbitlang$core$string$$String$substring(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x;
  }
  return start >= 0 && (start <= end$2 && end$2 <= len) ? self.substring(start, end$2) : $panic();
}
function moonbitlang$core$string$$String$substring$46$start$46$default() {
  return 0;
}
function moonbitlang$core$char$$Char$op_sub(self, that) {
  return self - that | 0;
}
function moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, bhi, blo) {
  const _x = self.hi;
  const _x$2 = self.lo;
  const lo = _x$2 + blo | 0;
  const s = lo >> 31;
  const as_ = _x$2 >> 31;
  const bs = blo >> 31;
  const c = (as_ & bs | ~s & (as_ ^ bs)) & 1;
  const hi = (_x + bhi | 0) + c | 0;
  return { hi: hi, lo: lo };
}
function moonbitlang$core$builtin$$MyInt64$op_add(self, other) {
  return moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, other.hi, other.lo);
}
function moonbitlang$core$int64$$Int64$op_add(self, other) {
  return moonbitlang$core$builtin$$MyInt64$op_add(self, other);
}
function moonbitlang$core$builtin$$op_gt$5$(self_, other) {
  return moonbitlang$core$int64$$Int64$compare(self_, other) > 0;
}
function moonbitlang$core$builtin$$StringBuilder$write_substring(self, str, start, len) {
  const _bind = self;
  _bind.val = `${_bind.val}${moonbitlang$core$string$$String$substring(str, start, start + len | 0)}`;
}
function moonbitlang$core$builtin$$Hasher$combine$31$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$31$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$91$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$91$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$45$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$45$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$7$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$7$(value, self);
}
function moonbitlang$core$builtin$$Hasher$combine$36$(self, value) {
  moonbitlang$core$builtin$$Hash$hash_combine$36$(value, self);
}
function moonbitlang$core$builtin$$power_2_above(x, n) {
  let _tmp = x;
  while (true) {
    const i = _tmp;
    if (i >= n) {
      return i;
    }
    const next = i << 1;
    if (next < 0) {
      return i;
    }
    _tmp = next;
    continue;
  }
}
function moonbitlang$core$builtin$$calc_grow_threshold(capacity) {
  return (Math.imul(capacity, 13) | 0) / 16 | 0;
}
function moonbitlang$core$builtin$$Map$new$69$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$92$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$93$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$94$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$95$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$builtin$$Map$new$96$(capacity) {
  const capacity$2 = moonbitlang$core$builtin$$power_2_above(8, capacity);
  return { entries: $make_array_len_and_init(capacity$2, undefined), list: $make_array_len_and_init(capacity$2, { prev: undefined, next: undefined }), size: 0, capacity: capacity$2, capacity_mask: capacity$2 - 1 | 0, growAt: moonbitlang$core$builtin$$calc_grow_threshold(capacity$2), head: undefined, tail: undefined };
}
function moonbitlang$core$array$$Array$each$97$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$98$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$99$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$100$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$101$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$array$$Array$each$102$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$94$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$96$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$92$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$95$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$93$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$add_entry_to_tail$69$(self, entry) {
  const _bind = self.tail;
  if (_bind === undefined) {
    self.head = entry;
    self.tail = entry;
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    self.list[_x.idx].next = entry;
    self.list[entry.idx].prev = _x;
    self.tail = entry;
    return;
  }
}
function moonbitlang$core$builtin$$Map$set$93$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$93$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$103$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$93$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$95$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$95$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$28$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$95$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$92$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$92$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$103$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$92$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$96$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$96$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$28$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$96$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$94$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$94$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$28$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$94$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$set$69$(self, key, value) {
  if (self.size >= self.growAt) {
    moonbitlang$core$builtin$$Map$grow$69$(self);
  }
  const hash = moonbitlang$core$builtin$$Hash$hash$103$(key);
  const insert_entry = { idx: -1, psl: 0, hash: hash, key: key, value: value };
  const list_node = { prev: undefined, next: undefined };
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  let _tmp$3 = insert_entry;
  let _tmp$4 = list_node;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    const _param$3 = _tmp$3;
    const _param$4 = _tmp$4;
    const _bind = self.entries[_param$2];
    if (_bind === undefined) {
      self.entries[_param$2] = _param$3;
      self.list[_param$2] = _param$4;
      _param$3.idx = _param$2;
      moonbitlang$core$builtin$$Map$add_entry_to_tail$69$(self, insert_entry);
      self.size = self.size + 1 | 0;
      return;
    } else {
      const _Some = _bind;
      const _x = _Some;
      const curr_node = self.list[_x.idx];
      if (_x.hash === _param$3.hash && _x.key === _param$3.key) {
        _x.value = _param$3.value;
        break;
      }
      if (_param$3.psl > _x.psl) {
        self.entries[_param$2] = _param$3;
        self.list[_param$2] = _param$4;
        _param$3.idx = _param$2;
        _x.psl = _x.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        _tmp$3 = _x;
        _tmp$4 = curr_node;
        continue;
      } else {
        _param$3.psl = _param$3.psl + 1 | 0;
        const _tmp$5 = _param + 1 | 0;
        const _tmp$6 = _param$2 + 1 & self.capacity_mask;
        _tmp = _tmp$5;
        _tmp$2 = _tmp$6;
        continue;
      }
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$94$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$94$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$96$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$96$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$92$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$92$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$95$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$95$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$93$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$93$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$grow$69$(self) {
  const old_head = self.head;
  const old_list = self.list;
  const new_capacity = self.capacity << 1;
  self.entries = $make_array_len_and_init(new_capacity, undefined);
  self.list = $make_array_len_and_init(new_capacity, { prev: undefined, next: undefined });
  self.capacity = new_capacity;
  self.capacity_mask = new_capacity - 1 | 0;
  self.growAt = moonbitlang$core$builtin$$calc_grow_threshold(self.capacity);
  self.size = 0;
  self.head = undefined;
  self.tail = undefined;
  let _tmp = old_head;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      const _x$2 = _x.idx;
      const _x$3 = _x.key;
      const _x$4 = _x.value;
      moonbitlang$core$builtin$$Map$set$69$(self, _x$3, _x$4);
      _tmp = old_list[_x$2].next;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$from_array$96$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$96$(arr.length);
  moonbitlang$core$array$$Array$each$102$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$96$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$95$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$95$(arr.length);
  moonbitlang$core$array$$Array$each$101$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$95$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$94$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$94$(arr.length);
  moonbitlang$core$array$$Array$each$100$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$94$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$93$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$93$(arr.length);
  moonbitlang$core$array$$Array$each$99$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$93$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$92$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$92$(arr.length);
  moonbitlang$core$array$$Array$each$98$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$92$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$from_array$69$(arr) {
  const m = moonbitlang$core$builtin$$Map$new$69$(arr.length);
  moonbitlang$core$array$$Array$each$97$(arr, (e) => {
    moonbitlang$core$builtin$$Map$set$69$(m, e._0, e._1);
  });
  return m;
}
function moonbitlang$core$builtin$$Map$op_set$93$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$93$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$94$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$94$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$96$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$96$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$92$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$92$(self, key, value);
}
function moonbitlang$core$builtin$$Map$op_set$95$(self, key, value) {
  moonbitlang$core$builtin$$Map$set$95$(self, key, value);
}
function moonbitlang$core$builtin$$Map$get$96$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$28$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$94$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$28$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$95$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$28$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$93$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$103$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$get$92$(self, key) {
  const hash = moonbitlang$core$builtin$$Hash$hash$103$(key);
  let _tmp = 0;
  let _tmp$2 = hash & self.capacity_mask;
  while (true) {
    const i = _tmp;
    const idx = _tmp$2;
    const _bind = self.entries[idx];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && _x.key === key) {
        return _x.value;
      }
      if (i > _x.psl) {
        return undefined;
      }
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = idx + 1 & self.capacity_mask;
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    }
  }
}
function moonbitlang$core$builtin$$Map$op_get$93$(self, key) {
  return moonbitlang$core$builtin$$Map$get$93$(self, key);
}
function moonbitlang$core$builtin$$Map$op_get$94$(self, key) {
  return moonbitlang$core$builtin$$Map$get$94$(self, key);
}
function moonbitlang$core$builtin$$Map$op_get$92$(self, key) {
  return moonbitlang$core$builtin$$Map$get$92$(self, key);
}
function moonbitlang$core$builtin$$Map$op_get$96$(self, key) {
  return moonbitlang$core$builtin$$Map$get$96$(self, key);
}
function moonbitlang$core$builtin$$Map$get_or_init$95$(self, key, default_) {
  const _bind = moonbitlang$core$builtin$$Map$get$95$(self, key);
  if (_bind === undefined) {
    const v = default_();
    moonbitlang$core$builtin$$Map$set$95$(self, key, v);
    return v;
  } else {
    const _Some = _bind;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$47$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$48$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$19$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$20$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$49$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$21$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$104$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$46$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$105$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$56$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$17$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$106$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$77$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$107$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$108$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$109$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$option$$Option$unwrap$84$(self) {
  if (self === undefined) {
    return $panic();
  } else {
    const _Some = self;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$core$builtin$$Map$is_empty$69$(self) {
  return self.size === 0;
}
function moonbitlang$core$builtin$$to_string$46$write_digits$110$(buf, num) {
  const num2 = num / 10 | 0;
  if (num2 !== 0) {
    moonbitlang$core$builtin$$to_string$46$write_digits$110$(buf, num2);
  }
  const n = num % 10 | 0;
  moonbitlang$core$builtin$$StringBuilder$write_char(buf, (n < 0 ? 0 - n | 0 : n) + 48 | 0);
}
function moonbitlang$core$int$$Int$to_string(self) {
  const buf = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  if (self < 0) {
    moonbitlang$core$builtin$$StringBuilder$write_char(buf, 45);
  }
  moonbitlang$core$builtin$$to_string$46$write_digits$110$(buf, self);
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$builtin$$Iter$new$56$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$111$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$28$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$66$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$25$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$112$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$55$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$77$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$33$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$113$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$8$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$114$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$26$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$45$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$17$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter$new$7$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$39$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$40$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$41$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$69$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$42$(f) {
  return f;
}
function moonbitlang$core$builtin$$Iter2$new$115$(f) {
  return f;
}
function moonbitlang$core$builtin$$Map$iter2$69$(self) {
  return moonbitlang$core$builtin$$Iter2$new$69$((yield_) => {
    let _tmp = self.head;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _x$2 = _x.key;
        const _x$3 = _x.value;
        const _x$4 = _x.idx;
        if (moonbitlang$core$builtin$$Eq$op_equal$9$(yield_(_x$2, _x$3), 0)) {
          return 0;
        } else {
          _tmp = self.list[_x$4].next;
          continue;
        }
      }
    }
  });
}
function moonbitlang$core$array$$Array$new$8$(capacity) {
  return [];
}
function moonbitlang$core$array$$Array$push$57$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$58$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$60$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$59$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$28$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$82$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$50$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$116$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$117$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$43$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$118$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$31$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$90$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$119$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$89$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$73$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$56$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$8$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$120$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$88$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$84$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$17$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$7$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$106$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$121$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$77$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$122$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$123$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$124$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$125$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$26$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$Array$push$126$(self, value) {
  moonbitlang$core$builtin$$JSArray$push(self, value);
}
function moonbitlang$core$array$$ArrayView$length$25$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$26$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$73$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$length$7$(self) {
  return self.len;
}
function moonbitlang$core$array$$ArrayView$op_get$25$(self, index) {
  return index >= 0 && index < self.len ? self.buf[self.start + index | 0] : moonbitlang$core$builtin$$abort$25$(`index out of bounds: the len is from 0 to ${moonbitlang$core$int$$Int$to_string(self.len)} but the index is ${moonbitlang$core$int$$Int$to_string(index)}`);
}
function moonbitlang$core$array$$ArrayView$op_get$26$(self, index) {
  return index >= 0 && index < self.len ? self.buf[self.start + index | 0] : moonbitlang$core$builtin$$abort$26$(`index out of bounds: the len is from 0 to ${moonbitlang$core$int$$Int$to_string(self.len)} but the index is ${moonbitlang$core$int$$Int$to_string(index)}`);
}
function moonbitlang$core$array$$ArrayView$op_get$73$(self, index) {
  return index >= 0 && index < self.len ? self.buf[self.start + index | 0] : moonbitlang$core$builtin$$abort$73$(`index out of bounds: the len is from 0 to ${moonbitlang$core$int$$Int$to_string(self.len)} but the index is ${moonbitlang$core$int$$Int$to_string(index)}`);
}
function moonbitlang$core$array$$ArrayView$swap$25$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const temp = self.buf[self.start + i | 0];
    self.buf[self.start + i | 0] = self.buf[self.start + j | 0];
    self.buf[self.start + j | 0] = temp;
    return;
  } else {
    moonbitlang$core$builtin$$abort$4$(`index out of bounds: the len is from 0 to ${moonbitlang$core$int$$Int$to_string(self.len)} but the index is (${moonbitlang$core$int$$Int$to_string(i)}, ${moonbitlang$core$int$$Int$to_string(j)})`);
    return;
  }
}
function moonbitlang$core$array$$ArrayView$swap$26$(self, i, j) {
  if (i >= 0 && (i < self.len && (j >= 0 && j < self.len))) {
    const temp = self.buf[self.start + i | 0];
    self.buf[self.start + i | 0] = self.buf[self.start + j | 0];
    self.buf[self.start + j | 0] = temp;
    return;
  } else {
    moonbitlang$core$builtin$$abort$4$(`index out of bounds: the len is from 0 to ${moonbitlang$core$int$$Int$to_string(self.len)} but the index is (${moonbitlang$core$int$$Int$to_string(i)}, ${moonbitlang$core$int$$Int$to_string(j)})`);
    return;
  }
}
function moonbitlang$core$array$$Array$op_as_view$7$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$76$("View index out of bounds");
}
function moonbitlang$core$array$$Array$op_as_view$73$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$75$("View index out of bounds");
}
function moonbitlang$core$array$$Array$op_as_view$45$(self, start, end) {
  const len = self.length;
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self, start: start$2, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$74$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$25$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$25$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$71$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$op_as_view$26$(self, start, end) {
  const len = moonbitlang$core$array$$ArrayView$length$26$(self);
  let end$2;
  if (end === undefined) {
    end$2 = len;
  } else {
    const _Some = end;
    const _x = _Some;
    end$2 = _x < 0 ? len + _x | 0 : _x;
  }
  const start$2 = start < 0 ? len + start | 0 : start;
  return start$2 >= 0 && (start$2 <= end$2 && end$2 <= len) ? { buf: self.buf, start: self.start + start$2 | 0, len: end$2 - start$2 | 0 } : moonbitlang$core$builtin$$abort$72$("View index out of bounds");
}
function moonbitlang$core$array$$ArrayView$iter$7$(self) {
  return moonbitlang$core$builtin$$Iter$new$7$((yield_) => {
    const _len = moonbitlang$core$array$$ArrayView$length$7$(self);
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self.buf[self.start + _i | 0];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return _bind;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$unsafe_pop$50$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$73$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$106$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$unsafe_pop$77$(self) {
  return moonbitlang$core$builtin$$JSArray$pop(self);
}
function moonbitlang$core$array$$Array$remove$77$(self, index) {
  if (index >= 0 && index < self.length) {
    const value = self[index];
    moonbitlang$core$builtin$$JSArray$splice(self, index, 1);
    return value;
  } else {
    return moonbitlang$core$builtin$$abort$77$(`index out of bounds: the len is from 0 to ${moonbitlang$core$int$$Int$to_string(self.length)} but the index is ${moonbitlang$core$int$$Int$to_string(index)}`);
  }
}
function moonbitlang$core$builtin$$Hasher$new(seed) {
  return { acc: seed + 374761393 | 0 };
}
function moonbitlang$core$builtin$$Hasher$new$46$seed$46$default() {
  return 0;
}
function moonbitlang$core$builtin$$Hasher$consume4(self, input) {
  self.acc = Math.imul(moonbitlang$core$builtin$$rotl(self.acc + (Math.imul(input, -1028477379) | 0) | 0, 17), 668265263) | 0;
}
function moonbitlang$core$builtin$$Hasher$combine_int(self, value) {
  self.acc = self.acc + 4 | 0;
  moonbitlang$core$builtin$$Hasher$consume4(self, value);
}
function moonbitlang$core$builtin$$MyInt64$to_int(self) {
  return self.lo;
}
function moonbitlang$core$int64$$Int64$to_int(self) {
  return moonbitlang$core$builtin$$MyInt64$to_int(self);
}
function moonbitlang$core$builtin$$Hasher$combine_string(self, value) {
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < value.length) {
      moonbitlang$core$builtin$$Hasher$combine_int(self, value.charCodeAt(i));
      _tmp = i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$core$builtin$$Hasher$avalanche(self) {
  let acc = self.acc;
  acc = acc ^ (acc >>> 15 | 0);
  acc = Math.imul(acc, -2048144777) | 0;
  acc = acc ^ (acc >>> 13 | 0);
  acc = Math.imul(acc, -1028477379) | 0;
  acc = acc ^ (acc >>> 16 | 0);
  return acc;
}
function moonbitlang$core$builtin$$Hasher$finalize(self) {
  return moonbitlang$core$builtin$$Hasher$avalanche(self);
}
function moonbitlang$core$builtin$$Hash$hash_combine$7$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_string(hasher, self);
}
function moonbitlang$core$builtin$$Hash$hash$28$(self) {
  const self$2 = self;
  let x = self$2 ^ (self$2 >>> 17 | 0);
  x = Math.imul(x, -312814405) | 0;
  x = x ^ (x >>> 11 | 0);
  x = Math.imul(x, -1404298415) | 0;
  x = x ^ (x >>> 15 | 0);
  x = Math.imul(x, 830770091) | 0;
  x = x ^ (x >>> 14 | 0);
  return x;
}
function moonbitlang$core$builtin$$Hash$hash_combine$28$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self);
}
function moonbitlang$core$array$$FixedArray$unsafe_blit$27$(dst, dst_offset, src, src_offset, len) {
  if (dst === src && dst_offset < src_offset) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i + 1 | 0;
        continue;
      } else {
        return;
      }
    }
  } else {
    let _tmp = len - 1 | 0;
    while (true) {
      const i = _tmp;
      if (i >= 0) {
        dst[dst_offset + i | 0] = src[src_offset + i | 0];
        _tmp = i - 1 | 0;
        continue;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$array$$FixedArray$blit_to$27$(self, dst, len, src_offset, dst_offset) {
  if ((dst_offset + len | 0) > dst.length || (src_offset + len | 0) > self.length) {
    $panic();
  }
  moonbitlang$core$array$$FixedArray$unsafe_blit$27$(dst, dst_offset, self, src_offset, len);
}
function moonbitlang$core$array$$FixedArray$blit_to$46$src_offset$46$default$27$() {
  return 0;
}
function moonbitlang$core$array$$FixedArray$blit_to$46$dst_offset$46$default$27$() {
  return 0;
}
function moonbitlang$core$builtin$$MyInt64$op_div(self, other) {
  const exports = moonbitlang$core$builtin$$get_int64_wasm_helper();
  const _x = self.hi;
  const _x$2 = self.lo;
  const _x$3 = other.hi;
  const _x$4 = other.lo;
  const _func = exports.div_s;
  const lo = _func(_x$2, _x, _x$4, _x$3);
  const _func$2 = exports.get_high;
  const hi = _func$2();
  return { hi: hi, lo: lo };
}
function moonbitlang$core$int64$$Int64$op_div(self, other) {
  return moonbitlang$core$builtin$$MyInt64$op_div(self, other);
}
function moonbitlang$core$builtin$$MyInt64$op_sub(self, other) {
  return other.lo === 0 ? { hi: self.hi - other.hi | 0, lo: self.lo } : moonbitlang$core$builtin$$MyInt64$add_hi_lo(self, ~other.hi, ~other.lo + 1 | 0);
}
function moonbitlang$core$int64$$Int64$op_sub(self, other) {
  return moonbitlang$core$builtin$$MyInt64$op_sub(self, other);
}
function moonbitlang$core$int$$Int$to_json(self) {
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Number(self + 0);
}
function moonbitlang$core$builtin$$escape_json_string$46$to_hex_digit$127$(i) {
  return i < 10 ? 48 + i | 0 : 97 + (i - 10 | 0) | 0;
}
function moonbitlang$core$builtin$$escape_json_string(str) {
  const len = str.length;
  const buf = moonbitlang$core$builtin$$StringBuilder$new(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      const c = str.charCodeAt(i);
      switch (c) {
        case 10: {
          moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\n");
          break;
        }
        case 13: {
          moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\r");
          break;
        }
        case 8: {
          moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\b");
          break;
        }
        case 9: {
          moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\t");
          break;
        }
        default: {
          const code = c;
          if (code === 12) {
            moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\f");
          } else {
            if (code < 32) {
              moonbitlang$core$builtin$$StringBuilder$write_string(buf, "\\u00");
              moonbitlang$core$builtin$$StringBuilder$write_char(buf, moonbitlang$core$builtin$$escape_json_string$46$to_hex_digit$127$(code / 16 | 0));
              moonbitlang$core$builtin$$StringBuilder$write_char(buf, moonbitlang$core$builtin$$escape_json_string$46$to_hex_digit$127$(code % 16 | 0));
            } else {
              moonbitlang$core$builtin$$StringBuilder$write_char(buf, c);
            }
          }
        }
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return moonbitlang$core$builtin$$StringBuilder$to_string(buf);
}
function moonbitlang$core$string$$String$to_json(self) {
  return new $64$moonbitlang$47$core$47$builtin$46$Json$String(moonbitlang$core$builtin$$escape_json_string(self));
}
function moonbitlang$core$array$$Array$map$128$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$129$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$30$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$130$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$131$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$132$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$133$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$134$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$135$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$map$136$(self, f) {
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$to_json$123$(self) {
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Array(moonbitlang$core$array$$Array$map$131$(self, moonbitlang$core$builtin$$ToJson$to_json$123$));
}
function moonbitlang$core$array$$Array$make$28$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$137$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$make$83$(len, elem) {
  const arr = new Array(len);
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < len) {
      arr[i] = elem;
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$op_set$28$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$137$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$array$$Array$op_set$83$(self, index, value) {
  const len = self.length;
  if (index >= 0 && index < len) {
    self[index] = value;
    return;
  } else {
    $panic();
    return;
  }
}
function moonbitlang$core$builtin$$MyInt64$from_int(value) {
  return { hi: value >> 31 & -1, lo: value | 0 };
}
function moonbitlang$core$int$$Int$to_int64(self) {
  return moonbitlang$core$builtin$$MyInt64$from_int(self);
}
function moonbitlang$core$builtin$$Show$output$28$(self, logger) {
  logger.method_0(logger.self, moonbitlang$core$int$$Int$to_string(self));
}
function moonbitlang$core$builtin$$output$46$flush_segment$138$(_env, i) {
  const self = _env._2;
  const logger = _env._1;
  const segment_start = _env._0;
  if (i > segment_start.val) {
    logger.method_1(logger.self, self, segment_start.val, i - segment_start.val | 0);
  }
  segment_start.val = i + 1 | 0;
}
function moonbitlang$core$builtin$$output$46$to_hex_digit$139$(i) {
  return i < 10 ? 48 + i | 0 : 97 + (i - 10 | 0) | 0;
}
function moonbitlang$core$builtin$$Show$output$7$(self, logger) {
  logger.method_3(logger.self, 34);
  const segment_start = { val: 0 };
  const _env = { _0: segment_start, _1: logger, _2: self };
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < self.length) {
      const c = self.charCodeAt(i);
      _L: {
        _L$2: {
          switch (c) {
            case 34: {
              break _L$2;
            }
            case 92: {
              break _L$2;
            }
            case 10: {
              moonbitlang$core$builtin$$output$46$flush_segment$138$(_env, i);
              logger.method_0(logger.self, "\\n");
              break;
            }
            case 13: {
              moonbitlang$core$builtin$$output$46$flush_segment$138$(_env, i);
              logger.method_0(logger.self, "\\r");
              break;
            }
            case 8: {
              moonbitlang$core$builtin$$output$46$flush_segment$138$(_env, i);
              logger.method_0(logger.self, "\\b");
              break;
            }
            case 9: {
              moonbitlang$core$builtin$$output$46$flush_segment$138$(_env, i);
              logger.method_0(logger.self, "\\t");
              break;
            }
            default: {
              const code = c;
              if (code < 32) {
                moonbitlang$core$builtin$$output$46$flush_segment$138$(_env, i);
                logger.method_3(logger.self, 92);
                logger.method_3(logger.self, 120);
                logger.method_3(logger.self, moonbitlang$core$builtin$$output$46$to_hex_digit$139$(code / 16 | 0));
                logger.method_3(logger.self, moonbitlang$core$builtin$$output$46$to_hex_digit$139$(code % 16 | 0));
              }
            }
          }
          break _L;
        }
        moonbitlang$core$builtin$$output$46$flush_segment$138$(_env, i);
        logger.method_3(logger.self, 92);
        logger.method_3(logger.self, c);
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$output$46$flush_segment$138$(_env, self.length);
  logger.method_3(logger.self, 34);
}
function moonbitlang$core$builtin$$Show$to_string$7$(self) {
  return self;
}
function moonbitlang$core$array$$Array$iter$25$(self) {
  return moonbitlang$core$builtin$$Iter$new$25$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return _bind;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$77$(self) {
  return moonbitlang$core$builtin$$Iter$new$77$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return _bind;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$45$(self) {
  return moonbitlang$core$builtin$$Iter$new$45$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return _bind;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$26$(self) {
  return moonbitlang$core$builtin$$Iter$new$26$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return _bind;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$17$(self) {
  return moonbitlang$core$builtin$$Iter$new$17$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return _bind;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$array$$Array$iter$7$(self) {
  return moonbitlang$core$builtin$$Iter$new$7$((yield_) => {
    const _len = self.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const v = self[_i];
        const _bind = yield_(v);
        if (_bind === 1) {
        } else {
          return _bind;
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        return 1;
      }
    }
  });
}
function moonbitlang$core$builtin$$Hash$hash$65$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$31$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Hash$hash$140$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$45$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Hash$hash$141$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$91$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Hash$hash$37$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$36$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Hash$hash$103$(self) {
  const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
  moonbitlang$core$builtin$$Hasher$combine$7$(hasher, self);
  return moonbitlang$core$builtin$$Hasher$finalize(hasher);
}
function moonbitlang$core$builtin$$Logger$write_sub_string$142$(self, value, start, len) {
  moonbitlang$core$builtin$$Logger$write_substring$143$(self, value, start, len);
}
function moonbitlang$core$builtin$$Logger$write_sub_string$79$(self, value, start, len) {
  moonbitlang$core$builtin$$StringBuilder$write_substring(self, value, start, len);
}
function moonbitlang$core$builtin$$Show$to_string$0$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$144$(self, { self: logger, method_0: moonbitlang$core$builtin$$StringBuilder$write_string, method_1: moonbitlang$core$builtin$$StringBuilder$write_substring, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$79$, method_3: moonbitlang$core$builtin$$StringBuilder$write_char });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$1$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$6$(self, { self: logger, method_0: moonbitlang$core$builtin$$StringBuilder$write_string, method_1: moonbitlang$core$builtin$$StringBuilder$write_substring, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$79$, method_3: moonbitlang$core$builtin$$StringBuilder$write_char });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$145$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$111$(self, { self: logger, method_0: moonbitlang$core$builtin$$StringBuilder$write_string, method_1: moonbitlang$core$builtin$$StringBuilder$write_substring, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$79$, method_3: moonbitlang$core$builtin$$StringBuilder$write_char });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$146$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$116$(self, { self: logger, method_0: moonbitlang$core$builtin$$StringBuilder$write_string, method_1: moonbitlang$core$builtin$$StringBuilder$write_substring, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$79$, method_3: moonbitlang$core$builtin$$StringBuilder$write_char });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$Show$to_string$147$(self) {
  const logger = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  moonbitlang$core$builtin$$Show$output$148$(self, { self: logger, method_0: moonbitlang$core$builtin$$StringBuilder$write_string, method_1: moonbitlang$core$builtin$$StringBuilder$write_substring, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$79$, method_3: moonbitlang$core$builtin$$StringBuilder$write_char });
  return moonbitlang$core$builtin$$StringBuilder$to_string(logger);
}
function moonbitlang$core$builtin$$MyInt64$op_mul(self, other) {
  const _x = self.hi;
  const _x$2 = self.lo;
  const _x$3 = other.hi;
  const _x$4 = other.lo;
  const ahi = _x;
  const alo = _x$2;
  const bhi = _x$3;
  const blo = _x$4;
  const a48 = ahi >>> 16 | 0;
  const a32 = ahi & 65535;
  const a16 = alo >>> 16 | 0;
  const a00 = alo & 65535;
  const b48 = bhi >>> 16 | 0;
  const b32 = bhi & 65535;
  const b16 = blo >>> 16 | 0;
  const b00 = blo & 65535;
  const c00 = Math.imul(a00, b00) | 0;
  const c16 = c00 >>> 16 | 0;
  const c00$2 = c00 & 65535;
  const c16$2 = (c16 >>> 0) + ((Math.imul(a16, b00) | 0) >>> 0) | 0;
  const c32 = c16$2 >>> 16 | 0;
  const c16$3 = c16$2 & 65535;
  const c16$4 = (c16$3 >>> 0) + ((Math.imul(a00, b16) | 0) >>> 0) | 0;
  const c32$2 = (c32 >>> 0) + ((c16$4 >>> 16 | 0) >>> 0) | 0;
  const c16$5 = c16$4 & 65535;
  const c32$3 = (c32$2 >>> 0) + ((Math.imul(a32, b00) | 0) >>> 0) | 0;
  const c48 = c32$3 >>> 16 | 0;
  const c32$4 = c32$3 & 65535;
  const c32$5 = (c32$4 >>> 0) + ((Math.imul(a16, b16) | 0) >>> 0) | 0;
  const c48$2 = (c48 >>> 0) + ((c32$5 >>> 16 | 0) >>> 0) | 0;
  const c32$6 = c32$5 & 65535;
  const c32$7 = (c32$6 >>> 0) + ((Math.imul(a00, b32) | 0) >>> 0) | 0;
  const c48$3 = (c48$2 >>> 0) + ((c32$7 >>> 16 | 0) >>> 0) | 0;
  const c32$8 = c32$7 & 65535;
  const c48$4 = (((((((c48$3 >>> 0) + ((Math.imul(a48, b00) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a32, b16) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a16, b32) | 0) >>> 0) | 0) >>> 0) + ((Math.imul(a00, b48) | 0) >>> 0) | 0;
  const c48$5 = c48$4 & 65535;
  return { hi: c48$5 << 16 | c32$8, lo: c16$5 << 16 | c00$2 };
}
function moonbitlang$core$int64$$Int64$op_mul(self, other) {
  return moonbitlang$core$builtin$$MyInt64$op_mul(self, other);
}
function moonbitlang$core$int64$$Int64$compare(self, other) {
  return moonbitlang$core$builtin$$MyInt64$compare(self, other);
}
function moonbitlang$core$builtin$$Iter2$run$39$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter2$run$40$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter2$run$41$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter2$run$42$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$option$$Option$op_equal$46$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$sorted_map$$Node$op_equal$39$(_x, _x$2);
    }
  }
}
function moonbitlang$core$option$$Option$op_equal$48$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$sorted_map$$Node$op_equal$40$(_x, _x$2);
    }
  }
}
function moonbitlang$core$option$$Option$op_equal$47$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$sorted_map$$Node$op_equal$41$(_x, _x$2);
    }
  }
}
function moonbitlang$core$option$$Option$op_equal$20$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$sorted_set$$Node$op_equal$18$(_x, _x$2);
    }
  }
}
function moonbitlang$core$option$$Option$op_equal$19$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$sorted_set$$Node$op_equal$7$(_x, _x$2);
    }
  }
}
function moonbitlang$core$option$$Option$op_equal$49$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$sorted_map$$Node$op_equal$42$(_x, _x$2);
    }
  }
}
function moonbitlang$core$option$$Option$op_equal$21$(self, other) {
  if (self === undefined) {
    return other === undefined;
  } else {
    const _Some = self;
    const _x = _Some;
    if (other === undefined) {
      return false;
    } else {
      const _Some$2 = other;
      const _x$2 = _Some$2;
      return moonbitlang$core$sorted_set$$Node$op_equal$17$(_x, _x$2);
    }
  }
}
function moonbitlang$core$array$$Array$get$45$(self, index) {
  const len = self.length;
  return index >= 0 && index < len ? self[index] : undefined;
}
function moonbitlang$core$array$$Array$op_equal$31$(self, other) {
  const self_len = self.length;
  const other_len = other.length;
  if (self_len === other_len) {
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < self_len) {
        if (moonbitlang$core$builtin$$Eq$op_equal$31$(self[i], other[i])) {
        } else {
          return false;
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        return true;
      }
    }
  } else {
    return false;
  }
}
function moonbitlang$core$array$$Array$mapi$149$(self, f) {
  if (self.length === 0) {
    return [];
  }
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(_i, v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$mapi$150$(self, f) {
  if (self.length === 0) {
    return [];
  }
  const arr = new Array(self.length);
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      arr[_i] = f(_i, v);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return arr;
}
function moonbitlang$core$array$$Array$is_empty$50$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$is_empty$70$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$is_empty$106$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$is_empty$77$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$is_empty$45$(self) {
  return self.length === 0;
}
function moonbitlang$core$array$$Array$contains$26$(self, value) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      if (moonbitlang$core$builtin$$Eq$op_equal$26$(v, value)) {
        return true;
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$array$$Array$search_by$77$(self, f) {
  const _len = self.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const v = self[_i];
      if (f(v)) {
        return _i;
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return undefined;
    }
  }
}
function moonbitlang$core$array$$Array$fold$151$(self, init, f) {
  let _tmp = 0;
  let _tmp$2 = init;
  while (true) {
    const i = _tmp;
    const acc = _tmp$2;
    if (i < self.length) {
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = f(acc, moonbitlang$core$array$$Array$op_get$26$(self, i));
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    } else {
      return acc;
    }
  }
}
function moonbitlang$core$array$$Array$fold$152$(self, init, f) {
  let _tmp = 0;
  let _tmp$2 = init;
  while (true) {
    const i = _tmp;
    const acc = _tmp$2;
    if (i < self.length) {
      const _tmp$3 = i + 1 | 0;
      const _tmp$4 = f(acc, moonbitlang$core$array$$Array$op_get$87$(self, i));
      _tmp = _tmp$3;
      _tmp$2 = _tmp$4;
      continue;
    } else {
      return acc;
    }
  }
}
function moonbitlang$core$builtin$$Iter$run$8$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$7$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$33$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$26$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$45$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Iter$run$17$(self, f) {
  const _func = self;
  return _func(f);
}
function moonbitlang$core$builtin$$Eq$op_equal$9$(_x_154, _x_155) {
  if (_x_154 === 0) {
    if (_x_155 === 0) {
      return true;
    } else {
      return false;
    }
  } else {
    if (_x_155 === 1) {
      return true;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Iter$any$8$(self, f) {
  return moonbitlang$core$builtin$$op_notequal$9$(moonbitlang$core$builtin$$Iter$run$8$(self, (k) => f(k) ? 0 : 1), 1);
}
function moonbitlang$core$builtin$$Iter$any$26$(self, f) {
  return moonbitlang$core$builtin$$op_notequal$9$(moonbitlang$core$builtin$$Iter$run$26$(self, (k) => f(k) ? 0 : 1), 1);
}
function moonbitlang$core$builtin$$Iter$all$45$(self, f) {
  return moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter$run$45$(self, (k) => !f(k) ? 0 : 1), 1);
}
function moonbitlang$core$builtin$$Iter$all$26$(self, f) {
  return moonbitlang$core$builtin$$Eq$op_equal$9$(moonbitlang$core$builtin$$Iter$run$26$(self, (k) => !f(k) ? 0 : 1), 1);
}
function moonbitlang$core$builtin$$Iter$find_first$77$(self, f) {
  const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$7$ };
  self((a) => {
    if (f(a)) {
      _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$7$(a);
      return 0;
    }
    return 1;
  });
  const _tmp = _foreach_result.val;
  switch (_tmp.$tag) {
    case 0: {
      return undefined;
    }
    case 1: {
      const _break = _tmp;
      return _break._0;
    }
    case 2: {
      const _return = _tmp;
      return _return._0;
    }
    case 3: {
      return $panic();
    }
    default: {
      return $panic();
    }
  }
}
function moonbitlang$core$builtin$$Iter$to_array$7$(self) {
  const result = [];
  self((e) => {
    moonbitlang$core$array$$Array$push$7$(result, e);
    return 1;
  });
  return result;
}
function moonbitlang$core$builtin$$Iter$contains$17$(self, value) {
  const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$8$ };
  self((v) => {
    if (moonbitlang$yacc$lib$grm$$Nonterminal$op_equal(v, value)) {
      _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$8$(true);
      return 0;
    }
    return 1;
  });
  const _tmp = _foreach_result.val;
  switch (_tmp.$tag) {
    case 0: {
      return false;
    }
    case 1: {
      const _break = _tmp;
      return _break._0;
    }
    case 2: {
      const _return = _tmp;
      return _return._0;
    }
    case 3: {
      return $panic();
    }
    default: {
      return $panic();
    }
  }
}
function moonbitlang$core$builtin$$Iter$contains$7$(self, value) {
  const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$8$ };
  self((v) => {
    if (v === value) {
      _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$8$(true);
      return 0;
    }
    return 1;
  });
  const _tmp = _foreach_result.val;
  switch (_tmp.$tag) {
    case 0: {
      return false;
    }
    case 1: {
      const _break = _tmp;
      return _break._0;
    }
    case 2: {
      const _return = _tmp;
      return _return._0;
    }
    case 3: {
      return $panic();
    }
    default: {
      return $panic();
    }
  }
}
function moonbitlang$core$builtin$$Show$output$148$(self, logger) {
  logger.method_0(logger.self, Error$$to_string(self));
}
function moonbitlang$x$fs$internal$ffi$$read_file_to_string(path) {
  return moonbitlang$x$fs$internal$ffi$$read_file_to_string_internal(path);
}
function moonbitlang$x$fs$internal$ffi$$write_string_to_file(path, content) {
  moonbitlang$x$fs$internal$ffi$$write_string_to_file_internal(path, content);
}
function moonbitlang$x$fs$internal$ffi$$path_exists(path) {
  return moonbitlang$x$fs$internal$ffi$$path_exists_internal(path);
}
function moonbitlang$x$fs$$IOError$to_string(self) {
  const _NotFound = self;
  const _x = _NotFound._0;
  return `\`${_x}\` does not exist`;
}
function moonbitlang$core$builtin$$Show$output$144$(self, logger) {
  logger.method_0(logger.self, moonbitlang$x$fs$$IOError$to_string(self));
}
function moonbitlang$x$fs$$write_string_to_file(path, content) {
  moonbitlang$x$fs$internal$ffi$$write_string_to_file(path, content);
}
function moonbitlang$x$fs$$path_exists(path) {
  return moonbitlang$x$fs$internal$ffi$$path_exists(path);
}
function moonbitlang$x$fs$$read_file_to_string(path) {
  if (moonbitlang$x$fs$$path_exists(path)) {
    return new Result$Ok$10$(moonbitlang$x$fs$internal$ffi$$read_file_to_string(path));
  } else {
    return new Result$Err$9$(new Error$moonbitlang$47$x$47$fs$46$IOError$46$NotFound(path));
  }
}
function moonbitlang$x$sys$internal$ffi$$get_cli_args() {
  return moonbitlang$x$sys$internal$ffi$$get_cli_args_internal();
}
function moonbitlang$x$sys$$get_cli_args() {
  return moonbitlang$x$sys$internal$ffi$$get_cli_args();
}
function Yoorkin$trie$$T$lookup$153$(self, path) {
  const _bind = moonbitlang$core$string$$String$to_array(path);
  let _tmp = { buf: _bind, start: 0, len: _bind.length };
  let _tmp$2 = self;
  while (true) {
    const _param = _tmp;
    const _param$2 = _tmp$2;
    if (_param.len === 0) {
      return _param$2.value;
    } else {
      const _x = _param.buf[_param.start + 0 | 0];
      const _tmp$3 = _param.buf;
      const _tmp$4 = 1 + _param.start | 0;
      const _some = _param.len - 0 | 0;
      const _x$2 = { buf: _tmp$3, start: _tmp$4, len: _some - 1 | 0 };
      const _bind$2 = moonbitlang$core$immut$sorted_map$$T$op_get$38$(_param$2.forks, _x);
      if (_bind$2 === undefined) {
        return undefined;
      } else {
        const _Some = _bind$2;
        const _x$3 = _Some;
        _tmp = _x$2;
        _tmp$2 = _x$3;
        continue;
      }
    }
  }
}
function Yoorkin$trie$$T$add$153$(self, path, value) {
  const _bind = moonbitlang$core$string$$String$to_array(path);
  return Yoorkin$trie$$add$46$aux$47$2964(value, { buf: _bind, start: 0, len: _bind.length }, self);
}
function Yoorkin$trie$$add$46$aux$47$2964(value, _param1, _param2) {
  if (_param1.len === 0) {
    return { value: value, forks: _param2.forks };
  } else {
    const _x = _param1.buf[_param1.start + 0 | 0];
    const _tmp = _param1.buf;
    const _tmp$2 = 1 + _param1.start | 0;
    const _some = _param1.len - 0 | 0;
    const _x$2 = { buf: _tmp, start: _tmp$2, len: _some - 1 | 0 };
    const subtree = moonbitlang$core$option$$Option$or$63$(moonbitlang$core$immut$sorted_map$$T$op_get$38$(_param2.forks, _x), { value: undefined, forks: moonbitlang$core$immut$sorted_map$$new$38$() });
    return { value: _param2.value, forks: moonbitlang$core$immut$sorted_map$$T$add$38$(_param2.forks, _x, Yoorkin$trie$$add$46$aux$47$2964(value, _x$2, subtree)) };
  }
}
function Yoorkin$trie$$empty$153$() {
  return { value: undefined, forks: moonbitlang$core$immut$sorted_map$$new$38$() };
}
function Yoorkin$ArgParser$$interpret(trie, xs, fallback) {
  const _bind = 0;
  const _bind$2 = xs.length;
  let _tmp = xs;
  let _tmp$2 = _bind;
  let _tmp$3 = _bind$2;
  _L: while (true) {
    const _param_buf = _tmp;
    const _param_start = _tmp$2;
    const _param_len = _tmp$3;
    if (_param_len === 0) {
      return;
    } else {
      const _x = _param_buf[_param_start + 0 | 0];
      const _bind$3 = 1 + _param_start | 0;
      const _some = _param_len - 0 | 0;
      const _bind$4 = _some - 1 | 0;
      const _bind$5 = Yoorkin$trie$$T$lookup$153$(trie, _x);
      if (_bind$5 === undefined) {
        fallback(_x);
        _tmp$2 = _bind$3;
        _tmp$3 = _bind$4;
        continue;
      } else {
        const _Some = _bind$5;
        const _x$2 = _Some;
        _L$2: {
          switch (_x$2.$tag) {
            case 1: {
              const _String = _x$2;
              const _x$3 = _String._0;
              if (_bind$4 >= 1) {
                const _x$4 = _param_buf[_bind$3 + 0 | 0];
                const _bind$6 = 1 + _bind$3 | 0;
                const _some$2 = _bind$4 - 0 | 0;
                const _bind$7 = _some$2 - 1 | 0;
                _x$3(_x$4);
                _tmp$2 = _bind$6;
                _tmp$3 = _bind$7;
                continue _L;
              } else {
                break _L$2;
              }
            }
            case 2: {
              const _Set_string = _x$2;
              const _x$4 = _Set_string._0;
              if (_bind$4 >= 1) {
                const _x$5 = _param_buf[_bind$3 + 0 | 0];
                const _bind$6 = 1 + _bind$3 | 0;
                const _some$2 = _bind$4 - 0 | 0;
                const _bind$7 = _some$2 - 1 | 0;
                _x$4.val = _x$5;
                _tmp$2 = _bind$6;
                _tmp$3 = _bind$7;
                continue _L;
              } else {
                break _L$2;
              }
            }
            case 3: {
              const _Set = _x$2;
              const _x$5 = _Set._0;
              _x$5.val = true;
              _tmp$2 = _bind$3;
              _tmp$3 = _bind$4;
              continue _L;
            }
            case 4: {
              const _Clear = _x$2;
              const _x$6 = _Clear._0;
              _x$6.val = false;
              _tmp$2 = _bind$3;
              _tmp$3 = _bind$4;
              continue _L;
            }
            default: {
              const _Unit = _x$2;
              const _x$7 = _Unit._0;
              _x$7();
              _tmp$2 = _bind$3;
              _tmp$3 = _bind$4;
              continue _L;
            }
          }
        }
        moonbitlang$core$builtin$$println$7$(`missing argument for ${_x}`);
        return;
      }
    }
  }
}
function Yoorkin$ArgParser$$parse$46$aux$154$(_param1, _param2) {
  const _x = _param1._0;
  const _x$2 = _param1._1;
  const _x$3 = _param2._0;
  const _x$4 = _param2._1;
  const _x$5 = _param2._2;
  const _x$6 = _param2._3;
  const trie = Yoorkin$trie$$T$add$153$(Yoorkin$trie$$T$add$153$(_x, _x$3, _x$5), _x$4, _x$5);
  const help_msg = `${_x$2}  ${_x$3}\t${_x$4}\t${_x$6}\n`;
  return { _0: trie, _1: help_msg };
}
function Yoorkin$ArgParser$$parse(speclist, rest, usage_msg, argv) {
  const _bind = moonbitlang$core$array$$Array$fold$152$(speclist, { _0: Yoorkin$trie$$empty$153$(), _1: `${usage_msg}\n options:\n` }, Yoorkin$ArgParser$$parse$46$aux$154$);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  const help_spec = new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
    moonbitlang$core$builtin$$println$7$(_x$2);
  });
  const trie = Yoorkin$trie$$T$add$153$(Yoorkin$trie$$T$add$153$(_x, "--help", help_spec), "-h", help_spec);
  Yoorkin$ArgParser$$interpret(trie, argv, rest);
}
function moonbitlang$core$builtin$$Eq$op_equal$84$(self, other) {
  return self.num === other.num;
}
function moonbitlang$core$builtin$$Compare$compare$84$(self, other) {
  return $compare_int(self.num, other.num);
}
function moonbitlang$core$builtin$$Hash$hash_combine$84$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self.num);
}
function moonbitlang$core$builtin$$Show$output$84$(self, logger) {
  logger.method_0(logger.self, self.name);
}
function moonbitlang$yacc$lib$grm$$Nonterminal$op_equal(self, other) {
  return self.num === other.num;
}
function moonbitlang$yacc$lib$grm$$Nonterminal$compare(self, other) {
  return $compare_int(self.num, other.num);
}
function moonbitlang$core$builtin$$Hash$hash_combine$17$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self.num);
}
function moonbitlang$core$builtin$$Show$output$17$(self, logger) {
  logger.method_0(logger.self, self.name);
}
function moonbitlang$core$builtin$$Eq$op_equal$45$(_x_112, _x_113) {
  if (_x_112.$tag === 0) {
    const _T = _x_112;
    const _x = _T._0;
    if (_x_113.$tag === 0) {
      const _T$2 = _x_113;
      const _x$2 = _T$2._0;
      return moonbitlang$core$builtin$$Eq$op_equal$84$(_x, _x$2);
    } else {
      return false;
    }
  } else {
    const _NT = _x_112;
    const _x = _NT._0;
    if (_x_113.$tag === 1) {
      const _NT$2 = _x_113;
      const _x$2 = _NT$2._0;
      return moonbitlang$yacc$lib$grm$$Nonterminal$op_equal(_x, _x$2);
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$45$(_x_100, _x_101) {
  if (_x_100.$tag === 0) {
    const _T = _x_100;
    const _x = _T._0;
    if (_x_101.$tag === 0) {
      const _T$2 = _x_101;
      const _x$2 = _T$2._0;
      return moonbitlang$core$builtin$$Compare$compare$84$(_x, _x$2);
    } else {
      return -1;
    }
  } else {
    const _NT = _x_100;
    const _x = _NT._0;
    if (_x_101.$tag === 0) {
      return 1;
    } else {
      const _NT$2 = _x_101;
      const _x$2 = _NT$2._0;
      return moonbitlang$yacc$lib$grm$$Nonterminal$compare(_x, _x$2);
    }
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$45$(_x_92, _x_93) {
  if (_x_92.$tag === 0) {
    const _T = _x_92;
    const _x = _T._0;
    moonbitlang$core$builtin$$Hasher$combine_int(_x_93, 0);
    moonbitlang$core$builtin$$Hash$hash_combine$84$(_x, _x_93);
    return;
  } else {
    const _NT = _x_92;
    const _x = _NT._0;
    moonbitlang$core$builtin$$Hasher$combine_int(_x_93, 1);
    moonbitlang$core$builtin$$Hash$hash_combine$17$(_x, _x_93);
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$45$(self, logger) {
  if (self.$tag === 0) {
    const _T = self;
    const _x = _T._0;
    moonbitlang$core$builtin$$Logger$write_object$84$(logger, _x);
    return;
  } else {
    const _NT = self;
    const _x = _NT._0;
    moonbitlang$core$builtin$$Logger$write_object$17$(logger, _x);
    return;
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$26$(self, other) {
  return self.num === other.num;
}
function moonbitlang$yacc$lib$grm$$Production$output_with_opt_dot$155$(self, logger, dot) {
  moonbitlang$core$builtin$$Logger$write_object$17$({ self: logger, method_0: (x, x$2) => {
    x.method_0(x.self, x$2);
  }, method_1: (x, x$2, x$3, x$4) => {
    x.method_1(x.self, x$2, x$3, x$4);
  }, method_2: (x, x$2, x$3, x$4) => {
    x.method_2(x.self, x$2, x$3, x$4);
  }, method_3: (x, x$2) => {
    x.method_3(x.self, x$2);
  } }, self.lhs);
  logger.method_0(logger.self, " →");
  const _arr = self.rhs;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const symbol = _arr[_i];
      if (dot === undefined) {
      } else {
        const _Some = dot;
        const _x = _Some;
        if (_i === _x) {
          logger.method_0(logger.self, " •");
        }
      }
      logger.method_0(logger.self, " ");
      moonbitlang$core$builtin$$Logger$write_object$45$({ self: logger, method_0: (x, x$2) => {
        x.method_0(x.self, x$2);
      }, method_1: (x, x$2, x$3, x$4) => {
        x.method_1(x.self, x$2, x$3, x$4);
      }, method_2: (x, x$2, x$3, x$4) => {
        x.method_2(x.self, x$2, x$3, x$4);
      }, method_3: (x, x$2) => {
        x.method_3(x.self, x$2);
      } }, symbol);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (dot === undefined) {
    return;
  } else {
    const _Some = dot;
    const _x = _Some;
    if (_x === self.rhs.length) {
      logger.method_0(logger.self, " •");
      return;
    } else {
      return;
    }
  }
}
function moonbitlang$yacc$lib$parser$$Lexbuf$from_string(content) {
  return { content: content, pos: 0 };
}
function moonbitlang$yacc$lib$parser$$Lexbuf$next(self) {
  if (self.pos < self.content.length) {
    const ch = self.content.charCodeAt(self.pos);
    self.pos = self.pos + 1 | 0;
    return ch;
  } else {
    return -1;
  }
}
function moonbitlang$yacc$lib$parser$$Lexbuf$substring(self, start, end) {
  return moonbitlang$core$string$$String$substring(self.content, start, end);
}
function moonbitlang$yacc$lib$parser$$LexEngine$run(self, lexbuf) {
  let state = 1;
  let tagState = [];
  const backtrace = moonbitlang$core$array$$Array$make$137$(self.code_blocks_n, undefined);
  const _arr = self.start_tags;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const tag = _arr[_i];
      while (true) {
        if (tagState.length <= tag) {
          moonbitlang$core$array$$Array$push$82$(tagState, []);
          continue;
        } else {
          break;
        }
      }
      moonbitlang$core$array$$Array$push$28$(moonbitlang$core$array$$Array$op_get$82$(tagState, tag), lexbuf.pos);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    if (state !== 0) {
      const _bind = moonbitlang$core$array$$Array$op_get$81$(self.end_nodes, state);
      if (_bind === undefined) {
      } else {
        const _Some = _bind;
        const _x = _Some;
        moonbitlang$core$array$$Array$op_set$137$(backtrace, _x._0, { _0: lexbuf.pos, _1: state, _2: tagState });
      }
      const _bind$2 = moonbitlang$yacc$lib$parser$$Lexbuf$next(lexbuf);
      let b;
      if (_bind$2 === -1) {
        b = 0;
      } else {
        const _Some = _bind$2;
        const _x = _Some;
        b = _x;
      }
      const _func = moonbitlang$core$array$$Array$op_get$80$(self.graph, state);
      const next = _func(b);
      state = next._0;
      const new_tagState = [];
      let _tmp$2 = 0;
      while (true) {
        const i = _tmp$2;
        if (i < next._1.length) {
          moonbitlang$core$array$$Array$push$82$(new_tagState, []);
          let _tmp$3 = 0;
          while (true) {
            const j = _tmp$3;
            if (j < moonbitlang$core$array$$Array$op_get$82$(next._1, i).length) {
              const t = moonbitlang$core$array$$Array$op_get$28$(moonbitlang$core$array$$Array$op_get$82$(next._1, i), j);
              if (t === -1) {
                moonbitlang$core$array$$Array$push$28$(moonbitlang$core$array$$Array$op_get$82$(new_tagState, i), lexbuf.pos);
              } else {
                moonbitlang$core$array$$Array$push$28$(moonbitlang$core$array$$Array$op_get$82$(new_tagState, i), moonbitlang$core$array$$Array$op_get$28$(moonbitlang$core$array$$Array$op_get$82$(tagState, i), t));
              }
              _tmp$3 = j + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          _tmp$2 = i + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      tagState = new_tagState;
      continue;
    } else {
      break;
    }
  }
  const _len$2 = backtrace.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const b = backtrace[_i];
      if (b === undefined) {
      } else {
        const _Some = b;
        const _x = _Some;
        const _x$2 = _x._0;
        const _x$3 = _x._1;
        const _x$4 = _x._2;
        lexbuf.pos = _x$2;
        const captures = moonbitlang$core$array$$Array$map$128$(moonbitlang$core$option$$Option$unwrap$104$(moonbitlang$core$array$$Array$op_get$81$(self.end_nodes, _x$3))._1, (_param1) => {
          const _x$5 = _param1._0;
          const _x$6 = _x$5._0;
          const _x$7 = _x$5._1;
          const _x$8 = _param1._1;
          const _x$9 = _x$8._0;
          const _x$10 = _x$8._1;
          return { _0: moonbitlang$core$array$$Array$op_get$28$(moonbitlang$core$array$$Array$op_get$82$(_x$4, _x$6), _x$7), _1: moonbitlang$core$array$$Array$op_get$28$(moonbitlang$core$array$$Array$op_get$82$(_x$4, _x$9), _x$10) };
        });
        return { _0: _i, _1: captures };
      }
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      return { _0: self.code_blocks_n, _1: [] };
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_0(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_1(input) {
  if (input === 0) {
    return { _0: 16, _1: moonbitlang$yacc$lib$parser$$token_tag_action_0 };
  } else {
    if (1 <= input && input <= 8) {
      return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
    } else {
      if (9 <= input && input <= 10) {
        return { _0: 4, _1: moonbitlang$yacc$lib$parser$$token_tag_action_2 };
      } else {
        if (11 <= input && input <= 31) {
          return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
        } else {
          switch (input) {
            case 32: {
              return { _0: 4, _1: moonbitlang$yacc$lib$parser$$token_tag_action_2 };
            }
            case 33: {
              return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
            }
            case 34: {
              return { _0: 7, _1: moonbitlang$yacc$lib$parser$$token_tag_action_3 };
            }
            default: {
              if (35 <= input && input <= 36) {
                return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
              } else {
                if (input === 37) {
                  return { _0: 2, _1: moonbitlang$yacc$lib$parser$$token_tag_action_4 };
                } else {
                  if (38 <= input && input <= 39) {
                    return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                  } else {
                    if (input === 40) {
                      return { _0: 8, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                    } else {
                      if (41 <= input && input <= 44) {
                        return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                      } else {
                        switch (input) {
                          case 45: {
                            return { _0: 10, _1: moonbitlang$yacc$lib$parser$$token_tag_action_5 };
                          }
                          case 46: {
                            return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                          }
                          case 47: {
                            return { _0: 9, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                          }
                          default: {
                            if (48 <= input && input <= 57) {
                              return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                            } else {
                              switch (input) {
                                case 58: {
                                  return { _0: 3, _1: moonbitlang$yacc$lib$parser$$token_tag_action_6 };
                                }
                                case 59: {
                                  return { _0: 6, _1: moonbitlang$yacc$lib$parser$$token_tag_action_7 };
                                }
                                case 60: {
                                  return { _0: 12, _1: moonbitlang$yacc$lib$parser$$token_tag_action_8 };
                                }
                                case 61: {
                                  return { _0: 13, _1: moonbitlang$yacc$lib$parser$$token_tag_action_9 };
                                }
                                default: {
                                  if (62 <= input && input <= 64) {
                                    return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                                  } else {
                                    if (65 <= input && input <= 90) {
                                      return { _0: 14, _1: moonbitlang$yacc$lib$parser$$token_tag_action_7 };
                                    } else {
                                      if (91 <= input && input <= 94) {
                                        return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                                      } else {
                                        switch (input) {
                                          case 95: {
                                            return { _0: 14, _1: moonbitlang$yacc$lib$parser$$token_tag_action_7 };
                                          }
                                          case 96: {
                                            return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                                          }
                                          default: {
                                            if (97 <= input && input <= 122) {
                                              return { _0: 14, _1: moonbitlang$yacc$lib$parser$$token_tag_action_7 };
                                            } else {
                                              switch (input) {
                                                case 123: {
                                                  return { _0: 5, _1: moonbitlang$yacc$lib$parser$$token_tag_action_10 };
                                                }
                                                case 124: {
                                                  return { _0: 15, _1: moonbitlang$yacc$lib$parser$$token_tag_action_11 };
                                                }
                                                default: {
                                                  return 125 <= input && input <= 127 ? { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 } : $panic();
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_2(input) {
  switch (input) {
    case 37: {
      return { _0: 21, _1: moonbitlang$yacc$lib$parser$$token_tag_action_12 };
    }
    case 100: {
      return { _0: 23, _1: moonbitlang$yacc$lib$parser$$token_tag_action_13 };
    }
    case 108: {
      return { _0: 19, _1: moonbitlang$yacc$lib$parser$$token_tag_action_14 };
    }
    case 110: {
      return { _0: 25, _1: moonbitlang$yacc$lib$parser$$token_tag_action_15 };
    }
    case 112: {
      return { _0: 18, _1: moonbitlang$yacc$lib$parser$$token_tag_action_16 };
    }
    case 114: {
      return { _0: 17, _1: moonbitlang$yacc$lib$parser$$token_tag_action_17 };
    }
    case 115: {
      return { _0: 20, _1: moonbitlang$yacc$lib$parser$$token_tag_action_18 };
    }
    case 116: {
      return { _0: 24, _1: moonbitlang$yacc$lib$parser$$token_tag_action_19 };
    }
    case 123: {
      return { _0: 22, _1: moonbitlang$yacc$lib$parser$$token_tag_action_20 };
    }
    default: {
      return { _0: 0, _1: [] };
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_3(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_4(input) {
  if (input === 0) {
    return { _0: 16, _1: moonbitlang$yacc$lib$parser$$token_tag_action_0 };
  } else {
    if (1 <= input && input <= 8) {
      return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
    } else {
      if (9 <= input && input <= 10) {
        return { _0: 4, _1: moonbitlang$yacc$lib$parser$$token_tag_action_2 };
      } else {
        if (11 <= input && input <= 31) {
          return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
        } else {
          switch (input) {
            case 32: {
              return { _0: 4, _1: moonbitlang$yacc$lib$parser$$token_tag_action_2 };
            }
            case 33: {
              return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
            }
            case 34: {
              return { _0: 7, _1: moonbitlang$yacc$lib$parser$$token_tag_action_3 };
            }
            default: {
              if (35 <= input && input <= 36) {
                return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
              } else {
                if (input === 37) {
                  return { _0: 2, _1: moonbitlang$yacc$lib$parser$$token_tag_action_4 };
                } else {
                  if (38 <= input && input <= 39) {
                    return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                  } else {
                    if (input === 40) {
                      return { _0: 8, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                    } else {
                      if (41 <= input && input <= 44) {
                        return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                      } else {
                        switch (input) {
                          case 45: {
                            return { _0: 10, _1: moonbitlang$yacc$lib$parser$$token_tag_action_5 };
                          }
                          case 46: {
                            return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                          }
                          case 47: {
                            return { _0: 9, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                          }
                          default: {
                            if (48 <= input && input <= 57) {
                              return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                            } else {
                              switch (input) {
                                case 58: {
                                  return { _0: 3, _1: moonbitlang$yacc$lib$parser$$token_tag_action_6 };
                                }
                                case 59: {
                                  return { _0: 6, _1: moonbitlang$yacc$lib$parser$$token_tag_action_7 };
                                }
                                case 60: {
                                  return { _0: 12, _1: moonbitlang$yacc$lib$parser$$token_tag_action_8 };
                                }
                                case 61: {
                                  return { _0: 13, _1: moonbitlang$yacc$lib$parser$$token_tag_action_9 };
                                }
                                default: {
                                  if (62 <= input && input <= 64) {
                                    return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                                  } else {
                                    if (65 <= input && input <= 90) {
                                      return { _0: 14, _1: moonbitlang$yacc$lib$parser$$token_tag_action_7 };
                                    } else {
                                      if (91 <= input && input <= 94) {
                                        return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                                      } else {
                                        switch (input) {
                                          case 95: {
                                            return { _0: 14, _1: moonbitlang$yacc$lib$parser$$token_tag_action_7 };
                                          }
                                          case 96: {
                                            return { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
                                          }
                                          default: {
                                            if (97 <= input && input <= 122) {
                                              return { _0: 14, _1: moonbitlang$yacc$lib$parser$$token_tag_action_7 };
                                            } else {
                                              switch (input) {
                                                case 123: {
                                                  return { _0: 5, _1: moonbitlang$yacc$lib$parser$$token_tag_action_10 };
                                                }
                                                case 124: {
                                                  return { _0: 15, _1: moonbitlang$yacc$lib$parser$$token_tag_action_11 };
                                                }
                                                default: {
                                                  return 125 <= input && input <= 127 ? { _0: 11, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 } : $panic();
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_5(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_6(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_7(input) {
  return 1 <= input && input <= 33 ? { _0: 26, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 } : 35 <= input && input <= 127 ? { _0: 26, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 } : { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_8(input) {
  if (input === 42) {
    return { _0: 27, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_9(input) {
  if (input === 42) {
    return { _0: 28, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_10(input) {
  if (input === 62) {
    return { _0: 29, _1: moonbitlang$yacc$lib$parser$$token_tag_action_23 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_11(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_12(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_13(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_14(input) {
  if (48 <= input && input <= 57) {
    return { _0: 30, _1: moonbitlang$yacc$lib$parser$$token_tag_action_24 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 30, _1: moonbitlang$yacc$lib$parser$$token_tag_action_24 };
    } else {
      if (input === 95) {
        return { _0: 30, _1: moonbitlang$yacc$lib$parser$$token_tag_action_24 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 30, _1: moonbitlang$yacc$lib$parser$$token_tag_action_24 } : { _0: 0, _1: [] };
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_15(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_16(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_17(input) {
  if (input === 105) {
    return { _0: 31, _1: moonbitlang$yacc$lib$parser$$token_tag_action_17 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_18(input) {
  switch (input) {
    case 111: {
      return { _0: 33, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 };
    }
    case 114: {
      return { _0: 32, _1: moonbitlang$yacc$lib$parser$$token_tag_action_25 };
    }
    default: {
      return { _0: 0, _1: [] };
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_19(input) {
  if (input === 101) {
    return { _0: 34, _1: moonbitlang$yacc$lib$parser$$token_tag_action_14 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_20(input) {
  if (input === 116) {
    return { _0: 35, _1: moonbitlang$yacc$lib$parser$$token_tag_action_18 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_21(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_22(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_23(input) {
  if (input === 101) {
    return { _0: 36, _1: moonbitlang$yacc$lib$parser$$token_tag_action_13 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_24(input) {
  switch (input) {
    case 111: {
      return { _0: 38, _1: moonbitlang$yacc$lib$parser$$token_tag_action_26 };
    }
    case 121: {
      return { _0: 37, _1: moonbitlang$yacc$lib$parser$$token_tag_action_27 };
    }
    default: {
      return { _0: 0, _1: [] };
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_25(input) {
  if (input === 111) {
    return { _0: 39, _1: moonbitlang$yacc$lib$parser$$token_tag_action_15 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_26(input) {
  if (1 <= input && input <= 33) {
    return { _0: 26, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 };
  } else {
    if (input === 34) {
      return { _0: 40, _1: moonbitlang$yacc$lib$parser$$token_tag_action_28 };
    } else {
      return 35 <= input && input <= 127 ? { _0: 26, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 } : { _0: 0, _1: [] };
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_27(input) {
  if (input === 41) {
    return { _0: 41, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_28(input) {
  if (1 <= input && input <= 41) {
    return { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
  } else {
    if (input === 42) {
      return { _0: 42, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
    } else {
      if (43 <= input && input <= 46) {
        return { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
      } else {
        if (input === 47) {
          return { _0: 44, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
        } else {
          return 48 <= input && input <= 127 ? { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_29(input) {
  if (1 <= input && input <= 8) {
    return { _0: 46, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 45, _1: moonbitlang$yacc$lib$parser$$token_tag_action_23 };
    } else {
      if (11 <= input && input <= 31) {
        return { _0: 46, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 };
      } else {
        if (input === 32) {
          return { _0: 45, _1: moonbitlang$yacc$lib$parser$$token_tag_action_23 };
        } else {
          return 33 <= input && input <= 57 ? { _0: 46, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 } : 59 <= input && input <= 127 ? { _0: 46, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_30(input) {
  if (48 <= input && input <= 57) {
    return { _0: 30, _1: moonbitlang$yacc$lib$parser$$token_tag_action_24 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 30, _1: moonbitlang$yacc$lib$parser$$token_tag_action_24 };
    } else {
      if (input === 95) {
        return { _0: 30, _1: moonbitlang$yacc$lib$parser$$token_tag_action_24 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 30, _1: moonbitlang$yacc$lib$parser$$token_tag_action_24 } : { _0: 0, _1: [] };
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_31(input) {
  if (input === 103) {
    return { _0: 47, _1: moonbitlang$yacc$lib$parser$$token_tag_action_17 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_32(input) {
  if (input === 101) {
    return { _0: 48, _1: moonbitlang$yacc$lib$parser$$token_tag_action_25 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_33(input) {
  if (input === 115) {
    return { _0: 49, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_34(input) {
  if (input === 102) {
    return { _0: 50, _1: moonbitlang$yacc$lib$parser$$token_tag_action_14 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_35(input) {
  if (input === 97) {
    return { _0: 51, _1: moonbitlang$yacc$lib$parser$$token_tag_action_18 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_36(input) {
  if (input === 114) {
    return { _0: 52, _1: moonbitlang$yacc$lib$parser$$token_tag_action_13 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_37(input) {
  if (input === 112) {
    return { _0: 53, _1: moonbitlang$yacc$lib$parser$$token_tag_action_27 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_38(input) {
  if (input === 107) {
    return { _0: 54, _1: moonbitlang$yacc$lib$parser$$token_tag_action_26 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_39(input) {
  if (input === 110) {
    return { _0: 55, _1: moonbitlang$yacc$lib$parser$$token_tag_action_15 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_40(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_41(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_42(input) {
  if (1 <= input && input <= 41) {
    return { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
  } else {
    if (input === 42) {
      return { _0: 42, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
    } else {
      if (43 <= input && input <= 46) {
        return { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
      } else {
        if (input === 47) {
          return { _0: 56, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
        } else {
          return 48 <= input && input <= 127 ? { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_43(input) {
  if (1 <= input && input <= 41) {
    return { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
  } else {
    if (input === 42) {
      return { _0: 42, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
    } else {
      if (43 <= input && input <= 46) {
        return { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
      } else {
        if (input === 47) {
          return { _0: 44, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
        } else {
          return 48 <= input && input <= 127 ? { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_44(input) {
  return 1 <= input && input <= 41 ? { _0: 57, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 } : 43 <= input && input <= 127 ? { _0: 57, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 } : { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_45(input) {
  if (1 <= input && input <= 8) {
    return { _0: 46, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 45, _1: moonbitlang$yacc$lib$parser$$token_tag_action_23 };
    } else {
      if (11 <= input && input <= 31) {
        return { _0: 46, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 };
      } else {
        if (input === 32) {
          return { _0: 45, _1: moonbitlang$yacc$lib$parser$$token_tag_action_23 };
        } else {
          return 33 <= input && input <= 57 ? { _0: 46, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 } : 59 <= input && input <= 127 ? { _0: 46, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_46(input) {
  return 1 <= input && input <= 57 ? { _0: 58, _1: moonbitlang$yacc$lib$parser$$token_tag_action_30 } : 59 <= input && input <= 127 ? { _0: 58, _1: moonbitlang$yacc$lib$parser$$token_tag_action_30 } : { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_47(input) {
  if (input === 104) {
    return { _0: 59, _1: moonbitlang$yacc$lib$parser$$token_tag_action_17 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_48(input) {
  if (input === 99) {
    return { _0: 60, _1: moonbitlang$yacc$lib$parser$$token_tag_action_31 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_49(input) {
  if (input === 105) {
    return { _0: 61, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_50(input) {
  if (input === 116) {
    return { _0: 62, _1: moonbitlang$yacc$lib$parser$$token_tag_action_1 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_51(input) {
  if (input === 114) {
    return { _0: 63, _1: moonbitlang$yacc$lib$parser$$token_tag_action_18 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_52(input) {
  if (input === 105) {
    return { _0: 64, _1: moonbitlang$yacc$lib$parser$$token_tag_action_13 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_53(input) {
  if (input === 101) {
    return { _0: 65, _1: moonbitlang$yacc$lib$parser$$token_tag_action_32 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_54(input) {
  if (input === 101) {
    return { _0: 66, _1: moonbitlang$yacc$lib$parser$$token_tag_action_26 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_55(input) {
  if (input === 97) {
    return { _0: 67, _1: moonbitlang$yacc$lib$parser$$token_tag_action_15 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_56(input) {
  return 1 <= input && input <= 41 ? { _0: 57, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 } : 43 <= input && input <= 127 ? { _0: 57, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 } : { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_57(input) {
  if (1 <= input && input <= 41) {
    return { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
  } else {
    if (input === 42) {
      return { _0: 42, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
    } else {
      if (43 <= input && input <= 46) {
        return { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
      } else {
        if (input === 47) {
          return { _0: 44, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 };
        } else {
          return 48 <= input && input <= 127 ? { _0: 43, _1: moonbitlang$yacc$lib$parser$$token_tag_action_22 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_58(input) {
  if (1 <= input && input <= 8) {
    return { _0: 68, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 58, _1: moonbitlang$yacc$lib$parser$$token_tag_action_30 };
    } else {
      if (11 <= input && input <= 31) {
        return { _0: 68, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 };
      } else {
        if (input === 32) {
          return { _0: 58, _1: moonbitlang$yacc$lib$parser$$token_tag_action_30 };
        } else {
          return 33 <= input && input <= 57 ? { _0: 68, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 } : 59 <= input && input <= 127 ? { _0: 68, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_59(input) {
  if (input === 116) {
    return { _0: 69, _1: moonbitlang$yacc$lib$parser$$token_tag_action_0 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_60(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_61(input) {
  if (input === 116) {
    return { _0: 70, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_62(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_63(input) {
  if (input === 116) {
    return { _0: 71, _1: moonbitlang$yacc$lib$parser$$token_tag_action_20 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_64(input) {
  if (input === 118) {
    return { _0: 72, _1: moonbitlang$yacc$lib$parser$$token_tag_action_13 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_65(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_66(input) {
  if (input === 110) {
    return { _0: 73, _1: moonbitlang$yacc$lib$parser$$token_tag_action_33 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_67(input) {
  if (input === 115) {
    return { _0: 74, _1: moonbitlang$yacc$lib$parser$$token_tag_action_15 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_68(input) {
  if (1 <= input && input <= 8) {
    return { _0: 68, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 };
  } else {
    if (9 <= input && input <= 10) {
      return { _0: 58, _1: moonbitlang$yacc$lib$parser$$token_tag_action_30 };
    } else {
      if (11 <= input && input <= 31) {
        return { _0: 68, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 };
      } else {
        if (input === 32) {
          return { _0: 58, _1: moonbitlang$yacc$lib$parser$$token_tag_action_30 };
        } else {
          return 33 <= input && input <= 57 ? { _0: 68, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 } : 59 <= input && input <= 127 ? { _0: 68, _1: moonbitlang$yacc$lib$parser$$token_tag_action_29 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token_state_69(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_70(input) {
  if (input === 105) {
    return { _0: 75, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_71(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_72(input) {
  if (input === 101) {
    return { _0: 76, _1: moonbitlang$yacc$lib$parser$$token_tag_action_34 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_73(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_74(input) {
  if (input === 115) {
    return { _0: 77, _1: moonbitlang$yacc$lib$parser$$token_tag_action_15 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_75(input) {
  if (input === 111) {
    return { _0: 78, _1: moonbitlang$yacc$lib$parser$$token_tag_action_21 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_76(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_77(input) {
  if (input === 111) {
    return { _0: 79, _1: moonbitlang$yacc$lib$parser$$token_tag_action_15 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_78(input) {
  if (input === 110) {
    return { _0: 80, _1: moonbitlang$yacc$lib$parser$$token_tag_action_28 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_79(input) {
  if (input === 99) {
    return { _0: 81, _1: moonbitlang$yacc$lib$parser$$token_tag_action_35 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$token_state_80(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$token_state_81(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_eof_state_0(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_eof_state_1(input) {
  if (input === 0) {
    return { _0: 3, _1: moonbitlang$yacc$lib$parser$$code_eof_tag_action_0 };
  } else {
    return 1 <= input && input <= 127 ? { _0: 2, _1: moonbitlang$yacc$lib$parser$$code_eof_tag_action_1 } : $panic();
  }
}
function moonbitlang$yacc$lib$parser$$code_eof_state_2(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_eof_state_3(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_eof(sb, lexbuf) {
  let _tmp = sb;
  let _tmp$2 = lexbuf;
  _L: while (true) {
    const sb$2 = _tmp;
    const lexbuf$2 = _tmp$2;
    const _bind = moonbitlang$yacc$lib$parser$$LexEngine$run(moonbitlang$yacc$lib$parser$$__mbtlex_engine_code_eof, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        const _x$2 = _bind._1;
        const _bind$2 = moonbitlang$core$array$$Array$op_get$86$(_x$2, 0);
        const _x$3 = _bind$2._0;
        const _x$4 = _bind$2._1;
        const t = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$3, _x$4);
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, t);
        continue _L;
      }
      case 1: {
        return;
      }
      default: {
        moonbitlang$core$builtin$$abort$4$("lex: fail to match");
        return;
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_0(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_1(input) {
  if (input === 0) {
    return { _0: 4, _1: moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_0 };
  } else {
    if (1 <= input && input <= 36) {
      return { _0: 2, _1: moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_1 };
    } else {
      if (input === 37) {
        return { _0: 3, _1: moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_1 };
      } else {
        return 38 <= input && input <= 127 ? { _0: 2, _1: moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_1 } : $panic();
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_2(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_3(input) {
  if (input === 125) {
    return { _0: 5, _1: moonbitlang$yacc$lib$parser$$code_percent_rbrace_tag_action_0 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_4(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_percent_rbrace_state_5(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_percent_rbrace(sb, lexbuf) {
  let _tmp = sb;
  let _tmp$2 = lexbuf;
  _L: while (true) {
    const sb$2 = _tmp;
    const lexbuf$2 = _tmp$2;
    const _bind = moonbitlang$yacc$lib$parser$$LexEngine$run(moonbitlang$yacc$lib$parser$$__mbtlex_engine_code_percent_rbrace, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        return new Result$Ok$11$(undefined);
      }
      case 1: {
        const _x$2 = _bind._1;
        const _bind$2 = moonbitlang$core$array$$Array$op_get$86$(_x$2, 0);
        const _x$3 = _bind$2._0;
        const _x$4 = _bind$2._1;
        const t = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$3, _x$4);
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, t);
        continue _L;
      }
      case 2: {
        return new Result$Err$11$(Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile);
      }
      default: {
        return new Result$Ok$11$(moonbitlang$core$builtin$$abort$4$("lex: fail to match"));
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rangle_state_0(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rangle_state_1(input) {
  if (input === 0) {
    return { _0: 4, _1: moonbitlang$yacc$lib$parser$$code_rangle_tag_action_0 };
  } else {
    if (1 <= input && input <= 61) {
      return { _0: 2, _1: moonbitlang$yacc$lib$parser$$code_rangle_tag_action_1 };
    } else {
      if (input === 62) {
        return { _0: 3, _1: moonbitlang$yacc$lib$parser$$code_rangle_tag_action_1 };
      } else {
        return 63 <= input && input <= 127 ? { _0: 2, _1: moonbitlang$yacc$lib$parser$$code_rangle_tag_action_1 } : $panic();
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rangle_state_2(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rangle_state_3(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rangle_state_4(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rangle(sb, lexbuf) {
  let _tmp = sb;
  let _tmp$2 = lexbuf;
  _L: while (true) {
    const sb$2 = _tmp;
    const lexbuf$2 = _tmp$2;
    const _bind = moonbitlang$yacc$lib$parser$$LexEngine$run(moonbitlang$yacc$lib$parser$$__mbtlex_engine_code_rangle, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        return new Result$Ok$11$(undefined);
      }
      case 1: {
        const _x$2 = _bind._1;
        const _bind$2 = moonbitlang$core$array$$Array$op_get$86$(_x$2, 0);
        const _x$3 = _bind$2._0;
        const _x$4 = _bind$2._1;
        const t = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$3, _x$4);
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, t);
        continue _L;
      }
      case 2: {
        return new Result$Err$11$(Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile);
      }
      default: {
        return new Result$Ok$11$(moonbitlang$core$builtin$$abort$4$("lex: fail to match"));
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_0(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_1(input) {
  if (input === 0) {
    return { _0: 5, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_0 };
  } else {
    if (1 <= input && input <= 35) {
      return { _0: 6, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_1 };
    } else {
      if (input === 36) {
        return { _0: 2, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_2 };
      } else {
        if (37 <= input && input <= 122) {
          return { _0: 6, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_1 };
        } else {
          switch (input) {
            case 123: {
              return { _0: 3, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_1 };
            }
            case 124: {
              return { _0: 6, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_1 };
            }
            case 125: {
              return { _0: 4, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_1 };
            }
            default: {
              return 126 <= input && input <= 127 ? { _0: 6, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_1 } : $panic();
            }
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_10(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 107) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 108) {
            return { _0: 16, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            if (109 <= input && input <= 115) {
              return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
            } else {
              if (input === 116) {
                return { _0: 15, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
              } else {
                if (117 <= input && input <= 120) {
                  return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
                } else {
                  switch (input) {
                    case 121: {
                      return { _0: 17, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
                    }
                    case 122: {
                      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
                    }
                    default: {
                      return { _0: 0, _1: [] };
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_11(input) {
  return 48 <= input && input <= 57 ? { _0: 11, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_3 } : { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_12(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_13(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 99) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 100) {
            return { _0: 18, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            return 101 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_14(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 98) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 99) {
            return { _0: 19, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_7 };
          } else {
            return 100 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_15(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      switch (input) {
        case 95: {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        }
        case 97: {
          return { _0: 20, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
        }
        default: {
          return 98 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_16(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 110) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 111) {
            return { _0: 21, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 112 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_17(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 108) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 109) {
            return { _0: 22, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 110 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_18(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 111) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 112) {
            return { _0: 23, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            return 113 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_19(input) {
  if (input === 40) {
    return { _0: 24, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_8 };
  } else {
    if (48 <= input && input <= 57) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (65 <= input && input <= 90) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (input === 95) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          return 97 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_2(input) {
  if (48 <= input && input <= 57) {
    return { _0: 11, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_3 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 7, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 7, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 100) {
          return { _0: 7, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 101) {
            return { _0: 8, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            if (102 <= input && input <= 107) {
              return { _0: 7, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
            } else {
              if (input === 108) {
                return { _0: 9, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
              } else {
                if (109 <= input && input <= 114) {
                  return { _0: 7, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
                } else {
                  if (input === 115) {
                    return { _0: 10, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
                  } else {
                    return 116 <= input && input <= 122 ? { _0: 7, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_20(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 113) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 114) {
            return { _0: 25, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            return 115 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_21(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 98) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 99) {
            return { _0: 26, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_9 };
          } else {
            return 100 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_22(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      switch (input) {
        case 95: {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        }
        case 97: {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        }
        case 98: {
          return { _0: 27, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
        }
        default: {
          return 99 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_23(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 110) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 111) {
            return { _0: 28, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            return 112 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_24(input) {
  switch (input) {
    case 9: {
      return { _0: 29, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_8 };
    }
    case 32: {
      return { _0: 29, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_8 };
    }
    case 36: {
      return { _0: 30, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_10 };
    }
    default: {
      return { _0: 0, _1: [] };
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_25(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 115) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 116) {
            return { _0: 31, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            return 117 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_26(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_27(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 110) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 111) {
            return { _0: 32, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 112 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_28(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 114) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 115) {
            return { _0: 33, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_7 };
          } else {
            return 116 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_29(input) {
  switch (input) {
    case 9: {
      return { _0: 29, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_8 };
    }
    case 32: {
      return { _0: 29, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_8 };
    }
    case 36: {
      return { _0: 30, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_10 };
    }
    default: {
      return { _0: 0, _1: [] };
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_3(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_30(input) {
  if (48 <= input && input <= 57) {
    return { _0: 34, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 35, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
    } else {
      if (input === 95) {
        return { _0: 35, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 35, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 } : { _0: 0, _1: [] };
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_31(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 111) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 112) {
            return { _0: 36, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            return 113 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_32(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 107) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 108) {
            return { _0: 37, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 109 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_33(input) {
  if (input === 40) {
    return { _0: 24, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_8 };
  } else {
    if (48 <= input && input <= 57) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (65 <= input && input <= 90) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (input === 95) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          return 97 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_34(input) {
  switch (input) {
    case 9: {
      return { _0: 39, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_12 };
    }
    case 32: {
      return { _0: 39, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_12 };
    }
    case 41: {
      return { _0: 38, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_13 };
    }
    default: {
      if (48 <= input && input <= 57) {
        return { _0: 34, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
      } else {
        if (65 <= input && input <= 90) {
          return { _0: 35, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
        } else {
          if (input === 95) {
            return { _0: 35, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
          } else {
            return 97 <= input && input <= 122 ? { _0: 35, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_35(input) {
  switch (input) {
    case 9: {
      return { _0: 39, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_12 };
    }
    case 32: {
      return { _0: 39, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_12 };
    }
    case 41: {
      return { _0: 38, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_13 };
    }
    default: {
      if (48 <= input && input <= 57) {
        return { _0: 40, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
      } else {
        if (65 <= input && input <= 90) {
          return { _0: 40, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
        } else {
          if (input === 95) {
            return { _0: 40, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
          } else {
            return 97 <= input && input <= 122 ? { _0: 40, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_36(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 110) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 111) {
            return { _0: 41, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            return 112 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_37(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 114) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 115) {
            return { _0: 42, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 116 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_38(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_39(input) {
  switch (input) {
    case 9: {
      return { _0: 39, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_12 };
    }
    case 32: {
      return { _0: 39, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_12 };
    }
    case 41: {
      return { _0: 38, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_13 };
    }
    default: {
      return { _0: 0, _1: [] };
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_4(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_40(input) {
  switch (input) {
    case 9: {
      return { _0: 39, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_12 };
    }
    case 32: {
      return { _0: 39, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_12 };
    }
    case 41: {
      return { _0: 38, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_13 };
    }
    default: {
      if (48 <= input && input <= 57) {
        return { _0: 40, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
      } else {
        if (65 <= input && input <= 90) {
          return { _0: 40, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
        } else {
          if (input === 95) {
            return { _0: 40, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 };
          } else {
            return 97 <= input && input <= 122 ? { _0: 40, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_11 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_41(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 114) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 115) {
            return { _0: 43, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_7 };
          } else {
            return 116 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_42(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 115) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 116) {
            return { _0: 44, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 117 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_43(input) {
  if (input === 40) {
    return { _0: 24, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_8 };
  } else {
    if (48 <= input && input <= 57) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (65 <= input && input <= 90) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (input === 95) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          return 97 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_44(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      switch (input) {
        case 95: {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        }
        case 97: {
          return { _0: 45, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
        }
        default: {
          return 98 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_45(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 113) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 114) {
            return { _0: 46, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 115 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_46(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 115) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 116) {
            return { _0: 47, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 117 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_47(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 111) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 112) {
            return { _0: 48, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 113 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_48(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 110) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 111) {
            return { _0: 49, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_6 };
          } else {
            return 112 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_49(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 114) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 115) {
            return { _0: 50, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_9 };
          } else {
            return 116 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_5(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_50(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_6(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_7(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        return 97 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_8(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 109) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 110) {
            return { _0: 13, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            return 111 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace_state_9(input) {
  if (48 <= input && input <= 57) {
    return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
  } else {
    if (65 <= input && input <= 90) {
      return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
    } else {
      if (input === 95) {
        return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
      } else {
        if (97 <= input && input <= 110) {
          return { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 };
        } else {
          if (input === 111) {
            return { _0: 14, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_5 };
          } else {
            return 112 <= input && input <= 122 ? { _0: 12, _1: moonbitlang$yacc$lib$parser$$code_rbrace_tag_action_4 } : { _0: 0, _1: [] };
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$code_rbrace(sb, subst, base, lexbuf) {
  let _tmp = sb;
  let _tmp$2 = subst;
  let _tmp$3 = base;
  let _tmp$4 = lexbuf;
  _L: while (true) {
    const sb$2 = _tmp;
    const subst$2 = _tmp$2;
    const base$2 = _tmp$3;
    const lexbuf$2 = _tmp$4;
    const _bind = moonbitlang$yacc$lib$parser$$LexEngine$run(moonbitlang$yacc$lib$parser$$__mbtlex_engine_code_rbrace, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, "{");
        const _bind$2 = moonbitlang$yacc$lib$parser$$code_rbrace(sb$2, subst$2, base$2, lexbuf$2);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          _ok._0;
        } else {
          return _bind$2;
        }
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, "}");
        continue _L;
      }
      case 1: {
        return new Result$Ok$11$(undefined);
      }
      case 2: {
        const _x$2 = _bind._1;
        const _bind$3 = moonbitlang$core$array$$Array$op_get$86$(_x$2, 0);
        const _x$3 = _bind$3._0;
        const _x$4 = _bind$3._1;
        const t = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$3, _x$4);
        const _bind$4 = moonbitlang$core$array$$Array$op_get$86$(_x$2, 1);
        const _x$5 = _bind$4._0;
        const _x$6 = _bind$4._1;
        const t1 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$5, _x$6);
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, t);
        let index;
        let _try_err;
        _L$2: {
          _L$3: {
            const _bind$5 = moonbitlang$core$strconv$$parse_int(t1, 10);
            if (_bind$5.$tag === 1) {
              const _ok = _bind$5;
              index = _ok._0;
            } else {
              const _err = _bind$5;
              const _tmp$5 = _err._0;
              _try_err = _tmp$5;
              break _L$3;
            }
            break _L$2;
          }
          index = moonbitlang$core$builtin$$abort$28$(moonbitlang$core$builtin$$Show$to_string$1$(_try_err));
        }
        moonbitlang$core$array$$Array$push$117$(subst$2, { start: _x$3 - base$2 | 0, end: _x$4 - base$2 | 0, desc: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$Dollar(index) });
        continue _L;
      }
      case 3: {
        const _x$7 = _bind._1;
        const _bind$5 = moonbitlang$core$array$$Array$op_get$86$(_x$7, 0);
        const _x$8 = _bind$5._0;
        const _x$9 = _bind$5._1;
        const t$2 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$8, _x$9);
        const _bind$6 = moonbitlang$core$array$$Array$op_get$86$(_x$7, 1);
        const _x$10 = _bind$6._0;
        const _x$11 = _bind$6._1;
        const t1$2 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$10, _x$11);
        const _bind$7 = moonbitlang$core$array$$Array$op_get$86$(_x$7, 2);
        const _x$12 = _bind$7._0;
        const _x$13 = _bind$7._1;
        const t2 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$12, _x$13);
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, t$2);
        let arg;
        if (moonbitlang$core$string$$String$starts_with(t2, "$")) {
          let index$2;
          let _try_err$2;
          _L$3: {
            _L$4: {
              const _bind$8 = moonbitlang$core$strconv$$parse_int(moonbitlang$core$string$$String$substring(t2, 1, undefined), 10);
              if (_bind$8.$tag === 1) {
                const _ok = _bind$8;
                index$2 = _ok._0;
              } else {
                const _err = _bind$8;
                const _tmp$5 = _err._0;
                _try_err$2 = _tmp$5;
                break _L$4;
              }
              break _L$3;
            }
            index$2 = moonbitlang$core$builtin$$abort$28$(moonbitlang$core$builtin$$Show$to_string$1$(_try_err$2));
          }
          arg = new $64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemIdent$Dollar(index$2);
        } else {
          arg = new $64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemIdent$Name(t2);
        }
        const _tmp$5 = _x$8 - base$2 | 0;
        const _tmp$6 = _x$9 - base$2 | 0;
        let _tmp$7;
        switch (t1$2) {
          case "startpos": {
            _tmp$7 = new $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$StartPosOf(arg);
            break;
          }
          case "endpos": {
            _tmp$7 = new $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$EndPosOf(arg);
            break;
          }
          case "loc": {
            _tmp$7 = new $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$LocOf(arg);
            break;
          }
          default: {
            _tmp$7 = $panic();
          }
        }
        moonbitlang$core$array$$Array$push$117$(subst$2, { start: _tmp$5, end: _tmp$6, desc: _tmp$7 });
        continue _L;
      }
      case 4: {
        const _x$14 = _bind._1;
        const _bind$8 = moonbitlang$core$array$$Array$op_get$86$(_x$14, 0);
        const _x$15 = _bind$8._0;
        const _x$16 = _bind$8._1;
        const t$3 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$15, _x$16);
        const _bind$9 = moonbitlang$core$array$$Array$op_get$86$(_x$14, 1);
        const _x$17 = _bind$9._0;
        const _x$18 = _bind$9._1;
        const t1$3 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$17, _x$18);
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, t$3);
        const _tmp$8 = _x$15 - base$2 | 0;
        const _tmp$9 = _x$16 - base$2 | 0;
        let _tmp$10;
        switch (t1$3) {
          case "startpos": {
            _tmp$10 = $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$StartPos;
            break;
          }
          case "endpos": {
            _tmp$10 = $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$EndPos;
            break;
          }
          case "loc": {
            _tmp$10 = $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$Loc;
            break;
          }
          case "symbolstartpos": {
            _tmp$10 = $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$SymbolStartPos;
            break;
          }
          case "sloc": {
            _tmp$10 = $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$Sloc;
            break;
          }
          default: {
            _tmp$10 = $panic();
          }
        }
        moonbitlang$core$array$$Array$push$117$(subst$2, { start: _tmp$8, end: _tmp$9, desc: _tmp$10 });
        continue _L;
      }
      case 5: {
        const _x$19 = _bind._1;
        const _bind$10 = moonbitlang$core$array$$Array$op_get$86$(_x$19, 0);
        const _x$20 = _bind$10._0;
        const _x$21 = _bind$10._1;
        const t$4 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$20, _x$21);
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, t$4);
        continue _L;
      }
      case 6: {
        const _x$22 = _bind._1;
        const _bind$11 = moonbitlang$core$array$$Array$op_get$86$(_x$22, 0);
        const _x$23 = _bind$11._0;
        const _x$24 = _bind$11._1;
        const t$5 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$23, _x$24);
        moonbitlang$core$builtin$$StringBuilder$write_string(sb$2, t$5);
        continue _L;
      }
      case 7: {
        return new Result$Err$11$(Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile);
      }
      default: {
        return new Result$Ok$11$(moonbitlang$core$builtin$$abort$4$("lex: fail to match"));
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen_state_0(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen_state_1(input) {
  if (input === 0) {
    return { _0: 5, _1: moonbitlang$yacc$lib$parser$$comment_star_rparen_tag_action_0 };
  } else {
    if (1 <= input && input <= 39) {
      return { _0: 4, _1: moonbitlang$yacc$lib$parser$$comment_star_rparen_tag_action_0 };
    } else {
      switch (input) {
        case 40: {
          return { _0: 2, _1: moonbitlang$yacc$lib$parser$$comment_star_rparen_tag_action_0 };
        }
        case 41: {
          return { _0: 4, _1: moonbitlang$yacc$lib$parser$$comment_star_rparen_tag_action_0 };
        }
        case 42: {
          return { _0: 3, _1: moonbitlang$yacc$lib$parser$$comment_star_rparen_tag_action_0 };
        }
        default: {
          return 43 <= input && input <= 127 ? { _0: 4, _1: moonbitlang$yacc$lib$parser$$comment_star_rparen_tag_action_0 } : $panic();
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen_state_2(input) {
  if (input === 42) {
    return { _0: 6, _1: moonbitlang$yacc$lib$parser$$comment_star_rparen_tag_action_0 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen_state_3(input) {
  if (input === 41) {
    return { _0: 7, _1: moonbitlang$yacc$lib$parser$$comment_star_rparen_tag_action_0 };
  } else {
    return { _0: 0, _1: [] };
  }
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen_state_4(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen_state_5(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen_state_6(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen_state_7(input) {
  return { _0: 0, _1: [] };
}
function moonbitlang$yacc$lib$parser$$comment_star_rparen(lexbuf) {
  let _tmp = lexbuf;
  _L: while (true) {
    const lexbuf$2 = _tmp;
    const _bind = moonbitlang$yacc$lib$parser$$LexEngine$run(moonbitlang$yacc$lib$parser$$__mbtlex_engine_comment_star_rparen, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        const _bind$2 = moonbitlang$yacc$lib$parser$$comment_star_rparen(lexbuf$2);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          _ok._0;
        } else {
          return _bind$2;
        }
        continue _L;
      }
      case 1: {
        return new Result$Ok$11$(undefined);
      }
      case 2: {
        continue _L;
      }
      case 3: {
        return new Result$Err$11$(Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$UnexpectedEndOfFile);
      }
      default: {
        return new Result$Ok$11$(moonbitlang$core$builtin$$abort$4$("lex: fail to match"));
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$token(phase, lexbuf) {
  let _tmp = phase;
  let _tmp$2 = lexbuf;
  _L: while (true) {
    const phase$2 = _tmp;
    const lexbuf$2 = _tmp$2;
    const _bind = moonbitlang$yacc$lib$parser$$LexEngine$run(moonbitlang$yacc$lib$parser$$__mbtlex_engine_token, lexbuf$2);
    const _x = _bind._0;
    switch (_x) {
      case 0: {
        continue _L;
      }
      case 1: {
        continue _L;
      }
      case 2: {
        const _bind$2 = moonbitlang$yacc$lib$parser$$comment_star_rparen(lexbuf$2);
        if (_bind$2.$tag === 1) {
          const _ok = _bind$2;
          _ok._0;
        } else {
          return _bind$2;
        }
        continue _L;
      }
      case 3: {
        continue _L;
      }
      case 4: {
        const _x$2 = _bind._1;
        const _bind$3 = moonbitlang$core$array$$Array$op_get$86$(_x$2, 0);
        const _x$3 = _bind$3._0;
        const _x$4 = _bind$3._1;
        const t = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$3, _x$4);
        return new Result$Ok$12$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$IDENT(t), _1: _x$3, _2: _x$4 });
      }
      case 5: {
        const _x$5 = _bind._1;
        const _bind$4 = moonbitlang$core$array$$Array$op_get$86$(_x$5, 0);
        const _x$6 = _bind$4._0;
        const _x$7 = _bind$4._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$6, _x$7);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_START, _1: _x$6, _2: _x$7 });
      }
      case 6: {
        const _x$8 = _bind._1;
        const _bind$5 = moonbitlang$core$array$$Array$op_get$86$(_x$8, 0);
        const _x$9 = _bind$5._0;
        const _x$10 = _bind$5._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$9, _x$10);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_TOKEN, _1: _x$9, _2: _x$10 });
      }
      case 7: {
        const _x$11 = _bind._1;
        const _bind$6 = moonbitlang$core$array$$Array$op_get$86$(_x$11, 0);
        const _x$12 = _bind$6._0;
        const _x$13 = _bind$6._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$12, _x$13);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_TYPE, _1: _x$12, _2: _x$13 });
      }
      case 8: {
        const _x$14 = _bind._1;
        const _bind$7 = moonbitlang$core$array$$Array$op_get$86$(_x$14, 0);
        const _x$15 = _bind$7._0;
        const _x$16 = _bind$7._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$15, _x$16);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_POSITION, _1: _x$15, _2: _x$16 });
      }
      case 9: {
        const _x$17 = _bind._1;
        const _bind$8 = moonbitlang$core$array$$Array$op_get$86$(_x$17, 0);
        const _x$18 = _bind$8._0;
        const _x$19 = _bind$8._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$18, _x$19);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LEFT, _1: _x$18, _2: _x$19 });
      }
      case 10: {
        const _x$20 = _bind._1;
        const _bind$9 = moonbitlang$core$array$$Array$op_get$86$(_x$20, 0);
        const _x$21 = _bind$9._0;
        const _x$22 = _bind$9._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$21, _x$22);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_RIGHT, _1: _x$21, _2: _x$22 });
      }
      case 11: {
        const _x$23 = _bind._1;
        const _bind$10 = moonbitlang$core$array$$Array$op_get$86$(_x$23, 0);
        const _x$24 = _bind$10._0;
        const _x$25 = _bind$10._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$24, _x$25);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_NONASSOC, _1: _x$24, _2: _x$25 });
      }
      case 12: {
        const _x$26 = _bind._1;
        const _bind$11 = moonbitlang$core$array$$Array$op_get$86$(_x$26, 0);
        const _x$27 = _bind$11._0;
        const _x$28 = _bind$11._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$27, _x$28);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PREC, _1: _x$27, _2: _x$28 });
      }
      case 13: {
        const _x$29 = _bind._1;
        const _bind$12 = moonbitlang$core$array$$Array$op_get$86$(_x$29, 0);
        const _x$30 = _bind$12._0;
        const _x$31 = _bind$12._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$30, _x$31);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_DERIVE, _1: _x$30, _2: _x$31 });
      }
      case 14: {
        const _x$32 = _bind._1;
        const _bind$13 = moonbitlang$core$array$$Array$op_get$86$(_x$32, 0);
        const _x$33 = _bind$13._0;
        const _x$34 = _bind$13._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$33, _x$34);
        if (phase$2.val <= 0) {
          phase$2.val = phase$2.val + 1 | 0;
          return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT, _1: _x$33, _2: _x$34 });
        } else {
          phase$2.val = phase$2.val + 1 | 0;
          const sb = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
          moonbitlang$yacc$lib$parser$$code_eof(sb, lexbuf$2);
          return new Result$Ok$12$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_PERCENT_CODE_EOF(moonbitlang$core$builtin$$StringBuilder$to_string(sb)), _1: _x$33, _2: _x$34 });
        }
      }
      case 15: {
        const _x$35 = _bind._1;
        const _bind$14 = moonbitlang$core$array$$Array$op_get$86$(_x$35, 0);
        const _x$36 = _bind$14._0;
        const _x$37 = _bind$14._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$36, _x$37);
        const _bind$15 = moonbitlang$core$array$$Array$op_get$86$(_x$35, 1);
        const _x$38 = _bind$15._0;
        const _x$39 = _bind$15._1;
        const t2 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$38, _x$39);
        return new Result$Ok$12$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$ARROW_CODE(t2), _1: _x$36, _2: _x$37 });
      }
      case 16: {
        const _x$40 = _bind._1;
        const _bind$16 = moonbitlang$core$array$$Array$op_get$86$(_x$40, 0);
        const _x$41 = _bind$16._0;
        const _x$42 = _bind$16._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$41, _x$42);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$COLON, _1: _x$41, _2: _x$42 });
      }
      case 17: {
        const _x$43 = _bind._1;
        const _bind$17 = moonbitlang$core$array$$Array$op_get$86$(_x$43, 0);
        const _x$44 = _bind$17._0;
        const _x$45 = _bind$17._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$44, _x$45);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$BAR, _1: _x$44, _2: _x$45 });
      }
      case 18: {
        const _x$46 = _bind._1;
        const _bind$18 = moonbitlang$core$array$$Array$op_get$86$(_x$46, 0);
        const _x$47 = _bind$18._0;
        const _x$48 = _bind$18._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$47, _x$48);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$EQ, _1: _x$47, _2: _x$48 });
      }
      case 19: {
        const _x$49 = _bind._1;
        const _bind$19 = moonbitlang$core$array$$Array$op_get$86$(_x$49, 0);
        const _x$50 = _bind$19._0;
        const _x$51 = _bind$19._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$50, _x$51);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$SEMI, _1: _x$50, _2: _x$51 });
      }
      case 20: {
        const _x$52 = _bind._1;
        const _bind$20 = moonbitlang$core$array$$Array$op_get$86$(_x$52, 0);
        const _x$53 = _bind$20._0;
        const _x$54 = _bind$20._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$53, _x$54);
        const sb = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
        const _bind$21 = moonbitlang$yacc$lib$parser$$code_percent_rbrace(sb, lexbuf$2);
        if (_bind$21.$tag === 1) {
          const _ok = _bind$21;
          _ok._0;
        } else {
          return _bind$21;
        }
        return new Result$Ok$12$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$PERCENT_LBRACE_CODE_PERCENT_RBRACE(moonbitlang$core$builtin$$StringBuilder$to_string(sb)), _1: _x$53, _2: _x$54 });
      }
      case 21: {
        const _x$55 = _bind._1;
        const _bind$22 = moonbitlang$core$array$$Array$op_get$86$(_x$55, 0);
        const _x$56 = _bind$22._0;
        const _x$57 = _bind$22._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$56, _x$57);
        const sb$2 = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
        const _bind$23 = moonbitlang$yacc$lib$parser$$code_rangle(sb$2, lexbuf$2);
        if (_bind$23.$tag === 1) {
          const _ok = _bind$23;
          _ok._0;
        } else {
          return _bind$23;
        }
        return new Result$Ok$12$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LANGLE_CODE_RANGLE(moonbitlang$core$builtin$$StringBuilder$to_string(sb$2)), _1: _x$56, _2: _x$57 });
      }
      case 22: {
        const _x$58 = _bind._1;
        const _bind$24 = moonbitlang$core$array$$Array$op_get$86$(_x$58, 0);
        const _x$59 = _bind$24._0;
        const _x$60 = _bind$24._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$59, _x$60);
        const sb$3 = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
        const subst = [];
        const base = lexbuf$2.pos;
        const _bind$25 = moonbitlang$yacc$lib$parser$$code_rbrace(sb$3, subst, base, lexbuf$2);
        if (_bind$25.$tag === 1) {
          const _ok = _bind$25;
          _ok._0;
        } else {
          return _bind$25;
        }
        return new Result$Ok$12$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$LBRACE_CODE_RBRACE({ _0: moonbitlang$core$builtin$$StringBuilder$to_string(sb$3), _1: base, _2: subst }), _1: _x$59, _2: lexbuf$2.pos });
      }
      case 23: {
        const _x$61 = _bind._1;
        const _bind$26 = moonbitlang$core$array$$Array$op_get$86$(_x$61, 0);
        const _x$62 = _bind$26._0;
        const _x$63 = _bind$26._1;
        const t$2 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$62, _x$63);
        return new Result$Ok$12$({ _0: new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$STRING(t$2), _1: _x$62, _2: _x$63 });
      }
      case 24: {
        const _x$64 = _bind._1;
        const _bind$27 = moonbitlang$core$array$$Array$op_get$86$(_x$64, 0);
        const _x$65 = _bind$27._0;
        const _x$66 = _bind$27._1;
        const t$3 = moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$65, _x$66);
        return new Result$Err$12$(new Error$moonbitlang$47$yacc$47$lib$47$parser$46$LexError$46$Unrecognized(t$3));
      }
      case 25: {
        const _x$67 = _bind._1;
        const _bind$28 = moonbitlang$core$array$$Array$op_get$86$(_x$67, 0);
        const _x$68 = _bind$28._0;
        const _x$69 = _bind$28._1;
        moonbitlang$yacc$lib$parser$$Lexbuf$substring(lexbuf$2, _x$68, _x$69);
        return new Result$Ok$12$({ _0: $64$moonbitlang$47$yacc$47$lib$47$parser$46$Token$EOF, _1: _x$68, _2: _x$69 });
      }
      default: {
        return new Result$Ok$12$(moonbitlang$core$builtin$$abort$11$("lex: fail to match"));
      }
    }
  }
}
function moonbitlang$yacc$lib$parser$$new_lexer(input) {
  return { buf: moonbitlang$yacc$lib$parser$$Lexbuf$from_string(input), phase: { val: 0 } };
}
function moonbitlang$yacc$lib$parser$$Lexer$next_token(self) {
  return moonbitlang$yacc$lib$parser$$token(self.phase, self.buf);
}
function moonbitlang$core$builtin$$Eq$op_equal$18$(_x_486, _x_487) {
  switch (_x_486.$tag) {
    case 0: {
      const _Dollar = _x_486;
      const _x = _Dollar._0;
      if (_x_487.$tag === 0) {
        const _Dollar$2 = _x_487;
        const _x$2 = _Dollar$2._0;
        return _x === _x$2;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_487.$tag === 1) {
        return true;
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_487.$tag === 2) {
        return true;
      } else {
        return false;
      }
    }
    case 3: {
      if (_x_487.$tag === 3) {
        return true;
      } else {
        return false;
      }
    }
    case 4: {
      const _StartPosOf = _x_486;
      const _x$2 = _StartPosOf._0;
      if (_x_487.$tag === 4) {
        const _StartPosOf$2 = _x_487;
        const _x$3 = _StartPosOf$2._0;
        return moonbitlang$core$builtin$$Eq$op_equal$156$(_x$2, _x$3);
      } else {
        return false;
      }
    }
    case 5: {
      const _EndPosOf = _x_486;
      const _x$3 = _EndPosOf._0;
      if (_x_487.$tag === 5) {
        const _EndPosOf$2 = _x_487;
        const _x$4 = _EndPosOf$2._0;
        return moonbitlang$core$builtin$$Eq$op_equal$156$(_x$3, _x$4);
      } else {
        return false;
      }
    }
    case 6: {
      const _LocOf = _x_486;
      const _x$4 = _LocOf._0;
      if (_x_487.$tag === 6) {
        const _LocOf$2 = _x_487;
        const _x$5 = _LocOf$2._0;
        return moonbitlang$core$builtin$$Eq$op_equal$156$(_x$4, _x$5);
      } else {
        return false;
      }
    }
    case 7: {
      if (_x_487.$tag === 7) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_487.$tag === 8) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$18$(_x_466, _x_467) {
  switch (_x_466.$tag) {
    case 0: {
      const _Dollar = _x_466;
      const _x = _Dollar._0;
      if (_x_467.$tag === 0) {
        const _Dollar$2 = _x_467;
        const _x$2 = _Dollar$2._0;
        return $compare_int(_x, _x$2);
      } else {
        return -1;
      }
    }
    case 1: {
      switch (_x_467.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 0;
        }
        default: {
          return -1;
        }
      }
    }
    case 2: {
      switch (_x_467.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 0;
        }
        default: {
          return -1;
        }
      }
    }
    case 3: {
      switch (_x_467.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 0;
        }
        default: {
          return -1;
        }
      }
    }
    case 4: {
      const _StartPosOf = _x_466;
      const _x$2 = _StartPosOf._0;
      switch (_x_467.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          const _StartPosOf$2 = _x_467;
          const _x$3 = _StartPosOf$2._0;
          return moonbitlang$core$builtin$$Compare$compare$156$(_x$2, _x$3);
        }
        default: {
          return -1;
        }
      }
    }
    case 5: {
      const _EndPosOf = _x_466;
      const _x$4 = _EndPosOf._0;
      switch (_x_467.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          return 1;
        }
        case 5: {
          const _EndPosOf$2 = _x_467;
          const _x$5 = _EndPosOf$2._0;
          return moonbitlang$core$builtin$$Compare$compare$156$(_x$4, _x$5);
        }
        default: {
          return -1;
        }
      }
    }
    case 6: {
      const _LocOf = _x_466;
      const _x$6 = _LocOf._0;
      switch (_x_467.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          return 1;
        }
        case 5: {
          return 1;
        }
        case 6: {
          const _LocOf$2 = _x_467;
          const _x$7 = _LocOf$2._0;
          return moonbitlang$core$builtin$$Compare$compare$156$(_x$6, _x$7);
        }
        default: {
          return -1;
        }
      }
    }
    case 7: {
      switch (_x_467.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          return 1;
        }
        case 5: {
          return 1;
        }
        case 6: {
          return 1;
        }
        case 7: {
          return 0;
        }
        default: {
          return -1;
        }
      }
    }
    default: {
      switch (_x_467.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        case 3: {
          return 1;
        }
        case 4: {
          return 1;
        }
        case 5: {
          return 1;
        }
        case 6: {
          return 1;
        }
        case 7: {
          return 1;
        }
        default: {
          return 0;
        }
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$156$(_x_423, _x_424) {
  if (_x_423.$tag === 0) {
    const _Dollar = _x_423;
    const _x = _Dollar._0;
    if (_x_424.$tag === 0) {
      const _Dollar$2 = _x_424;
      const _x$2 = _Dollar$2._0;
      return _x === _x$2;
    } else {
      return false;
    }
  } else {
    const _Name = _x_423;
    const _x = _Name._0;
    if (_x_424.$tag === 1) {
      const _Name$2 = _x_424;
      const _x$2 = _Name$2._0;
      return _x === _x$2;
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$156$(_x_411, _x_412) {
  if (_x_411.$tag === 0) {
    const _Dollar = _x_411;
    const _x = _Dollar._0;
    if (_x_412.$tag === 0) {
      const _Dollar$2 = _x_412;
      const _x$2 = _Dollar$2._0;
      return $compare_int(_x, _x$2);
    } else {
      return -1;
    }
  } else {
    const _Name = _x_411;
    const _x = _Name._0;
    if (_x_412.$tag === 0) {
      return 1;
    } else {
      const _Name$2 = _x_412;
      const _x$2 = _Name$2._0;
      return moonbitlang$core$string$$String$compare(_x, _x$2);
    }
  }
}
function moonbitlang$yacc$lib$parser$$Token$kind(self) {
  switch (self.$tag) {
    case 0: {
      return 0;
    }
    case 1: {
      return 1;
    }
    case 2: {
      return 2;
    }
    case 3: {
      return 3;
    }
    case 4: {
      return 4;
    }
    case 5: {
      return 5;
    }
    case 6: {
      return 6;
    }
    case 7: {
      return 7;
    }
    case 8: {
      return 8;
    }
    case 9: {
      return 9;
    }
    case 10: {
      return 10;
    }
    case 11: {
      return 11;
    }
    case 12: {
      return 12;
    }
    case 13: {
      return 13;
    }
    case 14: {
      return 14;
    }
    case 15: {
      return 15;
    }
    case 16: {
      return 16;
    }
    case 17: {
      return 17;
    }
    case 18: {
      return 18;
    }
    case 19: {
      return 19;
    }
    case 20: {
      return 20;
    }
    default: {
      return 21;
    }
  }
}
function moonbitlang$core$builtin$$Show$output$116$(self, logger) {
  let _tmp;
  switch (self) {
    case 0: {
      _tmp = "EOF";
      break;
    }
    case 1: {
      _tmp = "IDENT";
      break;
    }
    case 2: {
      _tmp = "STRING";
      break;
    }
    case 3: {
      _tmp = "LANGLE_CODE_RANGLE";
      break;
    }
    case 4: {
      _tmp = "LBRACE_CODE_RBRACE";
      break;
    }
    case 5: {
      _tmp = "PERCENT_LBRACE_CODE_PERCENT_RBRACE";
      break;
    }
    case 6: {
      _tmp = "ARROW_CODE";
      break;
    }
    case 7: {
      _tmp = "PERCENT_PERCENT_CODE_EOF";
      break;
    }
    case 8: {
      _tmp = "\"%%\"";
      break;
    }
    case 9: {
      _tmp = "\"%start\"";
      break;
    }
    case 10: {
      _tmp = "\"%token\"";
      break;
    }
    case 11: {
      _tmp = "\"%type\"";
      break;
    }
    case 12: {
      _tmp = "\"%position\"";
      break;
    }
    case 13: {
      _tmp = "\"%left\"";
      break;
    }
    case 14: {
      _tmp = "\"%right\"";
      break;
    }
    case 15: {
      _tmp = "\"%nonassoc\"";
      break;
    }
    case 16: {
      _tmp = "\"%prec\"";
      break;
    }
    case 17: {
      _tmp = "\"%derive\"";
      break;
    }
    case 18: {
      _tmp = "\":\"";
      break;
    }
    case 19: {
      _tmp = "\"|\"";
      break;
    }
    case 20: {
      _tmp = "\"=\"";
      break;
    }
    default: {
      _tmp = "\";\"";
    }
  }
  logger.method_0(logger.self, _tmp);
}
(() => {
})();
function moonbitlang$yacc$lib$parser$$yy_action_0(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 4) {
    const _YYObj_Code_ = _bind;
    const _x = _YYObj_Code_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
    if (_bind$2.$tag === 5) {
      const _YYObj__immut_list_T_Command_ = _bind$2;
      const _x$2 = _YYObj__immut_list_T_Command_._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 3)._0;
      if (_bind$3.$tag === 6) {
        const _YYObj__immut_list_T_Rule_ = _bind$3;
        const _x$3 = _YYObj__immut_list_T_Rule_._0;
        const _bind$4 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 4)._0;
        if (_bind$4.$tag === 4) {
          const _YYObj_Code_$2 = _bind$4;
          const _x$4 = _YYObj_Code_$2._0;
          return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ParserSpec$46$YYObj_ParserSpec({ header: _x, footer: _x$4, commands: moonbitlang$core$immut$list$$T$to_array$60$(_x$2), rules: moonbitlang$core$immut$list$$T$to_array$59$(_x$3) });
        } else {
          return $panic();
        }
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_1(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_2(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(undefined);
}
function moonbitlang$yacc$lib$parser$$yy_action_3(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_4(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_5(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(undefined);
}
function moonbitlang$yacc$lib$parser$$yy_action_6(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 9) {
    const _YYObj_Command = _bind;
    const _x = _YYObj_Command._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
    if (_bind$2.$tag === 5) {
      const _YYObj__immut_list_T_Command_ = _bind$2;
      const _x$2 = _YYObj__immut_list_T_Command_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Command_$46$YYObj__immut_list_T_Command_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$13$(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_7(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Command_$46$YYObj__immut_list_T_Command_($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$13$);
}
function moonbitlang$yacc$lib$parser$$yy_action_8(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 10) {
    const _YYObj__immut_list_T_Symbol_ = _bind;
    const _x = _YYObj__immut_list_T_Symbol_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Start(moonbitlang$core$immut$list$$T$to_array$7$(_x)));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_9(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 4) {
    const _YYObj_Code_ = _bind;
    const _x = _YYObj_Code_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 2)._0;
    if (_bind$2.$tag === 10) {
      const _YYObj__immut_list_T_Symbol_ = _bind$2;
      const _x$2 = _YYObj__immut_list_T_Symbol_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Token(moonbitlang$core$immut$list$$T$to_array$7$(_x$2), _x));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_10(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 4) {
    const _YYObj_Code_ = _bind;
    const _x = _YYObj_Code_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 2)._0;
    if (_bind$2.$tag === 11) {
      const _YYObj_Symbol = _bind$2;
      const _x$2 = _YYObj_Symbol._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 3)._0;
      if (_bind$3.$tag === 8) {
        const _YYObj_String = _bind$3;
        const _x$3 = _YYObj_String._0;
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Token1(_x$2, _x, _x$3));
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_11(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 2)._0;
    if (_bind$2.$tag === 10) {
      const _YYObj__immut_list_T_Symbol_ = _bind$2;
      const _x$2 = _YYObj__immut_list_T_Symbol_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Type(moonbitlang$core$immut$list$$T$to_array$7$(_x$2), _x));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_12(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Position(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_13(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 10) {
    const _YYObj__immut_list_T_Symbol_ = _bind;
    const _x = _YYObj__immut_list_T_Symbol_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Left(moonbitlang$core$immut$list$$T$to_array$7$(_x)));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_14(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 10) {
    const _YYObj__immut_list_T_Symbol_ = _bind;
    const _x = _YYObj__immut_list_T_Symbol_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Right(moonbitlang$core$immut$list$$T$to_array$7$(_x)));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_15(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 10) {
    const _YYObj__immut_list_T_Symbol_ = _bind;
    const _x = _YYObj__immut_list_T_Symbol_._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Nonassoc(moonbitlang$core$immut$list$$T$to_array$7$(_x)));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_16(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 2)._0;
    if (_bind$2.$tag === 8) {
      const _YYObj_String$2 = _bind$2;
      const _x$2 = _YYObj_String$2._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Command$46$YYObj_Command(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$Command$Derive(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_17(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_18(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(undefined);
}
function moonbitlang$yacc$lib$parser$$yy_action_19(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 12) {
    const _YYObj_Rule = _bind;
    const _x = _YYObj_Rule._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Rule_$46$YYObj__immut_list_T_Rule_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$14$(_x, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$14$));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_20(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 12) {
    const _YYObj_Rule = _bind;
    const _x = _YYObj_Rule._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
    if (_bind$2.$tag === 6) {
      const _YYObj__immut_list_T_Rule_ = _bind$2;
      const _x$2 = _YYObj__immut_list_T_Rule_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Rule_$46$YYObj__immut_list_T_Rule_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$14$(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_21(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 11) {
    const _YYObj_Symbol = _bind;
    const _x = _YYObj_Symbol._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
    if (_bind$2.$tag === 4) {
      const _YYObj_Code_ = _bind$2;
      const _x$2 = _YYObj_Code_._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 3)._0;
      if (_bind$3.$tag === 13) {
        const _YYObj__immut_list_T_Clause_ = _bind$3;
        const _x$3 = _YYObj__immut_list_T_Clause_._0;
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Rule$46$YYObj_Rule({ nonterminal: _x, type_: _x$2, clauses: moonbitlang$core$immut$list$$T$to_array$58$(_x$3) });
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_22(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_23(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Code_$46$YYObj_Code_(undefined);
}
function moonbitlang$yacc$lib$parser$$yy_action_24(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 14) {
    const _YYObj_Clause = _bind;
    const _x = _YYObj_Clause._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Clause_$46$YYObj__immut_list_T_Clause_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$15$(_x, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$15$));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_25(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 14) {
    const _YYObj_Clause = _bind;
    const _x = _YYObj_Clause._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 2)._0;
    if (_bind$2.$tag === 13) {
      const _YYObj__immut_list_T_Clause_ = _bind$2;
      const _x$2 = _YYObj__immut_list_T_Clause_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Clause_$46$YYObj__immut_list_T_Clause_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$15$(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_26(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 15) {
    const _YYObj__immut_list_T_ClauseItem_ = _bind;
    const _x = _YYObj__immut_list_T_ClauseItem_._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
    if (_bind$2.$tag === 16) {
      const _YYObj_Symbol_ = _bind$2;
      const _x$2 = _YYObj_Symbol_._0;
      const _bind$3 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 2)._0;
      if (_bind$3.$tag === 17) {
        const _YYObj_ClauseAction = _bind$3;
        const _x$3 = _YYObj_ClauseAction._0;
        return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Clause$46$YYObj_Clause({ items: moonbitlang$core$immut$list$$T$to_array$57$(_x), prec: _x$2, action: _x$3 });
      } else {
        return $panic();
      }
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_27(_last_pos, _args) {
  const _start_pos = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._1;
  const _end_pos = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._2;
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 18) {
    const _YYObj__String__Int__Array_SubstItem__ = _bind;
    const _x = _YYObj__String__Int__Array_SubstItem__._0;
    const _x$2 = _x._0;
    const _x$3 = _x._1;
    const _x$4 = _x._2;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseAction$46$YYObj_ClauseAction({ code: { code: _x$2, utf8_pos: _x$3, subst: _x$4 }, start: _start_pos, end: _end_pos });
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_28(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseAction$46$YYObj_ClauseAction({ code: undefined, start: _last_pos, end: _last_pos });
}
function moonbitlang$yacc$lib$parser$$yy_action_29(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
  if (_bind.$tag === 11) {
    const _YYObj_Symbol = _bind;
    const _x = _YYObj_Symbol._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Symbol_$46$YYObj_Symbol_(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_30(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Symbol_$46$YYObj_Symbol_(undefined);
}
function moonbitlang$yacc$lib$parser$$yy_action_31(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 19) {
    const _YYObj_ClauseItem = _bind;
    const _x = _YYObj_ClauseItem._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
    if (_bind$2.$tag === 15) {
      const _YYObj__immut_list_T_ClauseItem_ = _bind$2;
      const _x$2 = _YYObj__immut_list_T_ClauseItem_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_ClauseItem_$46$YYObj__immut_list_T_ClauseItem_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$16$(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_32(_last_pos, _args) {
  return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_ClauseItem_$46$YYObj__immut_list_T_ClauseItem_($64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$16$);
}
function moonbitlang$yacc$lib$parser$$yy_action_33(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 20) {
    const _YYObj_ClauseItemSymbol = _bind;
    const _x = _YYObj_ClauseItemSymbol._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseItem$46$YYObj_ClauseItem({ binder: undefined, symbol: _x });
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_34(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 2)._0;
    if (_bind$2.$tag === 20) {
      const _YYObj_ClauseItemSymbol = _bind$2;
      const _x$2 = _YYObj_ClauseItemSymbol._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseItem$46$YYObj_ClauseItem({ binder: _x, symbol: _x$2 });
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_35(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 11) {
    const _YYObj_Symbol = _bind;
    const _x = _YYObj_Symbol._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseItemSymbol$46$YYObj_ClauseItemSymbol(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemSymbol$Symbol(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_36(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_ClauseItemSymbol$46$YYObj_ClauseItemSymbol(new $64$moonbitlang$47$yacc$47$lib$47$parser$46$ClauseItemSymbol$Image(_x));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_37(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 11) {
    const _YYObj_Symbol = _bind;
    const _x = _YYObj_Symbol._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Symbol_$46$YYObj__immut_list_T_Symbol_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$17$(_x, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$17$));
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_38(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 11) {
    const _YYObj_Symbol = _bind;
    const _x = _YYObj_Symbol._0;
    const _bind$2 = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 1)._0;
    if (_bind$2.$tag === 10) {
      const _YYObj__immut_list_T_Symbol_ = _bind$2;
      const _x$2 = _YYObj__immut_list_T_Symbol_._0;
      return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__immut_list_T_Symbol_$46$YYObj__immut_list_T_Symbol_(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$17$(_x, _x$2));
    } else {
      return $panic();
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_action_39(_last_pos, _args) {
  const _bind = moonbitlang$core$array$$ArrayView$op_get$73$(_args, 0)._0;
  if (_bind.$tag === 8) {
    const _YYObj_String = _bind;
    const _x = _YYObj_String._0;
    return new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Symbol$46$YYObj_Symbol(_x);
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$parser$$yy_input(token, _start_pos, _end_pos) {
  switch (token.$tag) {
    case 0: {
      return { _0: 0, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 1: {
      const _IDENT = token;
      const _x = _IDENT._0;
      return { _0: 1, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x) };
    }
    case 2: {
      const _STRING = token;
      const _x$2 = _STRING._0;
      return { _0: 2, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x$2) };
    }
    case 3: {
      const _LANGLE_CODE_RANGLE = token;
      const _x$3 = _LANGLE_CODE_RANGLE._0;
      return { _0: 3, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x$3) };
    }
    case 4: {
      const _LBRACE_CODE_RBRACE = token;
      const _x$4 = _LBRACE_CODE_RBRACE._0;
      return { _0: 4, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj__String__Int__Array_SubstItem__$46$YYObj__String__Int__Array_SubstItem__(_x$4) };
    }
    case 5: {
      const _PERCENT_LBRACE_CODE_PERCENT_RBRACE = token;
      const _x$5 = _PERCENT_LBRACE_CODE_PERCENT_RBRACE._0;
      return { _0: 5, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x$5) };
    }
    case 6: {
      const _ARROW_CODE = token;
      const _x$6 = _ARROW_CODE._0;
      return { _0: 6, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x$6) };
    }
    case 7: {
      const _PERCENT_PERCENT_CODE_EOF = token;
      const _x$7 = _PERCENT_PERCENT_CODE_EOF._0;
      return { _0: 7, _1: new Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_String$46$YYObj_String(_x$7) };
    }
    case 8: {
      return { _0: 8, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 9: {
      return { _0: 9, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 10: {
      return { _0: 10, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 11: {
      return { _0: 11, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 12: {
      return { _0: 12, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 13: {
      return { _0: 13, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 14: {
      return { _0: 14, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 15: {
      return { _0: 15, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 16: {
      return { _0: 16, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 17: {
      return { _0: 17, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 18: {
      return { _0: 18, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 19: {
      return { _0: 19, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    case 20: {
      return { _0: 20, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
    default: {
      return { _0: 21, _1: Error$moonbitlang$47$yacc$47$lib$47$parser$46$YYObj_Void$46$YYObj_Void };
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_1(_lookahead) {
  return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Accept;
}
function moonbitlang$yacc$lib$parser$$yy_state_2(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 23, moonbitlang$yacc$lib$parser$$yy_action_1);
}
function moonbitlang$yacc$lib$parser$$yy_state_13(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 26, moonbitlang$yacc$lib$parser$$yy_action_14);
}
function moonbitlang$yacc$lib$parser$$yy_state_8(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 39, moonbitlang$yacc$lib$parser$$yy_action_39);
}
function moonbitlang$yacc$lib$parser$$yy_state_10(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 38, moonbitlang$yacc$lib$parser$$yy_action_38);
}
function moonbitlang$yacc$lib$parser$$yy_state_9(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
      }
      case 39: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
      }
      case 38: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_10);
      }
      case 8: {
        break _L;
      }
      case 9: {
        break _L;
      }
      case 10: {
        break _L;
      }
      case 11: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      case 14: {
        break _L;
      }
      case 15: {
        break _L;
      }
      case 17: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 38, moonbitlang$yacc$lib$parser$$yy_action_37);
}
function moonbitlang$yacc$lib$parser$$yy_state_12(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
    }
    case 38: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_13);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_15(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 26, moonbitlang$yacc$lib$parser$$yy_action_13);
}
function moonbitlang$yacc$lib$parser$$yy_state_14(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
    }
    case 38: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_15);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_17(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 26, moonbitlang$yacc$lib$parser$$yy_action_12);
}
function moonbitlang$yacc$lib$parser$$yy_state_16(_lookahead) {
  if (_lookahead === 3) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_17);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_20(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 26, moonbitlang$yacc$lib$parser$$yy_action_11);
}
function moonbitlang$yacc$lib$parser$$yy_state_19(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
    }
    case 38: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_20);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_18(_lookahead) {
  if (_lookahead === 3) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_19);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_22(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 27, moonbitlang$yacc$lib$parser$$yy_action_17);
}
function moonbitlang$yacc$lib$parser$$yy_state_25(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(4, 26, moonbitlang$yacc$lib$parser$$yy_action_10);
}
function moonbitlang$yacc$lib$parser$$yy_state_24(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
      }
      case 39: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
      }
      case 38: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_10);
      }
      case 2: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_25);
      }
      case 8: {
        break _L;
      }
      case 9: {
        break _L;
      }
      case 10: {
        break _L;
      }
      case 11: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      case 14: {
        break _L;
      }
      case 15: {
        break _L;
      }
      case 17: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 38, moonbitlang$yacc$lib$parser$$yy_action_37);
}
function moonbitlang$yacc$lib$parser$$yy_state_26(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 26, moonbitlang$yacc$lib$parser$$yy_action_9);
}
function moonbitlang$yacc$lib$parser$$yy_state_23(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_24);
    }
    case 38: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_26);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_21(_lookahead) {
  switch (_lookahead) {
    case 3: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_22);
    }
    case 27: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_23);
    }
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 27, moonbitlang$yacc$lib$parser$$yy_action_18);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_28(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 26, moonbitlang$yacc$lib$parser$$yy_action_8);
}
function moonbitlang$yacc$lib$parser$$yy_state_27(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
    }
    case 38: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_28);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_30(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 25, moonbitlang$yacc$lib$parser$$yy_action_6);
}
function moonbitlang$yacc$lib$parser$$yy_state_6(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 26, moonbitlang$yacc$lib$parser$$yy_action_16);
}
function moonbitlang$yacc$lib$parser$$yy_state_5(_lookahead) {
  if (_lookahead === 1) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_6);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_4(_lookahead) {
  if (_lookahead === 3) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_5);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_11(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 26, moonbitlang$yacc$lib$parser$$yy_action_15);
}
function moonbitlang$yacc$lib$parser$$yy_state_7(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_9);
    }
    case 38: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_11);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_29(_lookahead) {
  switch (_lookahead) {
    case 17: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_4);
    }
    case 15: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_7);
    }
    case 14: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_12);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_14);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_16);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_18);
    }
    case 10: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_21);
    }
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_27);
    }
    case 26: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_29);
    }
    case 25: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_30);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 25, moonbitlang$yacc$lib$parser$$yy_action_7);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_34(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 30, moonbitlang$yacc$lib$parser$$yy_action_22);
}
function moonbitlang$yacc$lib$parser$$yy_state_37(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 37, moonbitlang$yacc$lib$parser$$yy_action_36);
}
function moonbitlang$yacc$lib$parser$$yy_state_38(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 37, moonbitlang$yacc$lib$parser$$yy_action_35);
}
function moonbitlang$yacc$lib$parser$$yy_state_41(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 36, moonbitlang$yacc$lib$parser$$yy_action_34);
}
function moonbitlang$yacc$lib$parser$$yy_state_40(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 2: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_37);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_38);
    }
    case 37: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_41);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_39(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 20: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_40);
      }
      case 1: {
        break _L;
      }
      case 2: {
        break _L;
      }
      case 4: {
        break _L;
      }
      case 16: {
        break _L;
      }
      case 19: {
        break _L;
      }
      case 21: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 39, moonbitlang$yacc$lib$parser$$yy_action_39);
}
function moonbitlang$yacc$lib$parser$$yy_state_42(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 36, moonbitlang$yacc$lib$parser$$yy_action_33);
}
function moonbitlang$yacc$lib$parser$$yy_state_44(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 35, moonbitlang$yacc$lib$parser$$yy_action_31);
}
function moonbitlang$yacc$lib$parser$$yy_state_43(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 2: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_37);
      }
      case 39: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_38);
      }
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_39);
      }
      case 37: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_42);
      }
      case 36: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_43);
      }
      case 35: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_44);
      }
      case 4: {
        break _L;
      }
      case 16: {
        break _L;
      }
      case 19: {
        break _L;
      }
      case 21: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 35, moonbitlang$yacc$lib$parser$$yy_action_32);
}
function moonbitlang$yacc$lib$parser$$yy_state_47(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 34, moonbitlang$yacc$lib$parser$$yy_action_29);
}
function moonbitlang$yacc$lib$parser$$yy_state_46(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_47);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_49(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 33, moonbitlang$yacc$lib$parser$$yy_action_27);
}
function moonbitlang$yacc$lib$parser$$yy_state_50(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 32, moonbitlang$yacc$lib$parser$$yy_action_26);
}
function moonbitlang$yacc$lib$parser$$yy_state_48(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 4: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_49);
      }
      case 33: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_50);
      }
      case 19: {
        break _L;
      }
      case 21: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 33, moonbitlang$yacc$lib$parser$$yy_action_28);
}
function moonbitlang$yacc$lib$parser$$yy_state_45(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 16: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_46);
      }
      case 34: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_48);
      }
      case 4: {
        break _L;
      }
      case 19: {
        break _L;
      }
      case 21: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 34, moonbitlang$yacc$lib$parser$$yy_action_30);
}
function moonbitlang$yacc$lib$parser$$yy_state_53(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(3, 31, moonbitlang$yacc$lib$parser$$yy_action_25);
}
function moonbitlang$yacc$lib$parser$$yy_state_51(_lookahead) {
  switch (_lookahead) {
    case 19: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_52);
    }
    case 21: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 31, moonbitlang$yacc$lib$parser$$yy_action_24);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_52(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 2: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_37);
      }
      case 39: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_38);
      }
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_39);
      }
      case 37: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_42);
      }
      case 36: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_43);
      }
      case 35: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_45);
      }
      case 32: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_51);
      }
      case 31: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_53);
      }
      case 4: {
        break _L;
      }
      case 16: {
        break _L;
      }
      case 19: {
        break _L;
      }
      case 21: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 35, moonbitlang$yacc$lib$parser$$yy_action_32);
}
function moonbitlang$yacc$lib$parser$$yy_state_55(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(5, 29, moonbitlang$yacc$lib$parser$$yy_action_21);
}
function moonbitlang$yacc$lib$parser$$yy_state_54(_lookahead) {
  if (_lookahead === 21) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_55);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_36(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 2: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_37);
      }
      case 39: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_38);
      }
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_39);
      }
      case 37: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_42);
      }
      case 36: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_43);
      }
      case 35: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_45);
      }
      case 32: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_51);
      }
      case 31: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_54);
      }
      case 4: {
        break _L;
      }
      case 16: {
        break _L;
      }
      case 19: {
        break _L;
      }
      case 21: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 35, moonbitlang$yacc$lib$parser$$yy_action_32);
}
function moonbitlang$yacc$lib$parser$$yy_state_35(_lookahead) {
  if (_lookahead === 18) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_36);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_33(_lookahead) {
  switch (_lookahead) {
    case 6: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_34);
    }
    case 30: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_35);
    }
    case 18: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 30, moonbitlang$yacc$lib$parser$$yy_action_23);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_57(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(2, 28, moonbitlang$yacc$lib$parser$$yy_action_20);
}
function moonbitlang$yacc$lib$parser$$yy_state_56(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 1: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
      }
      case 39: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_33);
      }
      case 29: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_56);
      }
      case 28: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_57);
      }
      case 0: {
        break _L;
      }
      case 5: {
        break _L;
      }
      case 7: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(1, 28, moonbitlang$yacc$lib$parser$$yy_action_19);
}
function moonbitlang$yacc$lib$parser$$yy_state_59(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 24, moonbitlang$yacc$lib$parser$$yy_action_4);
}
function moonbitlang$yacc$lib$parser$$yy_state_60(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(1, 24, moonbitlang$yacc$lib$parser$$yy_action_3);
}
function moonbitlang$yacc$lib$parser$$yy_state_62(_lookahead) {
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$ReduceNoLookahead(6, 22, moonbitlang$yacc$lib$parser$$yy_action_0);
}
function moonbitlang$yacc$lib$parser$$yy_state_61(_lookahead) {
  if (_lookahead === 0) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_62);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_58(_lookahead) {
  switch (_lookahead) {
    case 7: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_59);
    }
    case 5: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_60);
    }
    case 24: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_61);
    }
    case 0: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 24, moonbitlang$yacc$lib$parser$$yy_action_5);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_32(_lookahead) {
  switch (_lookahead) {
    case 1: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_8);
    }
    case 39: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_33);
    }
    case 29: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_56);
    }
    case 28: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_58);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_31(_lookahead) {
  if (_lookahead === 8) {
    return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_32);
  } else {
    return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_3(_lookahead) {
  switch (_lookahead) {
    case 17: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_4);
    }
    case 15: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_7);
    }
    case 14: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_12);
    }
    case 13: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_14);
    }
    case 12: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_16);
    }
    case 11: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_18);
    }
    case 10: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_21);
    }
    case 9: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_27);
    }
    case 26: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_29);
    }
    case 25: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_31);
    }
    case 8: {
      return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 25, moonbitlang$yacc$lib$parser$$yy_action_7);
    }
    default: {
      return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
    }
  }
}
function moonbitlang$yacc$lib$parser$$yy_state_0(_lookahead) {
  _L: {
    switch (_lookahead) {
      case 22: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_1);
      }
      case 5: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_2);
      }
      case 23: {
        return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Shift(moonbitlang$yacc$lib$parser$$yy_state_3);
      }
      case 8: {
        break _L;
      }
      case 9: {
        break _L;
      }
      case 10: {
        break _L;
      }
      case 11: {
        break _L;
      }
      case 12: {
        break _L;
      }
      case 13: {
        break _L;
      }
      case 14: {
        break _L;
      }
      case 15: {
        break _L;
      }
      case 17: {
        break _L;
      }
      default: {
        return $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Error;
      }
    }
  }
  return new $64$moonbitlang$47$yacc$47$lib$47$parser$46$YYDecision$Reduce(0, 23, moonbitlang$yacc$lib$parser$$yy_action_2);
}
function moonbitlang$yacc$lib$parser$$error(stack, token, loc) {
  const expected = [];
  const _arr = [{ _0: 0, _1: 0 }, { _0: 1, _1: 1 }, { _0: 2, _1: 2 }, { _0: 3, _1: 3 }, { _0: 4, _1: 4 }, { _0: 5, _1: 5 }, { _0: 6, _1: 6 }, { _0: 7, _1: 7 }, { _0: 8, _1: 8 }, { _0: 9, _1: 9 }, { _0: 10, _1: 10 }, { _0: 11, _1: 11 }, { _0: 12, _1: 12 }, { _0: 13, _1: 13 }, { _0: 14, _1: 14 }, { _0: 15, _1: 15 }, { _0: 16, _1: 16 }, { _0: 17, _1: 17 }, { _0: 18, _1: 18 }, { _0: 19, _1: 19 }, { _0: 20, _1: 20 }, { _0: 21, _1: 21 }];
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const term = _arr[_i];
      const kind = term._1;
      const symbol = term._0;
      let stack$2;
      _L: {
        stack$2 = stack;
        break _L;
      }
      let _tmp$2 = stack$2;
      _L$2: while (true) {
        const stack$3 = _tmp$2;
        if (stack$3.$tag === 0) {
          break;
        } else {
          const _Cons = stack$3;
          const _x = _Cons._0;
          let count;
          let symbol$2;
          _L$3: {
            _L$4: {
              const _bind = _x(symbol);
              switch (_bind.$tag) {
                case 0: {
                  break _L$4;
                }
                case 1: {
                  break _L$4;
                }
                case 2: {
                  const _Reduce = _bind;
                  const _x$2 = _Reduce._0;
                  const _x$3 = _Reduce._1;
                  count = _x$2;
                  symbol$2 = _x$3;
                  break _L$3;
                }
                case 3: {
                  const _ReduceNoLookahead = _bind;
                  const _x$4 = _ReduceNoLookahead._0;
                  const _x$5 = _ReduceNoLookahead._1;
                  count = _x$4;
                  symbol$2 = _x$5;
                  break _L$3;
                }
                default: {
                  break _L$2;
                }
              }
            }
            moonbitlang$core$array$$Array$push$116$(expected, kind);
            break;
          }
          let stack$4;
          let count$2;
          let symbol$3;
          _L$4: {
            stack$4 = stack$3;
            count$2 = count;
            symbol$3 = symbol$2;
            break _L$4;
          }
          let _tmp$3 = stack$4;
          let _tmp$4 = count$2;
          let _tmp$5 = symbol$3;
          _L$5: while (true) {
            const stack$5 = _tmp$3;
            const count$3 = _tmp$4;
            const symbol$4 = _tmp$5;
            const stack$6 = moonbitlang$core$immut$list$$T$drop$61$(stack$5, count$3);
            if (stack$6.$tag === 1) {
              const _Cons$2 = stack$6;
              const _x$2 = _Cons$2._0;
              let count$4;
              let symbol$5;
              _L$6: {
                const _bind = _x$2(symbol$4);
                switch (_bind.$tag) {
                  case 1: {
                    const _Shift = _bind;
                    const _x$3 = _Shift._0;
                    _tmp$2 = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$6$(_x$3, stack$6);
                    continue _L$2;
                  }
                  case 2: {
                    const _Reduce = _bind;
                    const _x$4 = _Reduce._0;
                    const _x$5 = _Reduce._1;
                    count$4 = _x$4;
                    symbol$5 = _x$5;
                    break _L$6;
                  }
                  case 3: {
                    const _ReduceNoLookahead = _bind;
                    const _x$6 = _ReduceNoLookahead._0;
                    const _x$7 = _ReduceNoLookahead._1;
                    count$4 = _x$6;
                    symbol$5 = _x$7;
                    break _L$6;
                  }
                  default: {
                    $panic();
                    break _L$2;
                  }
                }
              }
              _tmp$3 = stack$6;
              _tmp$4 = count$4;
              _tmp$5 = symbol$5;
              continue;
            } else {
              $panic();
              break _L$2;
            }
          }
        }
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return new Result$Err$18$(new Error$moonbitlang$47$yacc$47$lib$47$parser$46$ParseError$46$UnexpectedToken(token, loc, expected));
}
function moonbitlang$yacc$lib$parser$$yy_parse$157$(read_token, start_pos, start, return_) {
  const state_stack = { val: new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$6$(start, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$6$) };
  const data_stack = [];
  const last_pos = { val: start_pos };
  const state = { val: start };
  let lookahead = undefined;
  let last_shifted_state_stack = state_stack.val;
  while (true) {
    let decision;
    const _func = state.val;
    const _bind = _func(40);
    switch (_bind.$tag) {
      case 3: {
        decision = _bind;
        break;
      }
      case 0: {
        decision = _bind;
        break;
      }
      default: {
        const _bind$2 = lookahead;
        if (_bind$2 === undefined) {
          const _bind$3 = read_token();
          const _x = _bind$3._0;
          const _x$2 = _bind$3._1;
          const _x$3 = _bind$3._2;
          const _bind$4 = moonbitlang$yacc$lib$parser$$yy_input(_x, _x$2, _x$3);
          const _x$4 = _bind$4._0;
          const _x$5 = _bind$4._1;
          lookahead = { _0: _x$4, _1: { _0: _x$5, _1: _x$2, _2: _x$3 }, _2: _x };
          const _func$2 = state.val;
          decision = _func$2(_x$4);
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          const _func$2 = state.val;
          decision = _func$2(_x._0);
        }
      }
    }
    let action;
    let count;
    let symbol;
    _L: {
      _L$2: {
        switch (decision.$tag) {
          case 0: {
            return new Result$Ok$19$(return_(moonbitlang$core$array$$Array$unsafe_pop$73$(data_stack)._0));
          }
          case 1: {
            const _Shift = decision;
            const _x = _Shift._0;
            const _bind$3 = lookahead;
            if (_bind$3 === undefined) {
              $panic();
            } else {
              const _Some = _bind$3;
              const _x$2 = _Some;
              moonbitlang$core$array$$Array$push$73$(data_stack, _x$2._1);
              state_stack.val = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$6$(_x, state_stack.val);
              last_shifted_state_stack = state_stack.val;
              state.val = _x;
              last_pos.val = _x$2._1._2;
              lookahead = undefined;
            }
            break;
          }
          case 2: {
            const _Reduce = decision;
            const _x$2 = _Reduce._0;
            const _x$3 = _Reduce._1;
            const _x$4 = _Reduce._2;
            action = _x$4;
            count = _x$2;
            symbol = _x$3;
            break _L$2;
          }
          case 3: {
            const _ReduceNoLookahead = decision;
            const _x$5 = _ReduceNoLookahead._0;
            const _x$6 = _ReduceNoLookahead._1;
            const _x$7 = _ReduceNoLookahead._2;
            action = _x$7;
            count = _x$5;
            symbol = _x$6;
            break _L$2;
          }
          default: {
            const _bind$4 = moonbitlang$core$option$$Option$unwrap$105$(lookahead);
            const _x$8 = _bind$4._1;
            const _x$9 = _x$8._1;
            const _x$10 = _x$8._2;
            const _x$11 = _bind$4._2;
            const _bind$5 = moonbitlang$yacc$lib$parser$$error(last_shifted_state_stack, _x$11, { _0: _x$9, _1: _x$10 });
            if (_bind$5.$tag === 1) {
              const _ok = _bind$5;
              _ok._0;
            } else {
              return _bind$5;
            }
          }
        }
        break _L;
      }
      let _tmp = count;
      let _tmp$2 = symbol;
      let _tmp$3 = action;
      _L$3: while (true) {
        const args = moonbitlang$core$array$$Array$op_as_view$73$(data_stack, data_stack.length - count | 0, undefined);
        const data = action(last_pos.val, args);
        let start_pos$2;
        let end_pos;
        _L$4: {
          if (moonbitlang$core$array$$ArrayView$length$73$(args) === 0) {
            const _tmp$4 = last_pos.val;
            const _tmp$5 = last_pos.val;
            start_pos$2 = _tmp$4;
            end_pos = _tmp$5;
            break _L$4;
          } else {
            const _tmp$4 = moonbitlang$core$array$$ArrayView$op_get$73$(args, 0)._1;
            const _tmp$5 = moonbitlang$core$array$$ArrayView$op_get$73$(args, moonbitlang$core$array$$ArrayView$length$73$(args) - 1 | 0)._2;
            start_pos$2 = _tmp$4;
            end_pos = _tmp$5;
            break _L$4;
          }
        }
        let _tmp$4 = 0;
        while (true) {
          const i = _tmp$4;
          if (i < count) {
            moonbitlang$core$array$$Array$unsafe_pop$73$(data_stack);
            state_stack.val = moonbitlang$core$immut$list$$T$tail$61$(state_stack.val);
            _tmp$4 = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        state.val = moonbitlang$core$immut$list$$T$unsafe_head$61$(state_stack.val);
        moonbitlang$core$array$$Array$push$73$(data_stack, { _0: data, _1: start_pos$2, _2: end_pos });
        let action$2;
        let count$2;
        let symbol$2;
        _L$5: {
          const _func$2 = state.val;
          const _bind$3 = _func$2(symbol);
          switch (_bind$3.$tag) {
            case 0: {
              return new Result$Ok$19$(return_(moonbitlang$core$array$$Array$unsafe_pop$73$(data_stack)._0));
            }
            case 1: {
              const _Shift = _bind$3;
              const _x = _Shift._0;
              state_stack.val = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$6$(_x, state_stack.val);
              state.val = _x;
              break _L$3;
            }
            case 2: {
              const _Reduce = _bind$3;
              const _x$2 = _Reduce._0;
              const _x$3 = _Reduce._1;
              const _x$4 = _Reduce._2;
              action$2 = _x$4;
              count$2 = _x$2;
              symbol$2 = _x$3;
              break _L$5;
            }
            case 3: {
              const _ReduceNoLookahead = _bind$3;
              const _x$5 = _ReduceNoLookahead._0;
              const _x$6 = _ReduceNoLookahead._1;
              const _x$7 = _ReduceNoLookahead._2;
              action$2 = _x$7;
              count$2 = _x$5;
              symbol$2 = _x$6;
              break _L$5;
            }
            default: {
              $panic();
              break _L$3;
            }
          }
        }
        _tmp = count$2;
        _tmp$2 = symbol$2;
        _tmp$3 = action$2;
        continue;
      }
    }
    continue;
  }
}
function moonbitlang$yacc$lib$parser$$spec(read_token, start_pos) {
  return moonbitlang$yacc$lib$parser$$yy_parse$157$(read_token, start_pos, moonbitlang$yacc$lib$parser$$yy_state_0, (_param2) => {
    if (_param2.$tag === 7) {
      const _YYObj_ParserSpec = _param2;
      const _x = _YYObj_ParserSpec._0;
      return _x;
    } else {
      return $panic();
    }
  });
}
function moonbitlang$core$builtin$$Eq$op_equal$36$(_x_25, _x_26) {
  switch (_x_25) {
    case 0: {
      if (_x_26 === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      if (_x_26 === 1) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      if (_x_26 === 2) {
        return true;
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$36$(_x_17, _x_18) {
  switch (_x_17) {
    case 0: {
      moonbitlang$core$builtin$$Hasher$combine_int(_x_18, 0);
      return;
    }
    case 1: {
      moonbitlang$core$builtin$$Hasher$combine_int(_x_18, 1);
      return;
    }
    default: {
      moonbitlang$core$builtin$$Hasher$combine_int(_x_18, 2);
      return;
    }
  }
}
function moonbitlang$core$builtin$$ToJson$to_json$158$(_x_9) {
  const $36$map = moonbitlang$core$builtin$$Map$from_array$69$([]);
  moonbitlang$core$builtin$$Map$set$69$($36$map, "mappings", moonbitlang$core$array$$Array$to_json$123$(_x_9.mappings));
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Object($36$map);
}
function moonbitlang$yacc$lib$codegen$$SourceMap$new() {
  return { mappings: [] };
}
function moonbitlang$core$builtin$$ToJson$to_json$123$(_x_6) {
  const $36$map = moonbitlang$core$builtin$$Map$from_array$69$([]);
  moonbitlang$core$builtin$$Map$set$69$($36$map, "source", moonbitlang$core$string$$String$to_json(_x_6.source));
  moonbitlang$core$builtin$$Map$set$69$($36$map, "original_offset", moonbitlang$core$int$$Int$to_json(_x_6.original_offset));
  moonbitlang$core$builtin$$Map$set$69$($36$map, "generated_offset", moonbitlang$core$int$$Int$to_json(_x_6.generated_offset));
  moonbitlang$core$builtin$$Map$set$69$($36$map, "length", moonbitlang$core$int$$Int$to_json(_x_6.length));
  return new $64$moonbitlang$47$core$47$builtin$46$Json$Object($36$map);
}
function moonbitlang$yacc$lib$codegen$$SourceMapBuilder$add_mapping$158$(self, source, original_offset_in_utf8, generated_offset_in_utf8, length_in_utf8) {
  moonbitlang$core$array$$Array$push$123$(self.mappings, { source: source, original_offset: original_offset_in_utf8, generated_offset: generated_offset_in_utf8, length: length_in_utf8 });
}
function moonbitlang$core$builtin$$Eq$op_equal$78$(_x_2, _x_3) {
  return _x_2 === _x_3;
}
function moonbitlang$yacc$lib$util$stamp$$new() {
  const stamp = moonbitlang$yacc$lib$util$stamp$$next_stamp.val;
  moonbitlang$yacc$lib$util$stamp$$next_stamp.val = moonbitlang$yacc$lib$util$stamp$$next_stamp.val + 1 | 0;
  return stamp;
}
function moonbitlang$yacc$lib$util$stamp$$initial() {
  return moonbitlang$yacc$lib$util$stamp$$initial_stamp;
}
function moonbitlang$yacc$lib$util$small_int_set$$empty() {
  return moonbitlang$yacc$lib$util$small_int_set$$_empty;
}
function moonbitlang$yacc$lib$util$small_int_set$$singleton(key) {
  const word_index = key >> 5;
  const result = moonbitlang$core$array$$Array$make$28$(2, 0);
  moonbitlang$core$array$$Array$op_set$28$(result, 0, 1 << word_index);
  moonbitlang$core$array$$Array$op_set$28$(result, 1, 1 << (key & 31));
  return result;
}
function moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$iter(self) {
  return moonbitlang$core$builtin$$Iter$new$28$((yield_) => {
    let i = 0;
    let bitmask = moonbitlang$core$array$$Array$op_get$28$(self, 0);
    while (true) {
      if (bitmask === 0) {
        break;
      }
      const word_index = $i32_ctz(bitmask);
      let word = moonbitlang$core$array$$Array$op_get$28$(self, 1 + i | 0);
      while (true) {
        if (word === 0) {
          break;
        }
        const bit = $i32_ctz(word);
        const _bind = yield_((Math.imul(word_index, 32) | 0) + bit | 0);
        if (_bind === 0) {
          return 0;
        }
        word = word & ~(1 << bit);
        continue;
      }
      bitmask = bitmask & ~(1 << word_index);
      i = i + 1 | 0;
      continue;
    }
    return 1;
  });
}
function moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$union(self, other) {
  const bitmask1 = moonbitlang$core$array$$Array$op_get$28$(self, 0);
  if (bitmask1 === 0) {
    return other;
  }
  const bitmask2 = moonbitlang$core$array$$Array$op_get$28$(other, 0);
  if (bitmask2 === 0) {
    return self;
  }
  const bitmask = bitmask1 | bitmask2;
  if (bitmask === bitmask1) {
    if (self === other) {
      return self;
    }
    const result = moonbitlang$core$array$$Array$copy$28$(self);
    let bitmask2$2 = bitmask2;
    let j = 1;
    while (true) {
      const jb = $i32_ctz(bitmask2$2);
      if (jb === 32) {
        break;
      }
      const i = 1 + $i32_popcnt(bitmask1 & ((1 << jb) - 1 | 0)) | 0;
      moonbitlang$core$array$$Array$op_set$28$(result, i, moonbitlang$core$array$$Array$op_get$28$(result, i) | moonbitlang$core$array$$Array$op_get$28$(other, j));
      j = j + 1 | 0;
      bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
      continue;
    }
    return result;
  } else {
    if (bitmask === bitmask2) {
      if (self === other) {
        return self;
      }
      const result = moonbitlang$core$array$$Array$copy$28$(other);
      let bitmask1$2 = bitmask1;
      let i = 1;
      while (true) {
        const ib = $i32_ctz(bitmask1$2);
        if (ib === 32) {
          break;
        }
        const j = 1 + $i32_popcnt(bitmask2 & ((1 << ib) - 1 | 0)) | 0;
        moonbitlang$core$array$$Array$op_set$28$(result, j, moonbitlang$core$array$$Array$op_get$28$(result, j) | moonbitlang$core$array$$Array$op_get$28$(self, i));
        i = i + 1 | 0;
        bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
        continue;
      }
      return result;
    } else {
      const result = moonbitlang$core$array$$Array$make$28$(1 + $i32_popcnt(bitmask) | 0, 0);
      moonbitlang$core$array$$Array$op_set$28$(result, 0, bitmask);
      let i = 1;
      let j = 1;
      let k = 1;
      let bitmask1$2 = bitmask1;
      let bitmask2$2 = bitmask2;
      while (true) {
        const ib = $i32_ctz(bitmask1$2);
        const jb = $i32_ctz(bitmask2$2);
        if (ib < jb) {
          moonbitlang$core$array$$Array$op_set$28$(result, k, moonbitlang$core$array$$Array$op_get$28$(self, i));
          i = i + 1 | 0;
          bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
        } else {
          if (ib > jb) {
            moonbitlang$core$array$$Array$op_set$28$(result, k, moonbitlang$core$array$$Array$op_get$28$(other, j));
            j = j + 1 | 0;
            bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
          } else {
            if (ib === 32) {
              break;
            }
            moonbitlang$core$array$$Array$op_set$28$(result, k, moonbitlang$core$array$$Array$op_get$28$(self, i) | moonbitlang$core$array$$Array$op_get$28$(other, j));
            i = i + 1 | 0;
            j = j + 1 | 0;
            bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
            bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
          }
        }
        k = k + 1 | 0;
        continue;
      }
      return result;
    }
  }
}
function moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$disjoint(self, other) {
  const bitmask1 = moonbitlang$core$array$$Array$op_get$28$(self, 0);
  const bitmask2 = moonbitlang$core$array$$Array$op_get$28$(other, 0);
  if ((bitmask1 & bitmask2) !== 0) {
    return false;
  }
  let i = 1;
  let j = 1;
  let bitmask1$2 = bitmask1;
  let bitmask2$2 = bitmask2;
  while (true) {
    const ib = $i32_ctz(bitmask1$2);
    const jb = $i32_ctz(bitmask2$2);
    if (ib < jb) {
      i = i + 1 | 0;
      bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
    } else {
      if (ib > jb) {
        j = j + 1 | 0;
        bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
      } else {
        if (ib === 32) {
          break;
        }
        if ((moonbitlang$core$array$$Array$op_get$28$(self, i) & moonbitlang$core$array$$Array$op_get$28$(other, j)) !== 0) {
          return false;
        }
        i = i + 1 | 0;
        j = j + 1 | 0;
        bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
        bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
      }
    }
    continue;
  }
  return true;
}
function moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$subset(self, other) {
  const bitmask1 = moonbitlang$core$array$$Array$op_get$28$(self, 0);
  const bitmask2 = moonbitlang$core$array$$Array$op_get$28$(other, 0);
  if ((bitmask1 & bitmask2) !== bitmask1) {
    return false;
  }
  let i = 1;
  let j = 1;
  let bitmask1$2 = bitmask1;
  let bitmask2$2 = bitmask2;
  while (true) {
    const ib = $i32_ctz(bitmask1$2);
    const jb = $i32_ctz(bitmask2$2);
    if (ib < jb) {
      return false;
    } else {
      if (ib === 32) {
        break;
      }
      if (ib > jb) {
        i = i + 1 | 0;
        bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
      } else {
        if ((moonbitlang$core$array$$Array$op_get$28$(self, i) & moonbitlang$core$array$$Array$op_get$28$(other, j)) !== moonbitlang$core$array$$Array$op_get$28$(self, i)) {
          return false;
        }
        i = i + 1 | 0;
        j = j + 1 | 0;
        bitmask1$2 = bitmask1$2 & (bitmask1$2 - 1 | 0);
        bitmask2$2 = bitmask2$2 & (bitmask2$2 - 1 | 0);
      }
    }
    continue;
  }
  return true;
}
function moonbitlang$yacc$lib$util$hashmap2$$new$159$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$160$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$115$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$new$161$(capacity) {
  const bucket = $make_array_len_and_init(capacity, undefined);
  return { bucket: bucket, entry: undefined, bitmask: capacity - 1 | 0, size: 0 };
}
function moonbitlang$yacc$lib$util$hashmap2$$T$size$161$(self) {
  return self.size;
}
function moonbitlang$yacc$lib$util$hashmap2$$T$iter$159$(self) {
  return moonbitlang$core$builtin$$Iter$new$112$((yield_) => {
    let _tmp = self.entry;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _bind = yield_({ _0: _x.key, _1: _x.value });
        if (_bind === 0) {
          return 0;
        } else {
          _tmp = _x.prev;
          continue;
        }
      }
    }
  });
}
function moonbitlang$yacc$lib$util$hashmap2$$T$iter$160$(self) {
  return moonbitlang$core$builtin$$Iter$new$113$((yield_) => {
    let _tmp = self.entry;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _bind = yield_({ _0: _x.key, _1: _x.value });
        if (_bind === 0) {
          return 0;
        } else {
          _tmp = _x.prev;
          continue;
        }
      }
    }
  });
}
function moonbitlang$yacc$lib$util$hashmap2$$T$iter2$115$(self) {
  return moonbitlang$core$builtin$$Iter2$new$115$((yield_) => {
    let _tmp = self.entry;
    while (true) {
      const _param = _tmp;
      if (_param === undefined) {
        return 1;
      } else {
        const _Some = _param;
        const _x = _Some;
        const _bind = yield_(_x.key, _x.value);
        if (_bind === 0) {
          return 0;
        } else {
          _tmp = _x.prev;
          continue;
        }
      }
    }
  });
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$161$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$162$(_x.key, key)) {
        return _x;
      }
      if ((index - ideal_index | 0) > _x.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$159$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$45$(_x.key, key)) {
        return _x;
      }
      if ((index - ideal_index | 0) > _x.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$160$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$45$(_x.key, key)) {
        return _x;
      }
      if ((index - ideal_index | 0) > _x.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$115$(self, key, hash) {
  const bucket = self.bucket;
  const bitmask = self.bitmask;
  const ideal_index = hash & bitmask;
  let _tmp = ideal_index;
  while (true) {
    const index = _tmp;
    const _bind = bucket[index];
    if (_bind === undefined) {
      return undefined;
    } else {
      const _Some = _bind;
      const _x = _Some;
      if (_x.hash === hash && moonbitlang$core$builtin$$Eq$op_equal$91$(_x.key, key)) {
        return _x;
      }
      if ((index - ideal_index | 0) > _x.psl) {
        return undefined;
      }
      _tmp = index + 1 & bitmask;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$161$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      let entry$3;
      if (entry$2.psl > _x.psl) {
        bucket[index$2] = entry$2;
        entry$3 = _x;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      const _tmp$3 = index$2 + 1 & bitmask;
      _tmp = _tmp$3;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$159$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      let entry$3;
      if (entry$2.psl > _x.psl) {
        bucket[index$2] = entry$2;
        entry$3 = _x;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      const _tmp$3 = index$2 + 1 & bitmask;
      _tmp = _tmp$3;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$160$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      let entry$3;
      if (entry$2.psl > _x.psl) {
        bucket[index$2] = entry$2;
        entry$3 = _x;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      const _tmp$3 = index$2 + 1 & bitmask;
      _tmp = _tmp$3;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$115$(self, index, bitmask, entry) {
  const bucket = self.bucket;
  let _tmp = index;
  let _tmp$2 = entry;
  while (true) {
    const index$2 = _tmp;
    const entry$2 = _tmp$2;
    const _bind = bucket[index$2];
    if (_bind === undefined) {
      bucket[index$2] = entry$2;
      break;
    } else {
      const _Some = _bind;
      const _x = _Some;
      let entry$3;
      if (entry$2.psl > _x.psl) {
        bucket[index$2] = entry$2;
        entry$3 = _x;
      } else {
        entry$3 = entry$2;
      }
      entry$3.psl = entry$3.psl + 1 | 0;
      const _tmp$3 = index$2 + 1 & bitmask;
      _tmp = _tmp$3;
      _tmp$2 = entry$3;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$161$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      _x.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$161$(self, _x.hash & bitmask, bitmask, _x);
      _tmp = _x.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$159$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      _x.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$159$(self, _x.hash & bitmask, bitmask, _x);
      _tmp = _x.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$160$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      _x.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$160$(self, _x.hash & bitmask, bitmask, _x);
      _tmp = _x.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$grow$115$(self) {
  const capacity = Math.imul(self.bitmask + 1 | 0, 2) | 0;
  const bitmask = capacity - 1 | 0;
  const bucket = $make_array_len_and_init(capacity, undefined);
  self.bucket = bucket;
  self.bitmask = bitmask;
  let _tmp = self.entry;
  while (true) {
    const _param = _tmp;
    if (_param === undefined) {
      return;
    } else {
      const _Some = _param;
      const _x = _Some;
      _x.psl = 0;
      moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$115$(self, _x.hash & bitmask, bitmask, _x);
      _tmp = _x.prev;
      continue;
    }
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$159$(self, key, init) {
  const hash = moonbitlang$core$builtin$$Hash$hash$140$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$159$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$159$(self);
    }
    const value = init(key);
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$159$(self, hash & self.bitmask, self.bitmask, entry);
    return value;
  } else {
    const _Some = _bind;
    const _x = _Some;
    return _x.value;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$161$(self, key, init) {
  const hash = moonbitlang$core$builtin$$Hash$hash$162$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$161$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$161$(self);
    }
    const value = init(key);
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$161$(self, hash & self.bitmask, self.bitmask, entry);
    return value;
  } else {
    const _Some = _bind;
    const _x = _Some;
    return _x.value;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$set$115$(self, key, value) {
  const hash = moonbitlang$core$builtin$$Hash$hash$141$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$115$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$115$(self);
    }
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$115$(self, hash & self.bitmask, self.bitmask, entry);
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    _x.value = value;
    return;
  }
}
function moonbitlang$yacc$lib$util$hashmap2$$T$set$160$(self, key, value) {
  const hash = moonbitlang$core$builtin$$Hash$hash$140$(key);
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$get_entry_with_hash$160$(self, key, hash);
  if (_bind === undefined) {
    if (self.size > (self.bitmask / 2 | 0)) {
      moonbitlang$yacc$lib$util$hashmap2$$T$grow$160$(self);
    }
    const entry = { value: value, psl: 0, key: key, hash: hash, prev: self.entry };
    self.entry = entry;
    self.size = self.size + 1 | 0;
    moonbitlang$yacc$lib$util$hashmap2$$T$put_entry$160$(self, hash & self.bitmask, self.bitmask, entry);
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    _x.value = value;
    return;
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$44$(_x_473, _x_474) {
  if (_x_473.$tag === 0) {
    if (_x_474.$tag === 0) {
      return true;
    } else {
      return false;
    }
  } else {
    const _Input = _x_473;
    const _x = _Input._0;
    if (_x_474.$tag === 1) {
      const _Input$2 = _x_474;
      const _x$2 = _Input$2._0;
      return moonbitlang$core$builtin$$Eq$op_equal$84$(_x, _x$2);
    } else {
      return false;
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$44$(_x_465, _x_466) {
  if (_x_465.$tag === 0) {
    if (_x_466.$tag === 0) {
      return 0;
    } else {
      return -1;
    }
  } else {
    const _Input = _x_465;
    const _x = _Input._0;
    if (_x_466.$tag === 0) {
      return 1;
    } else {
      const _Input$2 = _x_466;
      const _x$2 = _Input$2._0;
      return moonbitlang$core$builtin$$Compare$compare$84$(_x, _x$2);
    }
  }
}
function moonbitlang$core$builtin$$Hash$hash_combine$44$(self, hasher) {
  if (self.$tag === 0) {
    moonbitlang$core$builtin$$Hasher$combine_int(hasher, -1);
    return;
  } else {
    const _Input = self;
    const _x = _Input._0;
    moonbitlang$core$builtin$$Hasher$combine_int(hasher, _x.num);
    return;
  }
}
function moonbitlang$core$builtin$$Show$output$44$(self, logger) {
  if (self.$tag === 1) {
    const _Input = self;
    const _x = _Input._0;
    moonbitlang$core$builtin$$Logger$write_object$84$(logger, _x);
    return;
  } else {
    logger.method_0(logger.self, "$");
    return;
  }
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$empty() {
  return moonbitlang$yacc$lib$util$small_int_set$$empty();
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$terminal(t) {
  return moonbitlang$yacc$lib$util$small_int_set$$singleton(t.num + 1 | 0);
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$end_of_input() {
  return moonbitlang$yacc$lib$util$small_int_set$$singleton(0);
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$singleton(input) {
  if (input.$tag === 1) {
    const _Input = input;
    const _x = _Input._0;
    return moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$terminal(_x);
  } else {
    return moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$end_of_input();
  }
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$decode_iter(self, grammar) {
  const _bind = moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$iter(self);
  return (_p) => _bind((_p$2) => _p(_p$2 === 0 ? $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput : new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(moonbitlang$core$array$$Array$op_get$84$(grammar.terminals, _p$2 - 1 | 0))));
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$union(self, other) {
  return moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$union(self, other);
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(self, other) {
  return moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$disjoint(self, other);
}
function moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(self, other) {
  return moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$subset(self, other);
}
function moonbitlang$core$builtin$$Eq$op_equal$162$(self, other) {
  return moonbitlang$core$array$$Array$op_equal$31$(self.items, other.items);
}
function moonbitlang$core$builtin$$Hash$hash$162$(self) {
  const _bind = self.hash;
  if (_bind === undefined) {
    const hasher = moonbitlang$core$builtin$$Hasher$new(moonbitlang$core$builtin$$Hasher$new$46$seed$46$default());
    const _arr = self.items;
    const _len = _arr.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const item = _arr[_i];
        moonbitlang$core$builtin$$Hasher$combine_int(hasher, item);
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const hash = moonbitlang$core$builtin$$Hasher$finalize(hasher);
    self.hash = hash;
    return hash;
  } else {
    const _Some = _bind;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$from_sorted_array(items) {
  return { items: items, hash: undefined };
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode(self, grammar) {
  const production = moonbitlang$core$array$$Array$op_get$26$(grammar.productions, self >> 10);
  const dot = self & 1023;
  return { production: production, dot: dot };
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$decode_iter(self, grammar) {
  return moonbitlang$core$builtin$$Iter$new$114$((yield_) => {
    let index = 0;
    const _arr = self.items;
    const _len = _arr.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const item = _arr[_i];
        const _bind = yield_({ _0: index, _1: moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode(item, grammar) });
        if (_bind === 0) {
          return 0;
        }
        index = index + 1 | 0;
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return 1;
  });
}
function moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(self, subst) {
  const _bind = moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$iter(self.vars);
  const _bind$2 = self.concrete_set;
  const _acc = { val: _bind$2 };
  _bind((_p) => {
    const _p$2 = moonbitlang$core$array$$Array$op_get$85$(subst, _p);
    _acc.val = moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$union(_acc.val, _p$2);
    return 1;
  });
  return _acc.val;
}
function moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$decode_item_groups(self, grammar) {
  return moonbitlang$core$builtin$$Iter$new$111$((yield_) => {
    const lookahead_set_array = moonbitlang$core$array$$Array$map$133$(self.core.closure_symbolic_lookahead_set, (symbolic_lookahead_set) => moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(symbolic_lookahead_set, self.kernel_lookahead_set_table));
    const _foreach_result = { val: $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Continue$20$ };
    const _bind = moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$decode_iter(self.core.closure_items, grammar);
    _bind((item) => {
      const _x = item._0;
      const _x$2 = item._1;
      const lookahead_set = moonbitlang$core$array$$Array$op_get$85$(lookahead_set_array, _x);
      const _bind$2 = yield_({ core: _x$2, lookahead_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$decode_iter(lookahead_set, grammar) });
      if (_bind$2 === 0) {
        _foreach_result.val = new $64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$20$(0);
        return 0;
      }
      return 1;
    });
    const _tmp = _foreach_result.val;
    switch (_tmp.$tag) {
      case 0: {
        break;
      }
      case 1: {
        const _break = _tmp;
        _break._0;
        break;
      }
      case 2: {
        const _return = _tmp;
        return _return._0;
      }
      case 3: {
        $panic();
        break;
      }
      default: {
        $panic();
      }
    }
    return 1;
  });
}
function moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$merge(self, other) {
  return moonbitlang$core$builtin$$Eq$op_equal$163$(self.core, other.core) ? { core: self.core, kernel_lookahead_set_table: moonbitlang$core$array$$Array$mapi$149$(self.kernel_lookahead_set_table, (i, lookahead_set) => moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$union(lookahead_set, moonbitlang$core$array$$Array$op_get$85$(other.kernel_lookahead_set_table, i))) } : $panic();
}
function moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$subsume(self, other) {
  if (moonbitlang$core$builtin$$Eq$op_equal$163$(self.core, other.core)) {
    const len = self.kernel_lookahead_set_table.length;
    const self_table = self.kernel_lookahead_set_table;
    const other_table = other.kernel_lookahead_set_table;
    switch (len) {
      case 1: {
        return moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(moonbitlang$core$array$$Array$op_get$85$(self_table, 0), moonbitlang$core$array$$Array$op_get$85$(other_table, 0));
      }
      case 2: {
        return moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(moonbitlang$core$array$$Array$op_get$85$(self_table, 0), moonbitlang$core$array$$Array$op_get$85$(other_table, 0)) && moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(moonbitlang$core$array$$Array$op_get$85$(self_table, 1), moonbitlang$core$array$$Array$op_get$85$(other_table, 1));
      }
      default: {
        let _tmp = 0;
        while (true) {
          const i = _tmp;
          if (i < len) {
            if (!moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$subset(moonbitlang$core$array$$Array$op_get$85$(self_table, i), moonbitlang$core$array$$Array$op_get$85$(other_table, i))) {
              return false;
            }
            _tmp = i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        return true;
      }
    }
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$weak_compat(self, other) {
  if (moonbitlang$core$builtin$$Eq$op_equal$163$(self.core, other.core)) {
    const len = self.kernel_lookahead_set_table.length;
    let _tmp = 0;
    while (true) {
      const i = _tmp;
      if (i < len) {
        const la_set1i = moonbitlang$core$array$$Array$op_get$85$(self.kernel_lookahead_set_table, i);
        const la_set2i = moonbitlang$core$array$$Array$op_get$85$(other.kernel_lookahead_set_table, i);
        let _tmp$2 = i;
        while (true) {
          const j = _tmp$2;
          if (j < len) {
            _L: {
              if (i !== j) {
                const la_set1j = moonbitlang$core$array$$Array$op_get$85$(self.kernel_lookahead_set_table, j);
                const la_set2j = moonbitlang$core$array$$Array$op_get$85$(other.kernel_lookahead_set_table, j);
                const compat = moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(la_set1i, la_set2j) && moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(la_set2i, la_set1j) || (!moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(la_set1i, la_set1j) || !moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$disjoint(la_set2i, la_set2j));
                if (!compat) {
                  return false;
                }
              } else {
                break _L;
              }
              break _L;
            }
            _tmp$2 = j + 1 | 0;
            continue;
          } else {
            break;
          }
        }
        _tmp = i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    return true;
  } else {
    return $panic();
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$31$(_x_352, _x_353) {
  return _x_352 === _x_353;
}
function moonbitlang$core$builtin$$Compare$compare$31$(_x_348, _x_349) {
  return $compare_int(_x_348, _x_349);
}
function moonbitlang$core$builtin$$Hash$hash_combine$31$(_x_344, _x_345) {
  moonbitlang$core$builtin$$Hash$hash_combine$28$(_x_344, _x_345);
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0Item$new(production, dot) {
  return production.num << 10 | dot;
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_production(self, grammar) {
  return moonbitlang$core$array$$Array$op_get$26$(grammar.productions, self >> 10);
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_postdot(self, grammar) {
  const production = moonbitlang$core$array$$Array$op_get$26$(grammar.productions, self >> 10);
  const dot = self & 1023;
  return moonbitlang$core$array$$Array$get$45$(production.rhs, dot);
}
function moonbitlang$yacc$lib$lr1$$EncodedLR0Item$unsafe_shift(self) {
  return self + 1 | 0;
}
function moonbitlang$yacc$lib$lr1$$EpsilonLookaheadSet$op_add$118$(set1, set2) {
  return set1.nullable ? { set: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$union(set1.set, set2.set), nullable: set2.nullable } : set1;
}
function moonbitlang$yacc$lib$lr1$$EpsilonLookaheadSet$union$118$(set1, set2) {
  return { set: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$union(set1.set, set2.set), nullable: set1.nullable || set2.nullable };
}
function moonbitlang$yacc$lib$lr1$$compute_first_fn$118$(grammar) {
  const nt_first_map = moonbitlang$core$array$$Array$make$83$(grammar.nonterminals.length, undefined);
  const first = (symbols) => {
    if (symbols.len === 0) {
      return { set: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$empty(), nullable: true };
    } else {
      const _x = symbols.buf[symbols.start + 0 | 0];
      const _tmp = symbols.buf;
      const _tmp$2 = 1 + symbols.start | 0;
      const _some = symbols.len - 0 | 0;
      const _x$2 = { buf: _tmp, start: _tmp$2, len: _some - 1 | 0 };
      let _tmp$3;
      if (_x.$tag === 0) {
        const _T = _x;
        const _x$3 = _T._0;
        _tmp$3 = { set: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$singleton(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(_x$3)), nullable: false };
      } else {
        const _NT = _x;
        const _x$3 = _NT._0;
        const _bind = moonbitlang$core$array$$Array$op_get$83$(nt_first_map, _x$3.num);
        if (_bind === undefined) {
          moonbitlang$core$array$$Array$op_set$83$(nt_first_map, _x$3.num, { set: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$empty(), nullable: false });
          const set = moonbitlang$core$array$$Array$fold$151$(_x$3.productions, { set: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$empty(), nullable: false }, (acc, p) => {
            const _bind$2 = p.rhs;
            return moonbitlang$yacc$lib$lr1$$EpsilonLookaheadSet$union$118$(acc, first({ buf: _bind$2, start: 0, len: _bind$2.length }));
          });
          moonbitlang$core$array$$Array$op_set$83$(nt_first_map, _x$3.num, set);
          _tmp$3 = set;
        } else {
          const _Some = _bind;
          const _x$4 = _Some;
          _tmp$3 = _x$4;
        }
      }
      return moonbitlang$yacc$lib$lr1$$EpsilonLookaheadSet$op_add$118$(_tmp$3, first(_x$2));
    }
  };
  return first;
}
function moonbitlang$yacc$lib$lr1$$build_closure_fn$118$(grammar) {
  const first = moonbitlang$yacc$lib$lr1$$compute_first_fn$118$(grammar);
  const node_by_item = moonbitlang$core$hashmap$$new$64$(moonbitlang$core$hashmap$$new$46$capacity$46$default$64$());
  const _arr = grammar.productions;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const production = _arr[_i];
      const _end237 = production.rhs.length;
      let _tmp$2 = 0;
      while (true) {
        const dot = _tmp$2;
        if (dot <= _end237) {
          const item = moonbitlang$yacc$lib$lr1$$EncodedLR0Item$new(production, dot);
          const partial_lookahead_set = dot < production.rhs.length ? first(moonbitlang$core$array$$Array$op_as_view$45$(production.rhs, dot + 1 | 0, undefined)) : { set: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$empty(), nullable: false };
          const node = { item: item, partial_lookahead_set: partial_lookahead_set, epsilon_transitions: [], stamp: moonbitlang$yacc$lib$util$stamp$$initial(), predecessors: $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$21$, lookahead_set: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$empty() };
          moonbitlang$core$hashmap$$T$op_set$64$(node_by_item, item, node);
          _tmp$2 = dot + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _bind = moonbitlang$core$hashmap$$T$iter$64$(node_by_item);
  _bind((pair) => {
    const node = pair._1;
    const _bind$2 = moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_postdot(node.item, grammar);
    if (_bind$2 === undefined) {
    } else {
      const _Some = _bind$2;
      const _x = _Some;
      if (_x.$tag === 0) {
      } else {
        const _NT = _x;
        const _x$2 = _NT._0;
        const _arr$2 = _x$2.productions;
        const _len$2 = _arr$2.length;
        let _tmp$2 = 0;
        while (true) {
          const _i = _tmp$2;
          if (_i < _len$2) {
            const production = _arr$2[_i];
            const encoded_item = moonbitlang$yacc$lib$lr1$$EncodedLR0Item$new(production, 0);
            moonbitlang$core$array$$Array$push$56$(node.epsilon_transitions, moonbitlang$core$option$$Option$unwrap$56$(moonbitlang$core$hashmap$$T$op_get$64$(node_by_item, encoded_item)));
            _tmp$2 = _i + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
    }
    return 1;
  });
  return (item_set) => {
    const stamp = moonbitlang$yacc$lib$util$stamp$$new();
    const nodes = [];
    const _env = { _0: stamp, _1: nodes };
    item_set((item) => {
      const _x = item._0;
      const _x$2 = item._1;
      const node = moonbitlang$core$option$$Option$unwrap$56$(moonbitlang$core$hashmap$$T$op_get$64$(node_by_item, _x));
      node.lookahead_set = _x$2;
      moonbitlang$yacc$lib$lr1$$build_closure_fn$46$follow$47$4457(_env, node);
      return 1;
    });
    const stamp$2 = moonbitlang$yacc$lib$util$stamp$$new();
    const _len$2 = nodes.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len$2) {
        const node = nodes[_i];
        moonbitlang$yacc$lib$lr1$$build_closure_fn$46$walk$47$4458(stamp$2, node);
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const closure = moonbitlang$core$array$$Array$map$130$(nodes, (node) => ({ _0: node.item, _1: node.lookahead_set }));
    const _len$3 = nodes.length;
    let _tmp$3 = 0;
    while (true) {
      const _i = _tmp$3;
      if (_i < _len$3) {
        const node = nodes[_i];
        node.predecessors = $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$21$;
        node.lookahead_set = moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$empty();
        _tmp$3 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$array$$Array$sort_by_key$30$(closure, (pair) => pair._0);
    return closure;
  };
}
function moonbitlang$yacc$lib$lr1$$build_closure_fn$46$visit$47$4456(_env, node, lookahead_set, parent) {
  const stamp = _env._0;
  if (lookahead_set.nullable) {
    node.predecessors = new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$21$(parent, node.predecessors);
  }
  if (moonbitlang$core$builtin$$Eq$op_equal$78$(node.stamp, stamp)) {
    node.lookahead_set = moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$union(node.lookahead_set, lookahead_set.set);
    return;
  } else {
    node.lookahead_set = lookahead_set.set;
    moonbitlang$yacc$lib$lr1$$build_closure_fn$46$follow$47$4457(_env, node);
    return;
  }
}
function moonbitlang$yacc$lib$lr1$$build_closure_fn$46$follow$47$4457(_env, node) {
  const nodes = _env._1;
  const stamp = _env._0;
  node.stamp = stamp;
  moonbitlang$core$array$$Array$push$56$(nodes, node);
  const _arr = node.epsilon_transitions;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const epsilon_transition = _arr[_i];
      moonbitlang$yacc$lib$lr1$$build_closure_fn$46$visit$47$4456(_env, epsilon_transition, node.partial_lookahead_set, node);
      _tmp = _i + 1 | 0;
      continue;
    } else {
      return;
    }
  }
}
function moonbitlang$yacc$lib$lr1$$build_closure_fn$46$walk$47$4458(stamp, node) {
  if (moonbitlang$core$builtin$$op_notequal$78$(node.stamp, stamp)) {
    node.stamp = stamp;
    const _bind = moonbitlang$core$immut$list$$T$iter$56$(node.predecessors);
    _bind((predecessor) => {
      moonbitlang$yacc$lib$lr1$$build_closure_fn$46$walk$47$4458(stamp, predecessor);
      node.lookahead_set = moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$union(node.lookahead_set, predecessor.lookahead_set);
      return 1;
    });
    return;
  } else {
    return;
  }
}
function moonbitlang$yacc$lib$lr1$$resolve_conflicts(conflicts) {
  const errors = [];
  const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$iter2$115$(conflicts);
  _bind((location, decisions) => {
    const _x = location.state;
    const _x$2 = location.input;
    const shift = [];
    const reduce = [];
    const _bind$2 = moonbitlang$core$immut$list$$T$iter$55$(decisions);
    _bind$2((decision) => {
      switch (decision.$tag) {
        case 0: {
          const _Shift = decision;
          const _x$3 = _Shift._0;
          moonbitlang$core$array$$Array$push$88$(shift, { _0: _x$2, _1: _x$3 });
          break;
        }
        case 1: {
          const _Reduce = decision;
          const _x$4 = _Reduce._0;
          moonbitlang$core$array$$Array$push$26$(reduce, _x$4);
          break;
        }
        case 2: {
          $panic();
          break;
        }
        default: {
          $panic();
        }
      }
      return 1;
    });
    if (shift.length <= 1) {
      if (reduce.length >= 1) {
        moonbitlang$core$array$$Array$sort_by_key$32$(reduce, (prod) => prod.num);
        const best_reduce = moonbitlang$core$array$$Array$op_get$26$(reduce, 0);
        moonbitlang$core$array$$Array$push$120$(errors, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Reduce_conflict_resolved_by_presentation_order(_x, _x$2, reduce, best_reduce));
        let decision;
        if (shift.length === 0) {
          decision = new Result$Ok$22$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(best_reduce));
        } else {
          if (shift.length === 1) {
            const _x$3 = moonbitlang$core$array$$Array$op_get$88$(shift, 0);
            const _x$4 = _x$3._0;
            const _x$5 = _x$3._1;
            let term_prec;
            if (_x$4.$tag === 1) {
              const _Input = _x$4;
              const _x$6 = _Input._0;
              term_prec = _x$6.prec;
            } else {
              term_prec = undefined;
            }
            const _bind$3 = best_reduce.prec;
            if (term_prec === undefined) {
              if (_bind$3 === undefined) {
                moonbitlang$core$array$$Array$push$120$(errors, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_resolved_without_precedence(_x, _x$4, _x$5, best_reduce));
                decision = new Result$Ok$22$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(_x$5));
              } else {
                decision = new Result$Ok$22$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(best_reduce));
              }
            } else {
              const _Some = term_prec;
              if (_bind$3 === undefined) {
                decision = new Result$Ok$22$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(_x$5));
              } else {
                const _x$6 = _Some;
                const _x$7 = _x$6._0;
                const _x$8 = _x$6._1;
                const _Some$2 = _bind$3;
                const _x$9 = _Some$2;
                if (_x$7 > _x$9) {
                  decision = new Result$Ok$22$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(_x$5));
                } else {
                  if (_x$9 > _x$7) {
                    decision = new Result$Ok$22$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(best_reduce));
                  } else {
                    switch (_x$8) {
                      case 0: {
                        decision = new Result$Ok$22$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(best_reduce));
                        break;
                      }
                      case 1: {
                        decision = new Result$Ok$22$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(_x$5));
                        break;
                      }
                      default: {
                        decision = new Result$Err$22$(new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$ResolveConflictError$Shift_reduce_conflict_not_resolved_because_of_non_assoc(_x, _x$4, _x$5, best_reduce));
                      }
                    }
                  }
                }
              }
            }
          } else {
            decision = $panic();
          }
        }
        if (decision.$tag === 1) {
          const _Ok = decision;
          const _x$3 = _Ok._0;
          moonbitlang$core$sorted_map$$T$op_set$41$(_x.action, _x$2, _x$3);
        } else {
          const _Err = decision;
          const _x$3 = _Err._0;
          moonbitlang$core$array$$Array$push$120$(errors, _x$3);
        }
      } else {
        $panic();
      }
    } else {
      $panic();
    }
    return 1;
  });
  return errors;
}
function moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$empty() {
  return moonbitlang$yacc$lib$lr1$$_empty;
}
function moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$singleton(lookahead) {
  return { concrete_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$singleton(lookahead), vars: moonbitlang$yacc$lib$util$small_int_set$$empty() };
}
function moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$variable(var_) {
  return { concrete_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$empty(), vars: moonbitlang$yacc$lib$util$small_int_set$$singleton(var_) };
}
function moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$union(self, other) {
  return { concrete_set: moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$union(self.concrete_set, other.concrete_set), vars: moonbitlang$yacc$lib$util$small_int_set$$SmallIntSet$union(self.vars, other.vars) };
}
function moonbitlang$core$builtin$$Show$output$111$(self, logger) {
  logger.method_0(logger.self, "[");
  moonbitlang$core$builtin$$Logger$write_object$28$(logger, self.core.production.num);
  logger.method_0(logger.self, ", ");
  moonbitlang$yacc$lib$grm$$Production$output_with_opt_dot$155$(self.core.production, logger, self.core.dot);
  logger.method_0(logger.self, ", ");
  const first = { val: true };
  const _bind = self.lookahead_set;
  _bind((lookahead) => {
    if (!first.val) {
      logger.method_0(logger.self, " / ");
    }
    moonbitlang$core$builtin$$Logger$write_object$44$(logger, lookahead);
    first.val = false;
    return 1;
  });
  logger.method_0(logger.self, "]");
}
function moonbitlang$core$builtin$$Eq$op_equal$55$(_x_174, _x_175) {
  switch (_x_174.$tag) {
    case 0: {
      const _Shift = _x_174;
      const _x = _Shift._0;
      if (_x_175.$tag === 0) {
        const _Shift$2 = _x_175;
        const _x$2 = _Shift$2._0;
        return moonbitlang$core$builtin$$Eq$op_equal$106$(_x, _x$2);
      } else {
        return false;
      }
    }
    case 1: {
      const _Reduce = _x_174;
      const _x$2 = _Reduce._0;
      if (_x_175.$tag === 1) {
        const _Reduce$2 = _x_175;
        const _x$3 = _Reduce$2._0;
        return moonbitlang$core$builtin$$Eq$op_equal$26$(_x$2, _x$3);
      } else {
        return false;
      }
    }
    case 2: {
      if (_x_175.$tag === 2) {
        return true;
      } else {
        return false;
      }
    }
    default: {
      const _Conflict = _x_174;
      const _x$3 = _Conflict._0;
      if (_x_175.$tag === 3) {
        const _Conflict$2 = _x_175;
        const _x$4 = _Conflict$2._0;
        return moonbitlang$core$builtin$$Eq$op_equal$54$(_x$3, _x$4);
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$163$(self, other) {
  return self.num === other.num;
}
function moonbitlang$core$builtin$$Eq$op_equal$106$(self, other) {
  return self.num === other.num;
}
function moonbitlang$core$builtin$$Hash$hash_combine$106$(self, hasher) {
  moonbitlang$core$builtin$$Hasher$combine_int(hasher, self.num);
}
function moonbitlang$yacc$lib$lr1$$LR1State$iter_item_groups(self) {
  return moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$decode_item_groups(self.items, self.grammar);
}
function moonbitlang$yacc$lib$lr1$$LR1State$set_action(self, input, decision) {
  const _bind = moonbitlang$core$sorted_map$$T$op_get$41$(self.action, input);
  if (_bind === undefined) {
    moonbitlang$core$sorted_map$$T$op_set$41$(self.action, input, decision);
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 3) {
      const _Conflict = _x;
      const _x$2 = _Conflict._0;
      if (!moonbitlang$core$immut$list$$T$contains$55$(_x$2, decision)) {
        moonbitlang$core$sorted_map$$T$op_set$41$(self.action, input, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Conflict(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$23$(decision, _x$2)));
        return;
      } else {
        return;
      }
    } else {
      if (moonbitlang$core$builtin$$op_notequal$55$(_x, decision)) {
        moonbitlang$core$sorted_map$$T$op_set$41$(self.action, input, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Conflict(new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$23$(decision, new $64$moonbitlang$47$core$47$immut$47$list$46$T$Cons$23$(_x, $64$moonbitlang$47$core$47$immut$47$list$46$T$Nil$23$))));
        return;
      } else {
        return;
      }
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$91$(_x_152, _x_153) {
  return moonbitlang$core$builtin$$Eq$op_equal$106$(_x_152.state, _x_153.state) && moonbitlang$core$builtin$$Eq$op_equal$44$(_x_152.input, _x_153.input);
}
function moonbitlang$core$builtin$$Hash$hash_combine$91$(_x_148, _x_149) {
  moonbitlang$core$builtin$$Hash$hash_combine$106$(_x_148.state, _x_149);
  moonbitlang$core$builtin$$Hash$hash_combine$44$(_x_148.input, _x_149);
}
function moonbitlang$yacc$lib$lr1$$build$46$explore$164$(_env, kernel_items) {
  const grammar = _env._4;
  const node_transitions = _env._3;
  const node_by_kernel_items = _env._2;
  const closure = _env._1;
  const node_reductions = _env._0;
  const defer = { val: undefined };
  const node = moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$161$(node_by_kernel_items, kernel_items, (kernel_items$2) => {
    const symbolic_items = closure(moonbitlang$core$array$$Array$iter$25$(moonbitlang$core$array$$Array$mapi$150$(kernel_items$2.items, (index, item) => ({ _0: item, _1: moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$variable(index) }))));
    const node$2 = { num: moonbitlang$yacc$lib$util$hashmap2$$T$size$161$(node_by_kernel_items), closure_items: moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$from_sorted_array(moonbitlang$core$array$$Array$map$30$(symbolic_items, (item) => item._0)), closure_symbolic_lookahead_set: moonbitlang$core$array$$Array$map$129$(symbolic_items, (item) => item._1) };
    defer.val = symbolic_items;
    return node$2;
  });
  const _bind = defer.val;
  if (_bind === undefined) {
  } else {
    const _Some = _bind;
    const _x = _Some;
    const result = [];
    const _len = _x.length;
    let _tmp = 0;
    while (true) {
      const _i = _tmp;
      if (_i < _len) {
        const symbolic_item = _x[_i];
        const _x$2 = symbolic_item._0;
        const _x$3 = symbolic_item._1;
        const _bind$2 = moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_postdot(_x$2, grammar);
        if (_bind$2 === undefined) {
          moonbitlang$core$array$$Array$push$119$(result, { _0: _x$3, _1: moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_production(_x$2, grammar) });
        }
        _tmp = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$array$$Array$push$89$(node_reductions, result);
    moonbitlang$core$array$$Array$push$90$(node_transitions, moonbitlang$yacc$lib$util$hashmap2$$new$160$(16));
    const trans = moonbitlang$yacc$lib$util$hashmap2$$new$159$(16);
    const _len$2 = _x.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len$2) {
        const entry = _x[_i];
        const _x$2 = entry._0;
        const _x$3 = entry._1;
        const _bind$2 = moonbitlang$yacc$lib$lr1$$EncodedLR0Item$decode_postdot(_x$2, grammar);
        if (_bind$2 === undefined) {
        } else {
          const _Some$2 = _bind$2;
          const _x$4 = _Some$2;
          const next_item = moonbitlang$yacc$lib$lr1$$EncodedLR0Item$unsafe_shift(_x$2);
          const _bind$3 = moonbitlang$yacc$lib$util$hashmap2$$T$get_or_init$159$(trans, _x$4, (_arg) => ({ _0: [], _1: [] }));
          const _x$5 = _bind$3._0;
          const _x$6 = _bind$3._1;
          moonbitlang$core$array$$Array$push$31$(_x$5, next_item);
          moonbitlang$core$array$$Array$push$118$(_x$6, _x$3);
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _bind$2 = moonbitlang$yacc$lib$util$hashmap2$$T$iter$159$(trans);
    _bind$2((tran) => {
      const _x$2 = tran._0;
      const _x$3 = tran._1;
      const _x$4 = _x$3._0;
      const _x$5 = _x$3._1;
      const target = moonbitlang$yacc$lib$lr1$$build$46$explore$164$(_env, moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$from_sorted_array(_x$4));
      moonbitlang$yacc$lib$util$hashmap2$$T$set$160$(moonbitlang$core$array$$Array$op_get$90$(node_transitions, node.num), _x$2, { _0: target, _1: _x$5 });
      return 1;
    });
  }
  return node;
}
function moonbitlang$yacc$lib$lr1$$build$46$fuse$165$(_env, family, candidate) {
  const queue = _env._1;
  const next_state_num = _env._0;
  let _tmp = family;
  let _tmp$2 = candidate;
  _L: while (true) {
    const family$2 = _tmp;
    const candidate$2 = _tmp$2;
    const _len = family$2.length;
    let _tmp$3 = 0;
    while (true) {
      const _i = _tmp$3;
      if (_i < _len) {
        const state = family$2[_i];
        if (moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$weak_compat(state.items, candidate$2.items)) {
          const new_state = { items: moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$merge(candidate$2.items, state.items), state: undefined };
          next_state_num.val = next_state_num.val + 1 | 0;
          const _bind = moonbitlang$core$array$$Array$search_by$77$(family$2, (it) => it === state);
          if (_bind === undefined) {
          } else {
            const _Some = _bind;
            const _x = _Some;
            moonbitlang$core$array$$Array$remove$77$(family$2, _x);
          }
          _tmp$2 = new_state;
          continue _L;
        }
        _tmp$3 = _i + 1 | 0;
        continue;
      } else {
        moonbitlang$core$array$$Array$push$77$(family$2, candidate$2);
        moonbitlang$core$array$$Array$push$77$(queue, candidate$2);
        return;
      }
    }
  }
}
function moonbitlang$yacc$lib$lr1$$build$46$state_from_pre$166$(_env, pre_state) {
  const grammar = _env._1;
  const next_state_num = _env._0;
  const _bind = pre_state.state;
  if (_bind === undefined) {
    const state = { grammar: grammar, num: next_state_num.val, items: pre_state.items, goto: moonbitlang$core$sorted_map$$new$40$(), action: moonbitlang$core$sorted_map$$new$41$(), stamp: moonbitlang$yacc$lib$util$stamp$$initial() };
    next_state_num.val = next_state_num.val + 1 | 0;
    pre_state.state = state;
    return state;
  } else {
    const _Some = _bind;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$yacc$lib$lr1$$build$46$check_add_conflict$167$(conflicts, state, input) {
  const _bind = moonbitlang$core$sorted_map$$T$op_get$41$(state.action, input);
  if (_bind === undefined) {
    return;
  } else {
    const _Some = _bind;
    const _x = _Some;
    if (_x.$tag === 3) {
      const _Conflict = _x;
      const _x$2 = _Conflict._0;
      moonbitlang$yacc$lib$util$hashmap2$$T$set$115$(conflicts, { state: state, input: input }, _x$2);
      return;
    } else {
      return;
    }
  }
}
function moonbitlang$yacc$lib$lr1$$Automaton$build(grammar) {
  const closure = moonbitlang$yacc$lib$lr1$$build_closure_fn$118$(grammar);
  const node_by_kernel_items = moonbitlang$yacc$lib$util$hashmap2$$new$161$(65536);
  const node_transitions = [];
  const node_reductions = [];
  const node_starts = [];
  const _env = { _0: node_reductions, _1: closure, _2: node_by_kernel_items, _3: node_transitions, _4: grammar };
  const _arr = grammar.starts;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const start_production = _arr[_i];
      moonbitlang$core$array$$Array$push$122$(node_starts, { _0: moonbitlang$yacc$lib$lr1$$build$46$explore$164$(_env, moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$from_sorted_array([moonbitlang$yacc$lib$lr1$$EncodedLR0Item$new(start_production, 0)])), _1: start_production });
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const next_state_num = { val: 0 };
  const starts = [];
  const families = moonbitlang$core$array$$FixedArray$makei$29$(moonbitlang$yacc$lib$util$hashmap2$$T$size$161$(node_by_kernel_items), (_i) => []);
  const queue = [];
  const _len$2 = node_starts.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const entry = node_starts[_i];
      const _x = entry._0;
      const _x$2 = entry._1;
      const start_state = { items: { core: _x, kernel_lookahead_set_table: [moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$end_of_input()] }, state: undefined };
      moonbitlang$core$array$$Array$push$77$(families[start_state.items.core.num], start_state);
      next_state_num.val = next_state_num.val + 1 | 0;
      moonbitlang$core$array$$Array$push$121$(starts, { _0: _x$2, _1: start_state });
      moonbitlang$core$array$$Array$push$77$(queue, start_state);
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _env$2 = { _0: next_state_num, _1: queue };
  while (true) {
    if (!moonbitlang$core$array$$Array$is_empty$77$(queue)) {
      const state = moonbitlang$core$array$$Array$unsafe_pop$77$(queue);
      const trans = moonbitlang$core$array$$Array$op_get$90$(node_transitions, state.items.core.num);
      const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$iter$160$(trans);
      _bind((entry) => {
        const _x = entry._1;
        const _x$2 = _x._0;
        const _x$3 = _x._1;
        const kernel_lookahead_set_table = moonbitlang$core$array$$Array$map$133$(_x$3, (symbolic_lookahead_set) => moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(symbolic_lookahead_set, state.items.kernel_lookahead_set_table));
        const target_state = { items: { core: _x$2, kernel_lookahead_set_table: kernel_lookahead_set_table }, state: undefined };
        next_state_num.val = next_state_num.val + 1 | 0;
        let _return_value;
        _L: {
          _L$2: {
            const family = families[target_state.items.core.num];
            const _len$3 = family.length;
            let _tmp$3 = 0;
            while (true) {
              const _i = _tmp$3;
              if (_i < _len$3) {
                const state$2 = family[_i];
                if (moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$subsume(target_state.items, state$2.items)) {
                  _return_value = undefined;
                  break _L$2;
                }
                _tmp$3 = _i + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            moonbitlang$yacc$lib$lr1$$build$46$fuse$165$(_env$2, family, target_state);
            break _L;
          }
        }
        return 1;
      });
      continue;
    } else {
      break;
    }
  }
  const states = [];
  const _env$3 = { _0: next_state_num, _1: grammar };
  const queue$2 = [];
  const _len$3 = starts.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$3) {
      const entry = starts[_i];
      const _x = entry._1;
      moonbitlang$core$array$$Array$push$106$(queue$2, moonbitlang$yacc$lib$lr1$$build$46$state_from_pre$166$(_env$3, _x));
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const stamp = moonbitlang$yacc$lib$util$stamp$$new();
  while (true) {
    if (!moonbitlang$core$array$$Array$is_empty$106$(queue$2)) {
      const state = moonbitlang$core$array$$Array$unsafe_pop$106$(queue$2);
      if (moonbitlang$core$builtin$$Eq$op_equal$78$(state.stamp, stamp)) {
        continue;
      }
      state.stamp = stamp;
      moonbitlang$core$array$$Array$push$106$(states, state);
      const trans = moonbitlang$core$array$$Array$op_get$90$(node_transitions, state.items.core.num);
      const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$iter$160$(trans);
      _bind((entry) => {
        const _x = entry._0;
        const _x$2 = entry._1;
        const _x$3 = _x$2._0;
        const _x$4 = _x$2._1;
        const family = families[_x$3.num];
        let pre_state;
        if (family.length === 0) {
          pre_state = $panic();
        } else {
          if (family.length === 1) {
            const _x$5 = moonbitlang$core$array$$Array$op_get$77$(family, 0);
            pre_state = _x$5;
          } else {
            const kernel_lookahead_set_table = moonbitlang$core$array$$Array$map$133$(_x$4, (symbolic_lookahead_set) => moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(symbolic_lookahead_set, state.items.kernel_lookahead_set_table));
            const next_items = { core: _x$3, kernel_lookahead_set_table: kernel_lookahead_set_table };
            pre_state = moonbitlang$core$option$$Option$unwrap$77$(moonbitlang$core$builtin$$Iter$find_first$77$(moonbitlang$core$array$$Array$iter$77$(family), (state$2) => moonbitlang$yacc$lib$lr1$$EncodedLR1ItemSet$subsume(next_items, state$2.items)));
          }
        }
        const target_state = moonbitlang$yacc$lib$lr1$$build$46$state_from_pre$166$(_env$3, pre_state);
        moonbitlang$core$sorted_map$$T$op_set$40$(state.goto, _x, target_state);
        if (moonbitlang$core$builtin$$op_notequal$78$(target_state.stamp, stamp)) {
          moonbitlang$core$array$$Array$push$106$(queue$2, target_state);
        }
        return 1;
      });
      continue;
    } else {
      break;
    }
  }
  const _len$4 = states.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$4) {
      const state = states[_i];
      state.num = _i;
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const conflicts = moonbitlang$yacc$lib$util$hashmap2$$new$115$(16);
  const _len$5 = states.length;
  let _tmp$5 = 0;
  while (true) {
    const _i = _tmp$5;
    if (_i < _len$5) {
      const state = states[_i];
      const core = state.items.core;
      const _bind = moonbitlang$yacc$lib$util$hashmap2$$T$iter$160$(moonbitlang$core$array$$Array$op_get$90$(node_transitions, core.num));
      _bind((tran) => {
        const _x = tran._0;
        if (_x.$tag === 1) {
        } else {
          const _T = _x;
          const _x$2 = _T._0;
          moonbitlang$yacc$lib$lr1$$LR1State$set_action(state, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(_x$2), new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Shift(moonbitlang$core$option$$Option$unwrap$106$(moonbitlang$core$sorted_map$$T$op_get$40$(state.goto, new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$T(_x$2)))));
          moonbitlang$yacc$lib$lr1$$build$46$check_add_conflict$167$(conflicts, state, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$Input(_x$2));
        }
        return 1;
      });
      const _arr$2 = moonbitlang$core$array$$Array$op_get$89$(node_reductions, core.num);
      const _len$6 = _arr$2.length;
      let _tmp$6 = 0;
      while (true) {
        const _i$2 = _tmp$6;
        if (_i$2 < _len$6) {
          const reduction = _arr$2[_i$2];
          const _x = reduction._0;
          const _x$2 = reduction._1;
          const lookahead_set = moonbitlang$yacc$lib$lr1$$EncodedSymbolicLookaheadSet$interpret(_x, state.items.kernel_lookahead_set_table);
          const _bind$2 = moonbitlang$yacc$lib$lr1$$EncodedLR0ItemSet$decode_iter(core.closure_items, grammar);
          _bind$2((item) => {
            const _bind$3 = moonbitlang$yacc$lib$lr1$$EncodedLookaheadSet$decode_iter(lookahead_set, grammar);
            _bind$3((lookahead) => {
              if (moonbitlang$core$builtin$$Eq$op_equal$44$(lookahead, $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Lookahead$EndOfInput) && (moonbitlang$core$array$$Array$contains$26$(grammar.starts, _x$2) && item._1.dot === 1)) {
                moonbitlang$yacc$lib$lr1$$LR1State$set_action(state, lookahead, $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Accept);
              } else {
                moonbitlang$yacc$lib$lr1$$LR1State$set_action(state, lookahead, new $64$moonbitlang$47$yacc$47$lib$47$lr1$46$Decision$Reduce(_x$2));
              }
              moonbitlang$yacc$lib$lr1$$build$46$check_add_conflict$167$(conflicts, state, lookahead);
              return 1;
            });
            return 1;
          });
          _tmp$6 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp$5 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const starts$2 = moonbitlang$core$array$$Array$map$132$(starts, (entry) => {
    const _x = entry._0;
    const _x$2 = entry._1;
    return { _0: _x, _1: moonbitlang$yacc$lib$lr1$$build$46$state_from_pre$166$(_env$3, _x$2) };
  });
  return { states: states, starts: starts$2, conflicts: conflicts };
}
function moonbitlang$yacc$lib$driver$util$$exit$157$(code) {
  moonbitlang$yacc$lib$driver$util$$ffi_exit(code);
  return $panic();
}
function moonbitlang$yacc$lib$driver$util$$exit$4$(code) {
  moonbitlang$yacc$lib$driver$util$$ffi_exit(code);
  $panic();
}
function moonbitlang$yacc$lib$driver$util$$exit$15$(code) {
  moonbitlang$yacc$lib$driver$util$$ffi_exit(code);
  return $panic();
}
function moonbitlang$yacc$lib$util$logger_with_cursor$$new(logger, cursor) {
  return { logger: logger, cursor: cursor };
}
function moonbitlang$yacc$lib$util$logger_with_cursor$$new$46$cursor$46$default() {
  return 0;
}
function moonbitlang$yacc$lib$util$logger_with_cursor$$LoggerWithCursor$cursor(self) {
  return self.cursor;
}
function moonbitlang$core$builtin$$Logger$write_char$143$(self, char) {
  const _tmp = self.logger;
  _tmp.method_3(_tmp.self, char);
  self.cursor = self.cursor + 1 | 0;
}
function moonbitlang$core$builtin$$Logger$write_string$143$(self, str) {
  const _tmp = self.logger;
  _tmp.method_0(_tmp.self, str);
  self.cursor = self.cursor + str.length | 0;
}
function moonbitlang$core$builtin$$Logger$write_substring$143$(self, str, start, len) {
  const _tmp = self.logger;
  _tmp.method_2(_tmp.self, str, start, len);
  self.cursor = self.cursor + len | 0;
}
function moonbitlang$core$builtin$$Compare$compare$33$(_x_242, _x_243) {
  switch (_x_242.$tag) {
    case 0: {
      const _T = _x_242;
      const _x = _T._0;
      const _x$2 = _T._1;
      if (_x_243.$tag === 0) {
        const _T$2 = _x_243;
        const _x$3 = _T$2._0;
        const _x$4 = _T$2._1;
        const _bind = $compare_int(_x, _x$3);
        if (_bind === 0) {
          return moonbitlang$core$string$$String$compare(_x$2, _x$4);
        } else {
          return _bind;
        }
      } else {
        return -1;
      }
    }
    case 1: {
      const _NT = _x_242;
      const _x$3 = _NT._0;
      const _x$4 = _NT._1;
      switch (_x_243.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          const _NT$2 = _x_243;
          const _x$5 = _NT$2._0;
          const _x$6 = _NT$2._1;
          const _bind = $compare_int(_x$3, _x$5);
          if (_bind === 0) {
            return moonbitlang$core$string$$String$compare(_x$4, _x$6);
          } else {
            return _bind;
          }
        }
        default: {
          return -1;
        }
      }
    }
    default: {
      switch (_x_243.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        default: {
          return 0;
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$CodegenSymbol$to_string(self) {
  switch (self.$tag) {
    case 0: {
      const _T = self;
      const _x = _T._1;
      return `T_${_x}`;
    }
    case 1: {
      const _NT = self;
      const _x$2 = _NT._1;
      return `NT_${_x$2}`;
    }
    default: {
      return "EOI";
    }
  }
}
function moonbitlang$core$builtin$$Eq$op_equal$43$(_x_207, _x_208) {
  switch (_x_207.$tag) {
    case 0: {
      if (_x_208.$tag === 0) {
        return true;
      } else {
        return false;
      }
    }
    case 1: {
      const _Shift = _x_207;
      const _x = _Shift._0;
      if (_x_208.$tag === 1) {
        const _Shift$2 = _x_208;
        const _x$2 = _Shift$2._0;
        return _x === _x$2;
      } else {
        return false;
      }
    }
    case 2: {
      const _Reduce = _x_207;
      const _x$2 = _Reduce._0;
      const _x$3 = _Reduce._1;
      const _x$4 = _Reduce._2;
      if (_x_208.$tag === 2) {
        const _Reduce$2 = _x_208;
        const _x$5 = _Reduce$2._0;
        const _x$6 = _Reduce$2._1;
        const _x$7 = _Reduce$2._2;
        return _x$2 === _x$5 && (_x$3 === _x$6 && _x$4 === _x$7);
      } else {
        return false;
      }
    }
    default: {
      const _ReduceNoLookahead = _x_207;
      const _x$5 = _ReduceNoLookahead._0;
      const _x$6 = _ReduceNoLookahead._1;
      const _x$7 = _ReduceNoLookahead._2;
      if (_x_208.$tag === 3) {
        const _ReduceNoLookahead$2 = _x_208;
        const _x$8 = _ReduceNoLookahead$2._0;
        const _x$9 = _ReduceNoLookahead$2._1;
        const _x$10 = _ReduceNoLookahead$2._2;
        return _x$5 === _x$8 && (_x$6 === _x$9 && _x$7 === _x$10);
      } else {
        return false;
      }
    }
  }
}
function moonbitlang$core$builtin$$Compare$compare$43$(_x_167, _x_168) {
  switch (_x_167.$tag) {
    case 0: {
      if (_x_168.$tag === 0) {
        return 0;
      } else {
        return -1;
      }
    }
    case 1: {
      const _Shift = _x_167;
      const _x = _Shift._0;
      switch (_x_168.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          const _Shift$2 = _x_168;
          const _x$2 = _Shift$2._0;
          return $compare_int(_x, _x$2);
        }
        default: {
          return -1;
        }
      }
    }
    case 2: {
      const _Reduce = _x_167;
      const _x$3 = _Reduce._0;
      const _x$4 = _Reduce._1;
      const _x$5 = _Reduce._2;
      switch (_x_168.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          const _Reduce$2 = _x_168;
          const _x$6 = _Reduce$2._0;
          const _x$7 = _Reduce$2._1;
          const _x$8 = _Reduce$2._2;
          const _bind = $compare_int(_x$3, _x$6);
          if (_bind === 0) {
            const _bind$2 = moonbitlang$core$string$$String$compare(_x$4, _x$7);
            if (_bind$2 === 0) {
              return $compare_int(_x$5, _x$8);
            } else {
              return _bind$2;
            }
          } else {
            return _bind;
          }
        }
        default: {
          return -1;
        }
      }
    }
    default: {
      const _ReduceNoLookahead = _x_167;
      const _x$9 = _ReduceNoLookahead._0;
      const _x$10 = _ReduceNoLookahead._1;
      const _x$11 = _ReduceNoLookahead._2;
      switch (_x_168.$tag) {
        case 0: {
          return 1;
        }
        case 1: {
          return 1;
        }
        case 2: {
          return 1;
        }
        default: {
          const _ReduceNoLookahead$2 = _x_168;
          const _x$12 = _ReduceNoLookahead$2._0;
          const _x$13 = _ReduceNoLookahead$2._1;
          const _x$14 = _ReduceNoLookahead$2._2;
          const _bind$2 = $compare_int(_x$9, _x$12);
          if (_bind$2 === 0) {
            const _bind$3 = moonbitlang$core$string$$String$compare(_x$10, _x$13);
            if (_bind$3 === 0) {
              return $compare_int(_x$11, _x$14);
            } else {
              return _bind$3;
            }
          } else {
            return _bind$2;
          }
        }
      }
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$CodegenDecision$to_string(self) {
  switch (self.$tag) {
    case 0: {
      return "Accept";
    }
    case 1: {
      const _Shift = self;
      const _x = _Shift._0;
      return `Shift(yy_state_${moonbitlang$core$int$$Int$to_string(_x)})`;
    }
    case 2: {
      const _Reduce = self;
      const _x$2 = _Reduce._0;
      const _x$3 = _Reduce._1;
      const _x$4 = _Reduce._2;
      return `Reduce(${moonbitlang$core$int$$Int$to_string(_x$2)}, NT_${_x$3}, yy_action_${moonbitlang$core$int$$Int$to_string(_x$4)})`;
    }
    default: {
      const _ReduceNoLookahead = self;
      const _x$5 = _ReduceNoLookahead._0;
      const _x$6 = _ReduceNoLookahead._1;
      const _x$7 = _ReduceNoLookahead._2;
      return `ReduceNoLookahead(${moonbitlang$core$int$$Int$to_string(_x$5)}, NT_${_x$6}, yy_action_${moonbitlang$core$int$$Int$to_string(_x$7)})`;
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$esc(code) {
  return moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(moonbitlang$core$string$$String$replace_all(code, "@", "_"), "/", "_"), ".", "_"), "[", "_"), "]", "_"), "(", "_"), ")", "_"), ",", "_"), " ", "_"), "?", "_");
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$inject_derive$168$(derive_map, type_) {
  const _bind = moonbitlang$core$immut$hashmap$$T$op_get$35$(derive_map, type_);
  if (_bind === undefined) {
    return "";
  } else {
    const _Some = _bind;
    const _x = _Some;
    return ` derive(${_x})`;
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens(terminals, terminal_meta, output, no_comments, derive_map) {
  output.method_0(output.self, "pub(all) enum Token {\n");
  const _len = terminals.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const term = terminals[_i];
      const _bind = terminal_meta(term.name).data_type;
      if (_bind === undefined) {
        output.method_0(output.self, `  ${term.name}\n`);
      } else {
        const _Some = _bind;
        const _x = _Some;
        output.method_0(output.self, `  ${term.name}(${_x})\n`);
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_0(output.self, `}${moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$inject_derive$168$(derive_map, 0)}\n\npub fn Token::kind(self : Token) -> TokenKind {\n  match self {\n`);
  const _len$2 = terminals.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const term = terminals[_i];
      const _bind = terminal_meta(term.name).data_type;
      if (_bind === undefined) {
        output.method_0(output.self, `    ${term.name} => TK_${term.name}\n`);
      } else {
        output.method_0(output.self, `    ${term.name}(_) => TK_${term.name}\n`);
      }
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_0(output.self, "  }\n}\n\n");
  output.method_0(output.self, "pub(all) enum TokenKind {\n");
  const _len$3 = terminals.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$3) {
      const term = terminals[_i];
      output.method_0(output.self, `  TK_${term.name}\n`);
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_0(output.self, `}${moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$inject_derive$168$(derive_map, 1)}\n\n`);
  output.method_0(output.self, "pub impl Show for TokenKind with output(self, logger) {\n  logger.write_string(\n    match self {\n");
  const _len$4 = terminals.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$4) {
      const term = terminals[_i];
      const _bind = terminal_meta(term.name).image;
      let name;
      if (_bind === undefined) {
        name = term.name;
      } else {
        const _Some = _bind;
        const _x = _Some;
        name = _x;
      }
      output.method_0(output.self, `      TK_${term.name} => ${moonbitlang$core$string$$String$escape(name)}\n`);
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  output.method_0(output.self, "    }\n  )\n}\n\n");
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$derive_map$46$default() {
  return moonbitlang$core$immut$hashmap$$new$35$();
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$add_symbol_decision$169$(_env, symbol, decision) {
  const grammar = _env._2;
  const decision_groups = _env._1;
  const sum = _env._0;
  moonbitlang$core$sorted_map$$T$op_set$39$(decision_groups, decision, moonbitlang$core$immut$sorted_set$$T$add$33$(moonbitlang$core$option$$Option$or$34$(moonbitlang$core$sorted_map$$T$op_get$39$(decision_groups, decision), moonbitlang$core$immut$sorted_set$$new$33$()), symbol));
  switch (symbol.$tag) {
    case 0: {
      const _T = symbol;
      const _x = _T._0;
      sum.val = sum.val + _x | 0;
      return;
    }
    case 1: {
      const _NT = symbol;
      const _x$2 = _NT._0;
      sum.val = sum.val + (grammar.terminals.length + _x$2 | 0) | 0;
      return;
    }
    default: {
      sum.val = sum.val + (grammar.terminals.length + grammar.nonterminals.length | 0) | 0;
      return;
    }
  }
}
function moonbitlang$yacc$lib$codegen$gen_mbt$$codegen(grammar, automaton, meta, output, source_map_builder, grammar_filename, external_tokens, no_comments, mode, input_mode) {
  const used_runtime_funcs = moonbitlang$core$sorted_set$$new$7$();
  const _x = meta.terminal_meta;
  const _x$2 = meta.nonterminal_meta;
  const _x$3 = meta.production_meta;
  moonbitlang$core$builtin$$Logger$write_string$143$(output, meta.header);
  moonbitlang$core$builtin$$Logger$write_string$143$(output, `pub(all) typealias Position = ${meta.position_data_type}\n\n`);
  if (external_tokens) {
  } else {
    moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens(grammar.terminals, _x, { self: output, method_0: moonbitlang$core$builtin$$Logger$write_string$143$, method_1: moonbitlang$core$builtin$$Logger$write_substring$143$, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$142$, method_3: moonbitlang$core$builtin$$Logger$write_char$143$ }, no_comments, meta.derive_map);
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "pub type! ParseError {\n  UnexpectedToken(Token, (Position, Position), Array[TokenKind])\n");
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "  UnexpectedEndOfInput(Position, Array[TokenKind])\n");
  }
  const _bind = moonbitlang$core$immut$hashmap$$T$op_get$35$(meta.derive_map, 2);
  let _tmp;
  if (_bind === undefined) {
    _tmp = "";
  } else {
    const _Some = _bind;
    const _x$4 = _Some;
    _tmp = ` derive(${_x$4})`;
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, `}${_tmp}\n\n`);
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "typealias YYObj = Error\n\n");
  if (mode.$tag === 0) {
    const data_types = moonbitlang$core$sorted_set$$new$7$();
    const _arr = grammar.terminals;
    const _len = _arr.length;
    let _tmp$2 = 0;
    while (true) {
      const _i = _tmp$2;
      if (_i < _len) {
        const term = _arr[_i];
        const meta$2 = _x(term.name);
        const _bind$2 = meta$2.data_type;
        if (_bind$2 === undefined) {
        } else {
          const _Some = _bind$2;
          const _x$4 = _Some;
          moonbitlang$core$sorted_set$$T$add$7$(data_types, _x$4);
        }
        _tmp$2 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    const _arr$2 = grammar.nonterminals;
    const _len$2 = _arr$2.length;
    let _tmp$3 = 0;
    while (true) {
      const _i = _tmp$3;
      if (_i < _len$2) {
        _L: {
          const nonterm = _arr$2[_i];
          const _bind$2 = moonbitlang$core$array$$Array$iter$26$(grammar.starts);
          if (!moonbitlang$core$builtin$$Iter$contains$17$((_p) => _bind$2((_p$2) => _p(_p$2.lhs)), nonterm)) {
            const meta$2 = _x$2(nonterm.name);
            moonbitlang$core$sorted_set$$T$add$7$(data_types, meta$2.data_type);
          } else {
            break _L;
          }
          break _L;
        }
        _tmp$3 = _i + 1 | 0;
        continue;
      } else {
        break;
      }
    }
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "priv type! YYObj_Void\n\n");
    const _bind$2 = moonbitlang$core$sorted_set$$T$iter$7$(data_types);
    _bind$2((data_type) => {
      moonbitlang$core$builtin$$Logger$write_string$143$(output, `priv type! YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$esc(data_type)} ${data_type}\n\n`);
      return 1;
    });
  } else {
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "type! YYObj_Json Json\n\n");
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "typealias YYState = (YYSymbol) -> YYDecision\n\ntypealias YYAction = (Position, ArrayView[(YYObj, Position, Position)]) -> YYObj\n\npriv enum YYDecision {\n  Accept\n  Shift(YYState)\n  Reduce(Int, YYSymbol, YYAction)\n  ReduceNoLookahead(Int, YYSymbol, YYAction)\n  Error\n}\n\n");
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "priv enum YYSymbol {\n");
  const _arr = grammar.terminals;
  const _len = _arr.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len) {
      const term = _arr[_i];
      moonbitlang$core$builtin$$Logger$write_string$143$(output, `  T_${term.name}\n`);
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _arr$2 = grammar.nonterminals;
  const _len$2 = _arr$2.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$2) {
      _L: {
        const nonterm = _arr$2[_i];
        const _bind$2 = moonbitlang$core$array$$Array$iter$26$(grammar.starts);
        if (!moonbitlang$core$builtin$$Iter$contains$17$((_p) => _bind$2((_p$2) => _p(_p$2.lhs)), nonterm)) {
          moonbitlang$core$builtin$$Logger$write_string$143$(output, `  NT_${nonterm.name}\n`);
        } else {
          break _L;
        }
        break _L;
      }
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "  EOI\n}\n\n// Workaround for EOI unused warning\nfn init {\n  match EOI {\n    EOI => ()\n    _ => ()\n  }\n}\n\n");
  const _arr$3 = grammar.productions;
  const _len$3 = _arr$3.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$3) {
      _L: {
        const production = _arr$3[_i];
        if (!moonbitlang$core$array$$Array$contains$26$(grammar.starts, production)) {
          const meta$2 = _x$3(production.num);
          moonbitlang$core$builtin$$Logger$write_string$143$(output, `fn yy_action_${moonbitlang$core$int$$Int$to_string(production.num)}(_last_pos : Position, _args : ArrayView[(YYObj, Position, Position)]) -> YYObj {\n`);
          const _arr$4 = meta$2.bindings;
          const _len$4 = _arr$4.length;
          let _tmp$5 = 0;
          while (true) {
            const _i$2 = _tmp$5;
            if (_i$2 < _len$4) {
              const binding = _arr$4[_i$2];
              let index;
              _L$2: {
                _L$3: {
                  const _bind$2 = binding._0;
                  switch (_bind$2.$tag) {
                    case 0: {
                      const _Data = _bind$2;
                      const _x$4 = _Data._0;
                      const symbol = moonbitlang$core$array$$Array$op_get$45$(production.rhs, _x$4);
                      let data_type;
                      if (symbol.$tag === 0) {
                        const _T = symbol;
                        const _x$5 = _T._0;
                        data_type = moonbitlang$core$option$$Option$or$7$(_x(_x$5.name).data_type, "Unit");
                      } else {
                        const _NT = symbol;
                        const _x$5 = _NT._0;
                        data_type = _x$2(_x$5.name).data_type;
                      }
                      moonbitlang$core$builtin$$Logger$write_string$143$(output, `  guard let YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$esc(data_type)}(${binding._1}) = _args[${moonbitlang$core$int$$Int$to_string(_x$4)}].0\n`);
                      break;
                    }
                    case 1: {
                      moonbitlang$core$builtin$$Logger$write_string$143$(output, `  let ${binding._1} = _last_pos\n`);
                      break;
                    }
                    case 2: {
                      const _StartPos = _bind$2;
                      const _x$5 = _StartPos._0;
                      index = _x$5;
                      break _L$3;
                    }
                    case 3: {
                      const _EndPos = _bind$2;
                      const _x$6 = _EndPos._0;
                      index = _x$6;
                      break _L$3;
                    }
                    default: {
                      moonbitlang$core$sorted_set$$T$add$7$(used_runtime_funcs, "_get_symbol_start_pos");
                      moonbitlang$core$builtin$$Logger$write_string$143$(output, `  let ${binding._1} = _get_symbol_start_pos(_args, _last_pos)\n`);
                    }
                  }
                  break _L$2;
                }
                if (production.rhs.length === 0) {
                  moonbitlang$core$builtin$$Logger$write_string$143$(output, `  let ${binding._1} = _last_pos\n`);
                } else {
                  const _bind$2 = binding._0;
                  let field;
                  switch (_bind$2.$tag) {
                    case 2: {
                      field = 1;
                      break;
                    }
                    case 3: {
                      field = 2;
                      break;
                    }
                    default: {
                      field = $panic();
                    }
                  }
                  moonbitlang$core$builtin$$Logger$write_string$143$(output, `  let ${binding._1} = _args[${moonbitlang$core$int$$Int$to_string(index)}].${moonbitlang$core$int$$Int$to_string(field)}\n`);
                }
              }
              _tmp$5 = _i$2 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          moonbitlang$core$builtin$$Logger$write_string$143$(output, `  YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$esc(_x$2(production.lhs.name).data_type)}({(); `);
          const _arr$5 = meta$2.body;
          const _len$5 = _arr$5.length;
          let _tmp$6 = 0;
          while (true) {
            const _i$2 = _tmp$6;
            if (_i$2 < _len$5) {
              const part = _arr$5[_i$2];
              const _x$4 = part._0;
              const _x$5 = part._1;
              if (_x$5 === undefined) {
              } else {
                const _Some = _x$5;
                const _x$6 = _Some;
                const generated_utf8_pos = moonbitlang$yacc$lib$util$logger_with_cursor$$LoggerWithCursor$cursor(output);
                if (source_map_builder === undefined) {
                } else {
                  const _Some$2 = source_map_builder;
                  const _x$7 = _Some$2;
                  _x$7.method_0(_x$7.self, grammar_filename, _x$6, generated_utf8_pos, _x$4.length);
                }
              }
              moonbitlang$core$builtin$$Logger$write_string$143$(output, _x$4);
              _tmp$6 = _i$2 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          moonbitlang$core$builtin$$Logger$write_string$143$(output, "})\n");
          moonbitlang$core$builtin$$Logger$write_string$143$(output, "}\n\n");
        } else {
          break _L;
        }
        break _L;
      }
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "fn yy_input(token : Token, _start_pos : Position, _end_pos : Position) -> (YYSymbol, YYObj) {\n  match token {\n");
  const _arr$4 = grammar.terminals;
  const _len$4 = _arr$4.length;
  let _tmp$5 = 0;
  while (true) {
    const _i = _tmp$5;
    if (_i < _len$4) {
      const term = _arr$4[_i];
      const meta$2 = _x(term.name);
      if (mode.$tag === 0) {
        const _bind$2 = meta$2.data_type;
        if (_bind$2 === undefined) {
          moonbitlang$core$builtin$$Logger$write_string$143$(output, `    ${term.name} => (T_${term.name}, YYObj_Void)\n`);
        } else {
          const _Some = _bind$2;
          const _x$4 = _Some;
          moonbitlang$core$builtin$$Logger$write_string$143$(output, `    ${term.name}(data) => (T_${term.name}, YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$esc(_x$4)}(data))\n`);
        }
      } else {
        const _bind$2 = meta$2.data_type;
        const payload_code = _bind$2 === undefined ? "" : "(data)";
        const _bind$3 = meta$2.data_type;
        const data_code = _bind$3 === undefined ? "Null" : "data.to_json()";
        moonbitlang$core$builtin$$Logger$write_string$143$(output, `    ${term.name}${payload_code} => (T_${term.name}, YYObj_Json({\n      \"type\": \"TERMINAL\",\n      \"name\": \"${term.name}\",\n      \"data\": ${data_code},\n      \"start\": _start_pos.to_json(),\n      \"end\": _end_pos.to_json()\n    }))\n`);
      }
      _tmp$5 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "  }\n}\n\n");
  const _arr$5 = automaton.states;
  const _len$5 = _arr$5.length;
  let _tmp$6 = 0;
  while (true) {
    const _i = _tmp$6;
    if (_i < _len$5) {
      const state = _arr$5[_i];
      if (!no_comments) {
        const _bind$2 = moonbitlang$yacc$lib$lr1$$LR1State$iter_item_groups(state);
        _bind$2((item) => {
          moonbitlang$core$builtin$$Logger$write_string$143$(output, `// ${moonbitlang$core$builtin$$Show$to_string$145$(item)}\n`);
          return 1;
        });
      }
      moonbitlang$core$builtin$$Logger$write_string$143$(output, `fn yy_state_${moonbitlang$core$int$$Int$to_string(state.num)}(_lookahead : YYSymbol) -> YYDecision {\n`);
      const sum = { val: 0 };
      const decision_groups = moonbitlang$core$sorted_map$$new$39$();
      const _env = { _0: sum, _1: decision_groups, _2: grammar };
      const _bind$2 = moonbitlang$core$sorted_map$$T$iter2$41$(state.action);
      _bind$2((input, decision) => {
        let _tmp$7;
        if (input.$tag === 1) {
          const _Input = input;
          const _x$4 = _Input._0;
          _tmp$7 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$T(_x$4.num, _x$4.name);
        } else {
          _tmp$7 = $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$EOI;
        }
        const _tmp$8 = _tmp$7;
        let _tmp$9;
        switch (decision.$tag) {
          case 2: {
            _tmp$9 = $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Accept;
            break;
          }
          case 0: {
            const _Shift = decision;
            const _x$4 = _Shift._0;
            _tmp$9 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Shift(_x$4.num);
            break;
          }
          case 1: {
            const _Reduce = decision;
            const _x$5 = _Reduce._0;
            _tmp$9 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Reduce(_x$5.rhs.length, _x$5.lhs.name, _x$5.num);
            break;
          }
          default: {
            _tmp$9 = $panic();
          }
        }
        moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$add_symbol_decision$169$(_env, _tmp$8, _tmp$9);
        return 1;
      });
      const _bind$3 = moonbitlang$core$sorted_map$$T$iter2$40$(state.goto);
      _bind$3((symbol, state$2) => {
        if (symbol.$tag === 1) {
          const _NT = symbol;
          const _x$4 = _NT._0;
          moonbitlang$yacc$lib$codegen$gen_mbt$$codegen$46$add_symbol_decision$169$(_env, new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenSymbol$NT(_x$4.num, _x$4.name), new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$Shift(state$2.num));
        }
        return 1;
      });
      let total = 0;
      const _arr$6 = grammar.terminals;
      const _len$6 = _arr$6.length;
      let _tmp$7 = 0;
      while (true) {
        const _i$2 = _tmp$7;
        if (_i$2 < _len$6) {
          const term = _arr$6[_i$2];
          total = total + term.num | 0;
          _tmp$7 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      const _arr$7 = grammar.nonterminals;
      const _len$7 = _arr$7.length;
      let _tmp$8 = 0;
      while (true) {
        const _i$2 = _tmp$8;
        if (_i$2 < _len$7) {
          const nonterm = _arr$7[_i$2];
          total = total + (grammar.terminals.length + nonterm.num | 0) | 0;
          _tmp$8 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      total = total + (grammar.terminals.length + grammar.nonterminals.length | 0) | 0;
      let _tmp$9;
      if (moonbitlang$core$sorted_map$$T$size$39$(decision_groups) === 1) {
        const _bind$4 = moonbitlang$core$array$$Array$op_get$43$(moonbitlang$core$sorted_map$$T$keys$39$(decision_groups), 0);
        let _tmp$10;
        switch (_bind$4.$tag) {
          case 2: {
            _tmp$10 = true;
            break;
          }
          case 0: {
            _tmp$10 = true;
            break;
          }
          default: {
            _tmp$10 = false;
          }
        }
        _tmp$9 = _tmp$10;
      } else {
        _tmp$9 = false;
      }
      if (_tmp$9) {
        const decision = moonbitlang$core$array$$Array$op_get$43$(moonbitlang$core$sorted_map$$T$keys$39$(decision_groups), 0);
        let decision$2;
        if (decision.$tag === 2) {
          const _Reduce = decision;
          const _x$4 = _Reduce._0;
          const _x$5 = _Reduce._1;
          const _x$6 = _Reduce._2;
          decision$2 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$47$gen_mbt$46$CodegenDecision$ReduceNoLookahead(_x$4, _x$5, _x$6);
        } else {
          decision$2 = decision;
        }
        moonbitlang$core$builtin$$Logger$write_string$143$(output, `  ${moonbitlang$yacc$lib$codegen$gen_mbt$$CodegenDecision$to_string(decision$2)}\n`);
      } else {
        moonbitlang$core$builtin$$Logger$write_string$143$(output, "  match _lookahead {\n");
        const _bind$4 = moonbitlang$core$sorted_map$$T$iter2$39$(decision_groups);
        _bind$4((decision, symbols) => {
          const _bind$5 = moonbitlang$core$immut$sorted_set$$T$iter$33$(symbols);
          const pattern = moonbitlang$core$string$$String$concat(moonbitlang$core$builtin$$Iter$to_array$7$((_p) => _bind$5((_p$2) => _p(moonbitlang$yacc$lib$codegen$gen_mbt$$CodegenSymbol$to_string(_p$2)))), " | ");
          moonbitlang$core$builtin$$Logger$write_string$143$(output, `    ${pattern} => ${moonbitlang$yacc$lib$codegen$gen_mbt$$CodegenDecision$to_string(decision)}\n`);
          return 1;
        });
        const exhaustive = sum.val === total;
        if (!exhaustive) {
          moonbitlang$core$builtin$$Logger$write_string$143$(output, "    _ => Error\n");
        }
        moonbitlang$core$builtin$$Logger$write_string$143$(output, "  }\n");
      }
      moonbitlang$core$builtin$$Logger$write_string$143$(output, "}\n\n");
      _tmp$6 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "fn yy_parse[T](\n  tokens : Array[(Token, Position, Position)],\n  start : YYState,\n  return_ : (YYObj) -> T\n) -> T!ParseError {\n  let mut cursor = 0\n  let mut state_stack : @immut/list.T[YYState] = Cons(start, Nil)\n  let data_stack : Array[(YYObj, Position, Position)] = []\n  let mut last_pos = tokens[0].1\n  let mut state = start\n  let mut lookahead : Option[(YYSymbol, (YYObj, Position, Position), Token?)] = None\n  let mut last_shifted_state_stack = state_stack\n  while true {\n    let decision = match state(EOI) {\n      ReduceNoLookahead(_) | Accept as t => t\n      _ => {\n        match lookahead {\n          Some(la) => state(la.0)\n          None => {\n            if cursor < tokens.length() {\n              let (token, start_pos, end_pos) = tokens[cursor]\n              cursor += 1\n              let (symbol, data) = yy_input(token, start_pos, end_pos)\n              lookahead = Some((symbol, (data, start_pos, end_pos), Some(token)))\n              state(symbol)\n            } else {\n              lookahead = Some((EOI, (YYObj_Void, last_pos, last_pos), None))\n              state(EOI)\n            }\n          }\n        }\n      }\n    }\n    match decision {\n      Accept => return return_(data_stack.unsafe_pop().0)\n      Shift(next_state) => {\n        guard let Some(la) = lookahead\n        data_stack.push(la.1)\n        state_stack = Cons(next_state, state_stack)\n        last_shifted_state_stack = state_stack\n        state = next_state\n        last_pos = la.1.2\n        lookahead = None\n      }\n      Reduce(count, symbol, action)\n      | ReduceNoLookahead(count, symbol, action) => {\n        loop (count, symbol, action) {\n          _ => {\n            let args = data_stack[data_stack.length() - count:]\n            let data = action(last_pos, args)\n            let (start_pos, end_pos) = if args.length() == 0 {\n              (last_pos, last_pos)\n            } else {\n              (args[0].1, args[args.length() - 1].2)\n            }\n            for i in 0..<count {\n              ignore(data_stack.unsafe_pop())\n              state_stack = state_stack.tail()\n            }\n            state = state_stack.unsafe_head()\n            data_stack.push((data, start_pos, end_pos))\n            match state(symbol) {\n              Accept => return return_(data_stack.unsafe_pop().0)\n              Shift(next_state) => {\n                state_stack = Cons(next_state, state_stack)\n                state = next_state\n              }\n              Reduce(count, symbol, action)\n              | ReduceNoLookahead(count, symbol, action) => continue (count, symbol, action)\n              _ => panic()\n            }\n          }\n        }\n      }\n      Error => {\n        let (_, (_, start_pos, end_pos), token) = lookahead.unwrap()\n        error!(last_shifted_state_stack, token, (start_pos, end_pos))\n      }\n    }\n  }\n  panic()\n}\n\n");
  } else {
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "fn yy_parse[T](\n  read_token : () -> (Token, Position, Position),\n  start_pos : Position,\n  start : YYState,\n  return_ : (YYObj) -> T\n) -> T!ParseError {\n  let mut state_stack : @immut/list.T[YYState] = Cons(start, Nil)\n  let data_stack : Array[(YYObj, Position, Position)] = []\n  let mut last_pos = start_pos\n  let mut state = start\n  let mut lookahead : Option[(YYSymbol, (YYObj, Position, Position), Token)] = None\n  let mut last_shifted_state_stack = state_stack\n  while true {\n    let decision = match state(EOI) {\n      ReduceNoLookahead(_) | Accept as t => t\n      _ => {\n        match lookahead {\n          Some(la) => state(la.0)\n          None => {\n            let (token, start_pos, end_pos) = read_token()\n            let (symbol, data) = yy_input(token, start_pos, end_pos)\n            lookahead = Some((symbol, (data, start_pos, end_pos), token))\n            state(symbol)\n          }\n        }\n      }\n    }\n    match decision {\n      Accept => return return_(data_stack.unsafe_pop().0)\n      Shift(next_state) => {\n        guard let Some(la) = lookahead\n        data_stack.push(la.1)\n        state_stack = Cons(next_state, state_stack)\n        last_shifted_state_stack = state_stack\n        state = next_state\n        last_pos = la.1.2\n        lookahead = None\n      }\n      Reduce(count, symbol, action)\n      | ReduceNoLookahead(count, symbol, action) => {\n        loop (count, symbol, action) {\n          _ => {\n            let args = data_stack[data_stack.length() - count:]\n            let data = action(last_pos, args)\n            let (start_pos, end_pos) = if args.length() == 0 {\n              (last_pos, last_pos)\n            } else {\n              (args[0].1, args[args.length() - 1].2)\n            }\n            for i in 0..<count {\n              ignore(data_stack.unsafe_pop())\n              state_stack = state_stack.tail()\n            }\n            state = state_stack.unsafe_head()\n            data_stack.push((data, start_pos, end_pos))\n            match state(symbol) {\n              Accept => return return_(data_stack.unsafe_pop().0)\n              Shift(next_state) => {\n                state_stack = Cons(next_state, state_stack)\n                state = next_state\n              }\n              Reduce(count, symbol, action)\n              | ReduceNoLookahead(count, symbol, action) => continue (count, symbol, action)\n              _ => panic()\n            }\n          }\n        }\n      }\n      Error => {\n        let (_, (_, start_pos, end_pos), token) = lookahead.unwrap()\n        error!(last_shifted_state_stack, token, (start_pos, end_pos))\n      }\n    }\n  }\n  panic()\n}\n\n");
  }
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "fn error(stack : @immut/list.T[YYState], token : Token?, loc : (Position, Position)) -> Unit!ParseError {\n");
  } else {
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "fn error(stack : @immut/list.T[YYState], token : Token, loc : (Position, Position)) -> Unit!ParseError {\n");
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "  let expected = []\n  fn try_add(symbol : YYSymbol, kind : TokenKind) {\n    fn go(stack : @immut/list.T[YYState]) {\n      match stack {\n        Nil => ()\n        Cons(state, _) => {\n          match state(symbol) {\n            Accept | Shift(_) => expected.push(kind)\n            Reduce(count, symbol, _) | ReduceNoLookahead(count, symbol, _) => {\n              fn inner_go(stack : @immut/list.T[YYState], count, symbol) {\n                let stack = stack.drop(count)\n                guard let Cons(state, _) = stack\n                match state(symbol) {\n                  Shift(state) => go(Cons(state, stack))\n                  Reduce(count, symbol, _) | ReduceNoLookahead(count, symbol, _) => inner_go(stack, count, symbol)\n                  _ => panic()\n                }\n              }\n              inner_go(stack, count, symbol)\n            }\n            Error => ()\n          }\n        }\n      }\n    }\n    go(stack)\n  }\n");
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "  for term in [");
  const _arr$6 = grammar.terminals;
  const _len$6 = _arr$6.length;
  let _tmp$7 = 0;
  while (true) {
    const _i = _tmp$7;
    if (_i < _len$6) {
      const term = _arr$6[_i];
      if (_i > 0) {
        moonbitlang$core$builtin$$Logger$write_string$143$(output, ", ");
      }
      moonbitlang$core$builtin$$Logger$write_string$143$(output, `(T_${term.name}, TK_${term.name})`);
      _tmp$7 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "] {\n");
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "    try_add(term.0, term.1)\n  }\n");
  if (input_mode === 0) {
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "  match token {\n    None => raise UnexpectedEndOfInput(loc.1, expected)\n    Some(token) => raise UnexpectedToken(token, loc, expected)\n  }\n");
  } else {
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "  raise UnexpectedToken(token, loc, expected)\n");
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, "}\n\n");
  const _arr$7 = automaton.starts;
  const _len$7 = _arr$7.length;
  let _tmp$8 = 0;
  while (true) {
    const _i = _tmp$8;
    if (_i < _len$7) {
      const start = _arr$7[_i];
      const _x$4 = start._0;
      const _x$5 = start._1;
      const name = _x$4.lhs.name;
      const original_name = moonbitlang$core$string$$String$substring(name, 0, name.length - "_prime".length | 0);
      if (input_mode === 0) {
        moonbitlang$core$builtin$$Logger$write_string$143$(output, `pub fn ${original_name}(tokens: Array[(Token, Position, Position)]) -> ${_x$2(name).data_type}!ParseError {\n  yy_parse!(\n    tokens,\n    yy_state_${moonbitlang$core$int$$Int$to_string(_x$5.num)},\n    fn {\n      YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$esc(_x$2(name).data_type)}(result) => result\n      _ => panic()\n    },\n  )\n}\n`);
      } else {
        moonbitlang$core$builtin$$Logger$write_string$143$(output, `pub fn ${original_name}(read_token : () -> (Token, Position, Position), start_pos : Position) -> ${_x$2(name).data_type}!ParseError {\n  yy_parse!(\n    read_token,\n    start_pos,\n    yy_state_${moonbitlang$core$int$$Int$to_string(_x$5.num)},\n    fn {\n      YYObj_${moonbitlang$yacc$lib$codegen$gen_mbt$$esc(_x$2(name).data_type)}(result) => result\n      _ => panic()\n    },\n  )\n}\n`);
      }
      _tmp$8 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _bind$2 = moonbitlang$core$sorted_set$$T$iter$7$(used_runtime_funcs);
  _bind$2((func) => {
    if (func === "_get_symbol_start_pos") {
      moonbitlang$core$builtin$$Logger$write_string$143$(output, "\nfn _get_symbol_start_pos(args : ArrayView[(YYObj, Position, Position)], last_pos : Position) -> Position {\n  if args.length() == 0 {\n    last_pos\n  } else {\n    for i = 0; i < args.length(); i = i + 1 {\n      let (_, start_pos, end_pos) = args[i]\n      if start_pos == end_pos {\n        continue\n      }\n      return start_pos\n    }\n    args[args.length() - 1].2\n  }\n}\n");
    } else {
      $panic();
    }
    return 1;
  });
  if (mode.$tag === 0) {
  } else {
    moonbitlang$core$builtin$$Logger$write_string$143$(output, "\nfn args_to_json(args : ArrayView[(YYObj, Position, Position)]) -> Json {\n  Array(args.iter().map(fn {\n    (YYObj_Json(json), _, _) => json\n    _ => panic()\n  }).to_array())\n}\n");
  }
  moonbitlang$core$builtin$$Logger$write_string$143$(output, meta.footer);
}
function moonbitlang$yacc$lib$driver$$offset_to_line_column(content, offset) {
  let line = 1;
  let column = 1;
  let _tmp = 0;
  while (true) {
    const i = _tmp;
    if (i < offset) {
      if (content.charCodeAt(i) === 10) {
        line = line + 1 | 0;
        column = 1;
      } else {
        column = column + 1 | 0;
      }
      _tmp = i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  return { _0: line, _1: column };
}
function moonbitlang$yacc$lib$driver$$array_to_or_list(arr) {
  if (arr.len === 0) {
    return $panic();
  } else {
    if (arr.len === 1) {
      const _x = arr.buf[arr.start + 0 | 0];
      return _x;
    } else {
      const _x = arr.buf[arr.start + ((arr.len - 1 | 0) - 0 | 0) | 0];
      const _tmp = arr.buf;
      const _tmp$2 = 0 + arr.start | 0;
      const _some = arr.len - 1 | 0;
      const _x$2 = { buf: _tmp, start: _tmp$2, len: _some - 0 | 0 };
      const self = [];
      moonbitlang$core$array$$Array$push_iter$7$(self, moonbitlang$core$array$$ArrayView$iter$7$(_x$2));
      const left = moonbitlang$core$string$$String$concat(self, ", ");
      return `${left} or ${_x}`;
    }
  }
}
function moonbitlang$yacc$lib$driver$$loc_to_string(filename, content, loc) {
  const _bind = moonbitlang$yacc$lib$driver$$offset_to_line_column(content, loc._0);
  const _x = _bind._0;
  const _x$2 = _bind._1;
  const _bind$2 = moonbitlang$yacc$lib$driver$$offset_to_line_column(content, loc._1);
  const _x$3 = _bind$2._0;
  const _x$4 = _bind$2._1;
  return _x === _x$3 ? `${filename}:${moonbitlang$core$int$$Int$to_string(_x)}:${moonbitlang$core$int$$Int$to_string(_x$2)}-${moonbitlang$core$int$$Int$to_string(_x$4)}` : `${filename}:${moonbitlang$core$int$$Int$to_string(_x)}:${moonbitlang$core$int$$Int$to_string(_x$2)}-${moonbitlang$core$int$$Int$to_string(_x$3)}:${moonbitlang$core$int$$Int$to_string(_x$4)}`;
}
function moonbitlang$yacc$lib$driver$$compile$46$get_terminal_by_name$170$(_env, name) {
  const terminals = _env._1;
  const terminal_by_name = _env._0;
  const _bind = moonbitlang$core$builtin$$Map$get$92$(terminal_by_name, name);
  if (_bind === undefined) {
    const num = terminals.length;
    const term = { num: num, name: name, references: [], prec: undefined };
    moonbitlang$core$array$$Array$push$84$(terminals, term);
    moonbitlang$core$builtin$$Map$op_set$92$(terminal_by_name, name, term);
    return term;
  } else {
    const _Some = _bind;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$yacc$lib$driver$$compile$46$get_nonterminal_by_name$171$(_env, name) {
  const nonterminals = _env._1;
  const nonterminal_by_name = _env._0;
  const _bind = moonbitlang$core$builtin$$Map$get$93$(nonterminal_by_name, name);
  if (_bind === undefined) {
    const num = nonterminals.length;
    const nonterm = { num: num, name: name, productions: [], references: [], nullability: 2 };
    moonbitlang$core$array$$Array$push$17$(nonterminals, nonterm);
    moonbitlang$core$builtin$$Map$op_set$93$(nonterminal_by_name, name, nonterm);
    return nonterm;
  } else {
    const _Some = _bind;
    const _x = _Some;
    return _x;
  }
}
function moonbitlang$yacc$lib$driver$$compile$46$get_symbol_by_name$172$(_env, name) {
  const terminal_by_name = _env._1;
  const nonterminal_by_name = _env._0;
  const _bind = moonbitlang$core$builtin$$Map$get$92$(terminal_by_name, name);
  if (_bind === undefined) {
    return new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$NT(moonbitlang$core$option$$Option$unwrap$17$(moonbitlang$core$builtin$$Map$op_get$93$(nonterminal_by_name, name)));
  } else {
    const _Some = _bind;
    const _x = _Some;
    return new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$T(_x);
  }
}
function moonbitlang$yacc$lib$driver$$compile$46$item_ident_to_index$173$(ident) {
  if (ident.$tag === 0) {
    const _Dollar = ident;
    const _x = _Dollar._0;
    return _x;
  } else {
    return $panic();
  }
}
function moonbitlang$yacc$lib$driver$$compile$46$add_binding$174$(_env, desc) {
  const bindings = _env._2;
  const visited = _env._1;
  const production = _env._0;
  let _tmp = desc;
  _L: while (true) {
    const desc$2 = _tmp;
    if (!moonbitlang$core$sorted_set$$T$contains$18$(visited, desc$2)) {
      moonbitlang$core$sorted_set$$T$add$18$(visited, desc$2);
      switch (desc$2.$tag) {
        case 0: {
          const _Dollar = desc$2;
          const _x = _Dollar._0;
          const name = `_dollar${moonbitlang$core$int$$Int$to_string(_x)}`;
          moonbitlang$core$array$$Array$push$124$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$Data(_x - 1 | 0), _1: name });
          return;
        }
        case 1: {
          if (production.rhs.length === 0) {
            moonbitlang$core$array$$Array$push$124$(bindings, { _0: $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$LastPos, _1: "_start_pos" });
            return;
          } else {
            moonbitlang$core$array$$Array$push$124$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$StartPos(0), _1: "_start_pos" });
            return;
          }
        }
        case 3: {
          moonbitlang$yacc$lib$driver$$compile$46$add_binding$174$(_env, $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$StartPos);
          _tmp = $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$EndPos;
          continue _L;
        }
        case 2: {
          if (production.rhs.length === 0) {
            moonbitlang$core$array$$Array$push$124$(bindings, { _0: $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$LastPos, _1: "_end_pos" });
            return;
          } else {
            moonbitlang$core$array$$Array$push$124$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$EndPos(production.rhs.length - 1 | 0), _1: "_end_pos" });
            return;
          }
        }
        case 4: {
          const _StartPosOf = desc$2;
          const _x$2 = _StartPosOf._0;
          const index = moonbitlang$yacc$lib$driver$$compile$46$item_ident_to_index$173$(_x$2);
          moonbitlang$core$array$$Array$push$124$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$StartPos(index), _1: `_start_pos_of_item${moonbitlang$core$int$$Int$to_string(index)}` });
          return;
        }
        case 5: {
          const _EndPosOf = desc$2;
          const _x$3 = _EndPosOf._0;
          const index$2 = moonbitlang$yacc$lib$driver$$compile$46$item_ident_to_index$173$(_x$3);
          moonbitlang$core$array$$Array$push$124$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$EndPos(index$2), _1: `_end_pos_of_item${moonbitlang$core$int$$Int$to_string(index$2)}` });
          return;
        }
        case 6: {
          const _LocOf = desc$2;
          const _x$4 = _LocOf._0;
          moonbitlang$yacc$lib$driver$$compile$46$add_binding$174$(_env, new $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$StartPosOf(_x$4));
          _tmp = new $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$EndPosOf(_x$4);
          continue _L;
        }
        case 7: {
          moonbitlang$core$array$$Array$push$124$(bindings, { _0: $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$SymbolStartPos, _1: "_symbol_start_pos" });
          return;
        }
        default: {
          moonbitlang$yacc$lib$driver$$compile$46$add_binding$174$(_env, $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$SymbolStartPos);
          _tmp = $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$EndPos;
          continue _L;
        }
      }
    } else {
      return;
    }
  }
}
function moonbitlang$yacc$lib$driver$$compile$46$is_nullable$175$(symbol) {
  if (symbol.$tag === 0) {
    return false;
  } else {
    const _NT = symbol;
    const _x = _NT._0;
    const _x$2 = _x.nullability;
    switch (_x$2) {
      case 0: {
        return true;
      }
      case 1: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
}
function moonbitlang$yacc$lib$driver$$compile(parser_spec_str, mode, input_mode, filename, external_tokens, no_comments, source_map_builder) {
  const lexer = moonbitlang$yacc$lib$parser$$new_lexer(parser_spec_str);
  const token = () => moonbitlang$core$result$$Result$unwrap$10$(moonbitlang$yacc$lib$parser$$Lexer$next_token(lexer));
  let spec;
  let _try_err;
  _L: {
    _L$2: {
      const _bind = moonbitlang$yacc$lib$parser$$spec(token, 0);
      if (_bind.$tag === 1) {
        const _ok = _bind;
        spec = _ok._0;
      } else {
        const _err = _bind;
        const _tmp = _err._0;
        _try_err = _tmp;
        break _L$2;
      }
      break _L;
    }
    const _UnexpectedToken = _try_err;
    const _x = _UnexpectedToken._0;
    const _x$2 = _UnexpectedToken._1;
    const _x$3 = _UnexpectedToken._2;
    const loc_str = moonbitlang$yacc$lib$driver$$loc_to_string(filename, parser_spec_str, _x$2);
    const _bind = moonbitlang$core$array$$Array$map$136$(_x$3, moonbitlang$core$builtin$$Show$to_string$146$);
    const expected_str = moonbitlang$yacc$lib$driver$$array_to_or_list({ buf: _bind, start: 0, len: _bind.length });
    moonbitlang$yacc$lib$driver$util$$println_to_stderr(`SyntaxError: Unexpected token ${moonbitlang$core$builtin$$Show$to_string$146$(moonbitlang$yacc$lib$parser$$Token$kind(_x))}, expected ${expected_str}.\n  at ${loc_str}`);
    spec = moonbitlang$yacc$lib$driver$util$$exit$157$(1);
  }
  const terminals = [];
  const nonterminals = [];
  const terminal_by_name = moonbitlang$core$builtin$$Map$from_array$92$([]);
  const terminal_by_image = moonbitlang$core$builtin$$Map$from_array$92$([]);
  const nonterminal_by_name = moonbitlang$core$builtin$$Map$from_array$93$([]);
  const production_meta_map = moonbitlang$core$builtin$$Map$from_array$94$([]);
  const terminal_meta_map = moonbitlang$core$builtin$$Map$from_array$95$([]);
  const nonterminal_meta_map = moonbitlang$core$builtin$$Map$from_array$96$([]);
  const _env = { _0: terminal_by_name, _1: terminals };
  const _env$2 = { _0: nonterminal_by_name, _1: nonterminals };
  const _arr = spec.commands;
  const _len = _arr.length;
  let _tmp = 0;
  while (true) {
    const _i = _tmp;
    if (_i < _len) {
      const cmd = _arr[_i];
      switch (cmd.$tag) {
        case 1: {
          const _Token = cmd;
          const _x = _Token._0;
          const _x$2 = _Token._1;
          const _len$2 = _x.length;
          let _tmp$2 = 0;
          while (true) {
            const _i$2 = _tmp$2;
            if (_i$2 < _len$2) {
              const name = _x[_i$2];
              const t = moonbitlang$yacc$lib$driver$$compile$46$get_terminal_by_name$170$(_env, name);
              moonbitlang$core$builtin$$Map$op_set$95$(terminal_meta_map, t.num, { data_type: _x$2, image: undefined });
              _tmp$2 = _i$2 + 1 | 0;
              continue;
            } else {
              break;
            }
          }
          break;
        }
        case 2: {
          const _Token1 = cmd;
          const _x$3 = _Token1._0;
          const _x$4 = _Token1._1;
          const _x$5 = _Token1._2;
          const t = moonbitlang$yacc$lib$driver$$compile$46$get_terminal_by_name$170$(_env, _x$3);
          moonbitlang$core$builtin$$Map$op_set$95$(terminal_meta_map, t.num, { data_type: _x$4, image: _x$5 });
          moonbitlang$core$builtin$$Map$op_set$92$(terminal_by_image, _x$5, t);
          break;
        }
      }
      _tmp = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  if (mode.$tag === 2) {
    const output = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
    moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens(terminals, (name) => moonbitlang$core$builtin$$Map$get_or_init$95$(terminal_meta_map, moonbitlang$yacc$lib$driver$$compile$46$get_terminal_by_name$170$(_env, name).num, () => ({ data_type: undefined, image: undefined })), { self: output, method_0: moonbitlang$core$builtin$$StringBuilder$write_string, method_1: moonbitlang$core$builtin$$StringBuilder$write_substring, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$79$, method_3: moonbitlang$core$builtin$$StringBuilder$write_char }, no_comments, moonbitlang$yacc$lib$codegen$gen_mbt$$codegen_tokens$46$derive_map$46$default());
    return moonbitlang$core$builtin$$StringBuilder$to_string(output);
  }
  const _arr$2 = spec.rules;
  const _len$2 = _arr$2.length;
  let _tmp$2 = 0;
  while (true) {
    const _i = _tmp$2;
    if (_i < _len$2) {
      const rule = _arr$2[_i];
      moonbitlang$yacc$lib$driver$$compile$46$get_nonterminal_by_name$171$(_env$2, rule.nonterminal);
      _tmp$2 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const _env$3 = { _0: nonterminal_by_name, _1: terminal_by_name };
  const productions = [];
  const starts = [];
  const curr_prec = { val: 0 };
  let position_data_type = "Unit";
  let derive_map = moonbitlang$core$immut$hashmap$$new$35$();
  const prec_map = moonbitlang$core$sorted_map$$new$42$();
  const _arr$3 = spec.commands;
  const _len$3 = _arr$3.length;
  let _tmp$3 = 0;
  while (true) {
    const _i = _tmp$3;
    if (_i < _len$3) {
      const cmd = _arr$3[_i];
      let names;
      _L$2: {
        _L$3: {
          switch (cmd.$tag) {
            case 1: {
              break;
            }
            case 2: {
              break;
            }
            case 0: {
              const _Start = cmd;
              const _x = _Start._0;
              moonbitlang$core$array$$Array$push_iter$7$(starts, moonbitlang$core$array$$Array$iter$7$(_x));
              break;
            }
            case 3: {
              const _Type = cmd;
              const _x$2 = _Type._0;
              const _x$3 = _Type._1;
              const _len$4 = _x$2.length;
              let _tmp$4 = 0;
              while (true) {
                const _i$2 = _tmp$4;
                if (_i$2 < _len$4) {
                  const name = _x$2[_i$2];
                  const symbol = moonbitlang$yacc$lib$driver$$compile$46$get_symbol_by_name$172$(_env$3, name);
                  if (symbol.$tag === 0) {
                    $panic();
                  } else {
                    const _NT = symbol;
                    const _x$4 = _NT._0;
                    moonbitlang$core$builtin$$Map$op_set$96$(nonterminal_meta_map, _x$4.num, { data_type: _x$3 });
                  }
                  _tmp$4 = _i$2 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
              break;
            }
            case 5: {
              const _Position = cmd;
              const _x$4 = _Position._0;
              position_data_type = _x$4;
              break;
            }
            case 6: {
              const _Left = cmd;
              const _x$5 = _Left._0;
              names = _x$5;
              break _L$3;
            }
            case 7: {
              const _Right = cmd;
              const _x$6 = _Right._0;
              names = _x$6;
              break _L$3;
            }
            case 8: {
              const _Nonassoc = cmd;
              const _x$7 = _Nonassoc._0;
              names = _x$7;
              break _L$3;
            }
            default: {
              const _Derive = cmd;
              const _x$8 = _Derive._0;
              const _x$9 = _Derive._1;
              let type_;
              switch (_x$9) {
                case "Token": {
                  type_ = 0;
                  break;
                }
                case "TokenKind": {
                  type_ = 1;
                  break;
                }
                case "ParseError": {
                  type_ = 2;
                  break;
                }
                default: {
                  type_ = $panic();
                }
              }
              derive_map = moonbitlang$core$immut$hashmap$$T$add$35$(derive_map, type_, _x$8);
            }
          }
          break _L$2;
        }
        let assoc;
        switch (cmd.$tag) {
          case 6: {
            assoc = 0;
            break;
          }
          case 7: {
            assoc = 1;
            break;
          }
          case 8: {
            assoc = 2;
            break;
          }
          default: {
            assoc = $panic();
          }
        }
        const prec = curr_prec.val;
        curr_prec.val = curr_prec.val + 1 | 0;
        const _len$4 = names.length;
        let _tmp$4 = 0;
        while (true) {
          const _i$2 = _tmp$4;
          if (_i$2 < _len$4) {
            const name = names[_i$2];
            moonbitlang$core$sorted_map$$T$op_set$42$(prec_map, name, { _0: prec, _1: assoc });
            _tmp$4 = _i$2 + 1 | 0;
            continue;
          } else {
            break;
          }
        }
      }
      _tmp$3 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  switch (mode.$tag) {
    case 2: {
      $panic();
      break;
    }
    case 0: {
      break;
    }
    default: {
      const _JsonCst = mode;
      const _x = _JsonCst._0;
      position_data_type = "Int";
      if (_x === undefined) {
      } else {
        const x = moonbitlang$core$option$$Option$or$7$(moonbitlang$core$immut$hashmap$$T$op_get$35$(derive_map, 0), "");
        const _bind = moonbitlang$core$string$$String$split(x, ",");
        if (!moonbitlang$core$builtin$$Iter$contains$7$((_p) => _bind((_p$2) => _p(moonbitlang$core$string$$String$trim(_p$2, " "))), moonbitlang$yacc$lib$driver$$compile$46$y$2$)) {
          const z = x === "" ? moonbitlang$yacc$lib$driver$$compile$46$y$2$ : `${x}, ${moonbitlang$yacc$lib$driver$$compile$46$y$2$}`;
          derive_map = moonbitlang$core$immut$hashmap$$T$add$35$(derive_map, 0, z);
        }
      }
    }
  }
  const _bind = moonbitlang$core$sorted_map$$T$iter2$42$(prec_map);
  _bind((name, prec) => {
    const _bind$2 = moonbitlang$core$builtin$$Map$get$92$(terminal_by_name, name);
    if (_bind$2 === undefined) {
    } else {
      const _Some = _bind$2;
      const _x$2 = _Some;
      _x$2.prec = prec;
    }
    return 1;
  });
  const _arr$4 = spec.rules;
  const _len$4 = _arr$4.length;
  let _tmp$4 = 0;
  while (true) {
    const _i = _tmp$4;
    if (_i < _len$4) {
      const rule = _arr$4[_i];
      const lhs = moonbitlang$yacc$lib$driver$$compile$46$get_nonterminal_by_name$171$(_env$2, rule.nonterminal);
      const _bind$2 = rule.type_;
      if (_bind$2 === undefined) {
        const _bind$3 = moonbitlang$core$builtin$$Map$op_get$96$(nonterminal_meta_map, lhs.num);
        if (_bind$3 === undefined) {
          moonbitlang$core$builtin$$Map$op_set$96$(nonterminal_meta_map, lhs.num, { data_type: "Unit" });
        }
      } else {
        const _Some = _bind$2;
        const _x$2 = _Some;
        moonbitlang$core$builtin$$Map$op_set$96$(nonterminal_meta_map, lhs.num, { data_type: _x$2 });
      }
      const _arr$5 = rule.clauses;
      const _len$5 = _arr$5.length;
      let _tmp$5 = 0;
      while (true) {
        const _i$2 = _tmp$5;
        if (_i$2 < _len$5) {
          const clause = _arr$5[_i$2];
          const rhs = moonbitlang$core$array$$Array$map$135$(clause.items, (item) => {
            const _bind$3 = item.symbol;
            if (_bind$3.$tag === 0) {
              const _Symbol = _bind$3;
              const _x$2 = _Symbol._0;
              return moonbitlang$yacc$lib$driver$$compile$46$get_symbol_by_name$172$(_env$3, _x$2);
            } else {
              const _Image = _bind$3;
              const _x$2 = _Image._0;
              return new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$T(moonbitlang$core$option$$Option$unwrap$84$(moonbitlang$core$builtin$$Map$op_get$92$(terminal_by_image, _x$2)));
            }
          });
          const num = productions.length;
          const production = { num: num, lhs: lhs, rhs: rhs, prec: undefined };
          const _bind$3 = clause.prec;
          let _tmp$6;
          if (_bind$3 === undefined) {
            let last_prec = undefined;
            const _arr$6 = production.rhs;
            const _len$6 = _arr$6.length;
            let _tmp$7 = 0;
            while (true) {
              const _i$3 = _tmp$7;
              if (_i$3 < _len$6) {
                const symbol = _arr$6[_i$3];
                if (symbol.$tag === 0) {
                  const _T = symbol;
                  const _x$2 = _T._0;
                  moonbitlang$core$array$$Array$push$126$(_x$2.references, { _0: production, _1: _i$3 });
                  last_prec = moonbitlang$core$option$$Option$map$62$(_x$2.prec, (_param1) => {
                    const _x$3 = _param1._0;
                    return _x$3;
                  });
                } else {
                  const _NT = symbol;
                  const _x$2 = _NT._0;
                  moonbitlang$core$array$$Array$push$126$(_x$2.references, { _0: production, _1: _i$3 });
                }
                _tmp$7 = _i$3 + 1 | 0;
                continue;
              } else {
                break;
              }
            }
            _tmp$6 = last_prec;
          } else {
            const _Some = _bind$3;
            const _x$2 = _Some;
            const _bind$4 = moonbitlang$core$option$$Option$unwrap$109$(moonbitlang$core$sorted_map$$T$op_get$42$(prec_map, _x$2));
            const _x$3 = _bind$4._0;
            _tmp$6 = _x$3;
          }
          production.prec = _tmp$6;
          moonbitlang$core$array$$Array$push$26$(productions, production);
          moonbitlang$core$array$$Array$push$26$(lhs.productions, production);
          const bindings = [];
          const visited = moonbitlang$core$sorted_set$$new$18$();
          const _env$4 = { _0: production, _1: visited, _2: bindings };
          const body = [];
          switch (mode.$tag) {
            case 2: {
              $panic();
              break;
            }
            case 0: {
              const _bind$4 = clause.action.code;
              if (_bind$4 === undefined) {
                moonbitlang$core$array$$Array$push$125$(body, { _0: "()", _1: undefined });
              } else {
                const _Some = _bind$4;
                const _x$2 = _Some;
                const _x$3 = _x$2.code;
                const _x$4 = _x$2.subst;
                const _x$5 = _x$2.utf8_pos;
                let last_index = 0;
                const _len$6 = _x$4.length;
                let _tmp$7 = 0;
                while (true) {
                  const _i$3 = _tmp$7;
                  if (_i$3 < _len$6) {
                    const item = _x$4[_i$3];
                    if (item.start > last_index) {
                      moonbitlang$core$array$$Array$push$125$(body, { _0: moonbitlang$core$string$$String$substring(_x$3, last_index, item.start), _1: _x$5 + last_index | 0 });
                    }
                    moonbitlang$yacc$lib$driver$$compile$46$add_binding$174$(_env$4, item.desc);
                    const _bind$5 = item.desc;
                    let _tmp$8;
                    switch (_bind$5.$tag) {
                      case 0: {
                        const _Dollar = _bind$5;
                        const _x$6 = _Dollar._0;
                        _tmp$8 = `_dollar${moonbitlang$core$int$$Int$to_string(_x$6)}`;
                        break;
                      }
                      case 1: {
                        _tmp$8 = "_start_pos";
                        break;
                      }
                      case 2: {
                        _tmp$8 = "_end_pos";
                        break;
                      }
                      case 3: {
                        _tmp$8 = "(_start_pos, _end_pos)";
                        break;
                      }
                      case 4: {
                        const _StartPosOf = _bind$5;
                        const _x$7 = _StartPosOf._0;
                        _tmp$8 = `_start_pos_of_item${moonbitlang$core$int$$Int$to_string(moonbitlang$yacc$lib$driver$$compile$46$item_ident_to_index$173$(_x$7))}`;
                        break;
                      }
                      case 5: {
                        const _EndPosOf = _bind$5;
                        const _x$8 = _EndPosOf._0;
                        _tmp$8 = `_end_pos_of_item${moonbitlang$core$int$$Int$to_string(moonbitlang$yacc$lib$driver$$compile$46$item_ident_to_index$173$(_x$8))}`;
                        break;
                      }
                      case 6: {
                        const _LocOf = _bind$5;
                        const _x$9 = _LocOf._0;
                        const index = moonbitlang$yacc$lib$driver$$compile$46$item_ident_to_index$173$(_x$9);
                        _tmp$8 = `(_start_pos_of_item${moonbitlang$core$int$$Int$to_string(index)}, _end_pos_of_item${moonbitlang$core$int$$Int$to_string(index)})`;
                        break;
                      }
                      case 7: {
                        _tmp$8 = "_symbol_start_pos";
                        break;
                      }
                      default: {
                        _tmp$8 = "(_symbol_start_pos, _end_pos)";
                      }
                    }
                    moonbitlang$core$array$$Array$push$125$(body, { _0: _tmp$8, _1: undefined });
                    last_index = item.end;
                    _tmp$7 = _i$3 + 1 | 0;
                    continue;
                  } else {
                    break;
                  }
                }
                if (last_index < _x$3.length) {
                  moonbitlang$core$array$$Array$push$125$(body, { _0: moonbitlang$core$string$$String$substring(_x$3, last_index, _x$3.length), _1: _x$5 + last_index | 0 });
                }
              }
              break;
            }
            default: {
              moonbitlang$yacc$lib$driver$$compile$46$add_binding$174$(_env$4, $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$StartPos);
              moonbitlang$yacc$lib$driver$$compile$46$add_binding$174$(_env$4, $64$moonbitlang$47$yacc$47$lib$47$parser$46$SubstItemDesc$EndPos);
              moonbitlang$core$array$$Array$push$125$(body, { _0: `{\n  \"type\": \"NONTERMINAL\",\n  \"name\": \"${lhs.name}\",\n  \"prod_num\": ${moonbitlang$core$int$$Int$to_string(production.num)},\n  \"children\": args_to_json(_args),\n  \"start\": _start_pos.to_json(),\n  \"end\": _end_pos.to_json(),\n}`, _1: undefined });
            }
          }
          switch (mode.$tag) {
            case 2: {
              $panic();
              break;
            }
            case 1: {
              break;
            }
            default: {
              const _arr$6 = clause.items;
              const _len$6 = _arr$6.length;
              let _tmp$7 = 0;
              while (true) {
                const _i$3 = _tmp$7;
                if (_i$3 < _len$6) {
                  const item = _arr$6[_i$3];
                  const _x$2 = item.binder;
                  if (_x$2 === undefined) {
                  } else {
                    const _Some = _x$2;
                    const _x$3 = _Some;
                    moonbitlang$core$array$$Array$push$124$(bindings, { _0: new $64$moonbitlang$47$yacc$47$lib$47$codegen$46$BindingSubject$Data(_i$3), _1: _x$3 });
                  }
                  _tmp$7 = _i$3 + 1 | 0;
                  continue;
                } else {
                  break;
                }
              }
            }
          }
          moonbitlang$core$builtin$$Map$op_set$94$(production_meta_map, num, { bindings: bindings, body: body });
          _tmp$5 = _i$2 + 1 | 0;
          continue;
        } else {
          break;
        }
      }
      _tmp$4 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  const transient_non_nullables = moonbitlang$core$sorted_set$$from_iter$17$(moonbitlang$core$array$$Array$iter$17$(nonterminals));
  const _len$5 = nonterminals.length;
  let _tmp$5 = 0;
  while (true) {
    const _i = _tmp$5;
    if (_i < _len$5) {
      const nt = nonterminals[_i];
      if (moonbitlang$core$builtin$$Iter$all$26$(moonbitlang$core$array$$Array$iter$26$(nt.productions), (p) => moonbitlang$core$array$$Array$is_empty$45$(p.rhs))) {
        nt.nullability = 0;
        moonbitlang$core$sorted_set$$T$remove$17$(transient_non_nullables, nt);
      }
      _tmp$5 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  while (true) {
    const changed = { val: false };
    const _bind$2 = moonbitlang$core$sorted_set$$T$iter$17$(transient_non_nullables);
    _bind$2((nt) => {
      if (moonbitlang$core$builtin$$Iter$any$26$(moonbitlang$core$array$$Array$iter$26$(nt.productions), (p) => moonbitlang$core$builtin$$Iter$all$45$(moonbitlang$core$array$$Array$iter$45$(p.rhs), moonbitlang$yacc$lib$driver$$compile$46$is_nullable$175$))) {
        nt.nullability = 1;
        moonbitlang$core$sorted_set$$T$remove$17$(transient_non_nullables, nt);
        changed.val = true;
      }
      return 1;
    });
    if (!changed.val) {
      break;
    }
    continue;
  }
  const starts$2 = moonbitlang$core$array$$Array$map$134$(starts, (name) => {
    const start_nt = moonbitlang$yacc$lib$driver$$compile$46$get_nonterminal_by_name$171$(_env$2, name);
    const augmented_start_nt = moonbitlang$yacc$lib$driver$$compile$46$get_nonterminal_by_name$171$(_env$2, `${name}_prime`);
    moonbitlang$core$builtin$$Map$op_set$96$(nonterminal_meta_map, augmented_start_nt.num, moonbitlang$core$option$$Option$unwrap$108$(moonbitlang$core$builtin$$Map$op_get$96$(nonterminal_meta_map, start_nt.num)));
    const production = { num: productions.length, lhs: augmented_start_nt, rhs: [new $64$moonbitlang$47$yacc$47$lib$47$grm$46$Symbol$NT(start_nt)], prec: undefined };
    moonbitlang$core$array$$Array$push$126$(start_nt.references, { _0: production, _1: 0 });
    moonbitlang$core$array$$Array$push$26$(productions, production);
    return production;
  });
  const grammar = { starts: starts$2, terminals: terminals, nonterminals: nonterminals, productions: productions };
  const automaton = moonbitlang$yacc$lib$lr1$$Automaton$build(grammar);
  const errors = moonbitlang$yacc$lib$lr1$$resolve_conflicts(automaton.conflicts);
  const _len$6 = errors.length;
  let _tmp$6 = 0;
  while (true) {
    const _i = _tmp$6;
    if (_i < _len$6) {
      const error = errors[_i];
      switch (error.$tag) {
        case 0: {
          moonbitlang$yacc$lib$driver$util$$println_to_stderr("Reduce conflict resolved by presentation order");
          break;
        }
        case 1: {
          moonbitlang$yacc$lib$driver$util$$println_to_stderr("Shift-reduce conflict resolved without precedence");
          break;
        }
        default: {
          moonbitlang$yacc$lib$driver$util$$println_to_stderr("Shift-reduce conflict not resolved because of non-associativity");
        }
      }
      _tmp$6 = _i + 1 | 0;
      continue;
    } else {
      break;
    }
  }
  let _tmp$7;
  switch (mode.$tag) {
    case 2: {
      _tmp$7 = $panic();
      break;
    }
    case 0: {
      _tmp$7 = moonbitlang$core$option$$Option$or_default$7$(spec.header);
      break;
    }
    default: {
      _tmp$7 = "";
    }
  }
  const _tmp$8 = _tmp$7;
  let _tmp$9;
  switch (mode.$tag) {
    case 2: {
      _tmp$9 = $panic();
      break;
    }
    case 0: {
      _tmp$9 = moonbitlang$core$option$$Option$or_default$7$(spec.footer);
      break;
    }
    default: {
      _tmp$9 = "";
    }
  }
  const meta = { header: _tmp$8, footer: _tmp$9, position_data_type: position_data_type, terminal_meta: (name) => {
    const meta$2 = moonbitlang$core$builtin$$Map$get_or_init$95$(terminal_meta_map, moonbitlang$yacc$lib$driver$$compile$46$get_terminal_by_name$170$(_env, name).num, () => ({ data_type: undefined, image: undefined }));
    _L$2: {
      switch (mode.$tag) {
        case 2: {
          return $panic();
        }
        case 0: {
          break _L$2;
        }
        default: {
          const _JsonCst$2 = mode;
          const _x$2 = _JsonCst$2._0;
          if (_x$2 === undefined) {
            break _L$2;
          } else {
            const _Some = _x$2;
            const _x$3 = _Some;
            if (_x$3 === 0) {
              return { data_type: undefined, image: meta$2.image };
            } else {
              const _bind$2 = meta$2.data_type;
              const _tmp$10 = _bind$2 === undefined ? undefined : "Json";
              return { data_type: _tmp$10, image: meta$2.image };
            }
          }
        }
      }
    }
    return meta$2;
  }, nonterminal_meta: (name) => {
    switch (mode.$tag) {
      case 2: {
        return $panic();
      }
      case 0: {
        return moonbitlang$core$option$$Option$unwrap$108$(moonbitlang$core$builtin$$Map$op_get$96$(nonterminal_meta_map, moonbitlang$yacc$lib$driver$$compile$46$get_nonterminal_by_name$171$(_env$2, name).num));
      }
      default: {
        return { data_type: "Json" };
      }
    }
  }, production_meta: (num) => moonbitlang$core$option$$Option$unwrap$107$(moonbitlang$core$builtin$$Map$op_get$94$(production_meta_map, num)), derive_map: derive_map };
  const output_buffer = moonbitlang$core$builtin$$StringBuilder$new(moonbitlang$core$builtin$$StringBuilder$new$46$size_hint$46$default());
  const output = moonbitlang$yacc$lib$util$logger_with_cursor$$new({ self: output_buffer, method_0: moonbitlang$core$builtin$$StringBuilder$write_string, method_1: moonbitlang$core$builtin$$StringBuilder$write_substring, method_2: moonbitlang$core$builtin$$Logger$write_sub_string$79$, method_3: moonbitlang$core$builtin$$StringBuilder$write_char }, moonbitlang$yacc$lib$util$logger_with_cursor$$new$46$cursor$46$default());
  let _tmp$10;
  switch (mode.$tag) {
    case 2: {
      _tmp$10 = $panic();
      break;
    }
    case 0: {
      _tmp$10 = $64$moonbitlang$47$yacc$47$lib$47$codegen$46$Mode$Default;
      break;
    }
    default: {
      const _JsonCst$2 = mode;
      const _x$2 = _JsonCst$2._0;
      if (_x$2 === undefined) {
        _tmp$10 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$46$Mode$JsonCst(undefined);
      } else {
        const _Some = _x$2;
        const _x$3 = _Some;
        if (_x$3 === 0) {
          _tmp$10 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$46$Mode$JsonCst(0);
        } else {
          _tmp$10 = new $64$moonbitlang$47$yacc$47$lib$47$codegen$46$Mode$JsonCst(1);
        }
      }
    }
  }
  const _tmp$11 = _tmp$10;
  let _tmp$12;
  if (input_mode === 0) {
    _tmp$12 = 0;
  } else {
    _tmp$12 = 1;
  }
  moonbitlang$yacc$lib$codegen$gen_mbt$$codegen(grammar, automaton, meta, output, source_map_builder, filename, external_tokens, no_comments, _tmp$11, _tmp$12);
  return moonbitlang$core$builtin$$StringBuilder$to_string(output_buffer);
}
(() => {
  const output_file = moonbitlang$core$ref$$new$7$("");
  const output_map_file = moonbitlang$core$ref$$new$16$(undefined);
  const input_file = moonbitlang$core$ref$$new$7$("");
  const mode = moonbitlang$core$ref$$new$15$($64$moonbitlang$47$yacc$47$lib$47$driver$46$Mode$Default);
  const input_mode = moonbitlang$core$ref$$new$14$(0);
  const external_tokens = moonbitlang$core$ref$$new$13$(false);
  const no_comments = moonbitlang$core$ref$$new$13$(false);
  const token_payload_rewrite = moonbitlang$core$ref$$new$12$(undefined);
  Yoorkin$ArgParser$$parse([{ _0: "--output-file", _1: "-o", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Set_string(output_file), _3: "Output file" }, { _0: "--output-map-file", _1: "--output-map-file", _2: new $64$Yoorkin$47$ArgParser$46$Spec$String((file) => {
    output_map_file.val = file;
  }), _3: "Output source map file, if not specified, it will be the output file with .map.json extension" }, { _0: "--mode", _1: "--mode", _2: new $64$Yoorkin$47$ArgParser$46$Spec$String((mode_sym) => {
    let _tmp;
    switch (mode_sym) {
      case "default": {
        _tmp = $64$moonbitlang$47$yacc$47$lib$47$driver$46$Mode$Default;
        break;
      }
      case "json-cst": {
        _tmp = new $64$moonbitlang$47$yacc$47$lib$47$driver$46$Mode$JsonCst(undefined);
        break;
      }
      case "only-tokens": {
        _tmp = $64$moonbitlang$47$yacc$47$lib$47$driver$46$Mode$OnlyTokens;
        break;
      }
      default: {
        moonbitlang$yacc$lib$driver$util$$println_to_stderr(`Unsupported mode: ${mode_sym}`);
        _tmp = moonbitlang$yacc$lib$driver$util$$exit$15$(1);
      }
    }
    mode.val = _tmp;
  }), _3: "Specify mode (default, json-cst)" }, { _0: "--input-mode", _1: "--input-mode", _2: new $64$Yoorkin$47$ArgParser$46$Spec$String((input_mode_sym) => {
    switch (input_mode_sym) {
      case "array": {
        input_mode.val = 0;
        return;
      }
      case "pull": {
        input_mode.val = 1;
        return;
      }
      default: {
        moonbitlang$yacc$lib$driver$util$$println_to_stderr(`Unsupported input mode: ${input_mode_sym}`);
        moonbitlang$yacc$lib$driver$util$$exit$4$(1);
        return;
      }
    }
  }), _3: "Specify input mode (array, pull). Default is array" }, { _0: "--external-tokens", _1: "--external-tokens", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
    external_tokens.val = true;
  }), _3: "Use external tokens" }, { _0: "--force-token-json-payload", _1: "--force-token-json-payload", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
    token_payload_rewrite.val = 1;
  }), _3: "Force token to use JSON payload (only for json-cst mode)" }, { _0: "--force-token-no-payload", _1: "--force-token-no-payload", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
    token_payload_rewrite.val = 0;
  }), _3: "Force token to not use payload (only for json-cst mode)" }, { _0: "--no-comments", _1: "--no-comments", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
    no_comments.val = true;
  }), _3: "Do not include comments in the output" }, { _0: "--version", _1: "-v", _2: new $64$Yoorkin$47$ArgParser$46$Spec$Unit(() => {
    moonbitlang$core$builtin$$println$7$("moonyacc 0.1.0");
    moonbitlang$yacc$lib$driver$util$$exit$4$(0);
  }), _3: "Show version" }], (rest) => {
    input_file.val = rest;
  }, moonbitlang$yacc$main$$_init$42$46$usage$3$, moonbitlang$x$sys$$get_cli_args());
  if (moonbitlang$core$builtin$$op_notequal$7$(input_file.val, "")) {
    let parser_spec_src;
    let _try_err;
    _L: {
      _L$2: {
        const _bind = moonbitlang$x$fs$$read_file_to_string(input_file.val);
        if (_bind.$tag === 1) {
          const _ok = _bind;
          parser_spec_src = _ok._0;
        } else {
          const _err = _bind;
          const _tmp = _err._0;
          _try_err = _tmp;
          break _L$2;
        }
        break _L;
      }
      parser_spec_src = moonbitlang$core$builtin$$abort$7$(moonbitlang$core$builtin$$Show$to_string$147$(_try_err));
    }
    const _bind = mode.val;
    let mode$2;
    if (_bind.$tag === 1) {
      mode$2 = new $64$moonbitlang$47$yacc$47$lib$47$driver$46$Mode$JsonCst(token_payload_rewrite.val);
    } else {
      mode$2 = _bind;
    }
    const source_map = moonbitlang$yacc$lib$codegen$$SourceMap$new();
    const output = moonbitlang$yacc$lib$driver$$compile(parser_spec_src, mode$2, input_mode.val, input_file.val, external_tokens.val, no_comments.val, { self: source_map, method_0: moonbitlang$yacc$lib$codegen$$SourceMapBuilder$add_mapping$158$ });
    let file;
    _L$2: {
      if (output_file.val === "") {
        moonbitlang$core$builtin$$println$7$(output);
        const _bind$2 = output_map_file.val;
        if (_bind$2 === undefined) {
          return;
        } else {
          const _Some = _bind$2;
          const _x = _Some;
          file = _x;
          break _L$2;
        }
      } else {
        moonbitlang$x$fs$$write_string_to_file(output_file.val, output);
        const _tmp = moonbitlang$core$option$$Option$or$7$(output_map_file.val, `${output_file.val}.map.json`);
        file = _tmp;
        break _L$2;
      }
    }
    moonbitlang$x$fs$$write_string_to_file(file, moonbitlang$core$json$$Json$stringify(moonbitlang$core$builtin$$ToJson$to_json$158$(source_map), moonbitlang$core$json$$Json$stringify$46$escape_slash$46$default(), 2));
    return;
  } else {
    moonbitlang$yacc$lib$driver$util$$println_to_stderr("Input file is required");
    moonbitlang$yacc$lib$driver$util$$exit$4$(1);
    return;
  }
})();
